// Generated by Haxe 4.0.0-preview.4+1e3e5e016
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = {},$_;
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.strDate = function(s) {
	var _g = s.length;
	switch(_g) {
	case 8:
		var k = s.split(":");
		var d = new Date();
		d["setTime"](0);
		d["setUTCHours"](k[0]);
		d["setUTCMinutes"](k[1]);
		d["setUTCSeconds"](k[2]);
		return d;
	case 10:
		var k1 = s.split("-");
		return new Date(k1[0],k1[1] - 1,k1[2],0,0,0);
	case 19:
		var k2 = s.split(" ");
		var y = k2[0].split("-");
		var t = k2[1].split(":");
		return new Date(y[0],y[1] - 1,y[2],t[0],t[1],t[2]);
	default:
		throw new js__$Boot_HaxeError("Invalid date format : " + s);
	}
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
Math.__name__ = true;
var pot_core_App = function(canvas) {
	this.canvas = canvas;
	this.input = new pot_input_Input(canvas);
	this.pot = new pot_core_Pot(this,canvas);
	this.frameCount = 0;
	this.setup();
};
pot_core_App.__name__ = true;
pot_core_App.prototype = {
	setup: function() {
	}
	,loop: function() {
	}
};
var PendulumTest = function(canvas) {
	this.rewards = [];
	this.criticPlot = null;
	this.actorPlot = null;
	this.fastMode = false;
	pot_core_App.call(this,canvas);
};
PendulumTest.__name__ = true;
PendulumTest.main = function() {
	new PendulumTest(window.document.getElementById("canvas"));
};
PendulumTest.__super__ = pot_core_App;
PendulumTest.prototype = $extend(pot_core_App.prototype,{
	setup: function() {
		webdl_core_WebDL.setBackend("gpu");
		this.pot.size(400,300);
		this.pot.start();
		this.g = this.pot.graphics;
		this.g.init2D();
		this.initSim();
	}
	,initSim: function() {
		this.agent = new _$PendulumTest_PendulumAgent(0.05);
		var ds = new webdl_rl_ddpg_DDPGSetting(this.agent,3,[[-4.,4]]);
		ds.numHiddenUnits = 64;
		ds.numHiddenLayers = 2;
		ds.maxEpisodeLength = 240;
		ds.startReplay = 2000;
		ds.updateInterval = 2;
		this.ddpg = new webdl_rl_ddpg_DDPG(ds);
		this.updates = this.ddpg.actor.network.updates.concat(this.ddpg.critic.network.updates);
	}
	,loop: function() {
		var _gthis = this;
		if(this.input.mouse.dleft == 1) {
			this.fastMode = !this.fastMode;
		}
		if(this.input.mouse.dright == 1) {
			window.console.log("[" + this.rewards.join(",") + "];");
		}
		if(this.fastMode) {
			var _g = 0;
			while(_g < 20) {
				var i = _g++;
				if(this.ddpg.step()) {
					webdl_core_WebDL.run(this.updates);
				}
				if(this.ddpg.episodeTime == 0) {
					this.rewards.push(this.ddpg.totalRewardInLastEpisode);
				}
			}
		} else {
			var st = new Date().getTime() / 1000;
			if(this.ddpg.step()) {
				webdl_core_WebDL.run(this.updates);
			}
			if(this.ddpg.episodeTime == 0) {
				this.rewards.push(this.ddpg.totalRewardInLastEpisode);
			}
			var en = new Date().getTime() / 1000;
		}
		this.g.beginScene();
		var _this = this.g;
		_this.gl.clearColor(0.9,0.9,0.9,1);
		_this.gl.clearDepth(1);
		_this.gl.clear(16640);
		this.g.pushMatrix();
		this.g.modelMat.appendTranslation(this.pot.width * 0.5,this.pot.height * 0.5,0);
		var _this1 = this.g;
		_this1.colorR = 0;
		_this1.colorG = 0;
		_this1.colorB = 0;
		_this1.colorA = 1;
		this.g.modelMat.appendRotation(-this.agent.theta,0,0,1);
		var len = Math.min(this.pot.width,this.pot.height) * 0.3;
		var wid = len * 0.05;
		this.g.rect(-wid,-wid - len,wid * 2,wid * 2 + len);
		this.g.popMatrix();
		this.plot2D(-Math.PI,Math.PI,-8.,8,32,128,function(angVels) {
			if(_gthis.actorPlot == null || _gthis.frameCount % 1 == 0) {
				var _g1 = [];
				var _g11 = 0;
				while(_g11 < angVels.length) {
					var angVel = angVels[_g11];
					++_g11;
					_g1.push([Math.cos(angVel[0]),Math.sin(angVel[0]),angVel[1]]);
				}
				var states = _g1;
				var _gthis1 = _gthis.ddpg.actor.network.isTraining;
				var this1 = _gthis.input.keyboard;
				var code = 65;
				if(!this1.keys.h.hasOwnProperty(code)) {
					var this2 = this1.keys;
					var value = new pot_input_Key();
					this2.h[code] = value;
				}
				_gthis1.set0D(this1.keys.h[code].down ? 1 : 0);
				var actions = _gthis.ddpg.computeActions(states);
				_gthis.ddpg.actor.network.isTraining.set0D(0);
				var _g12 = [];
				var _g2 = 0;
				while(_g2 < actions.length) {
					var action = actions[_g2];
					++_g2;
					_g12.push(action[0] / 4);
				}
				_gthis.actorPlot = _g12;
			}
			return _gthis.actorPlot;
		},[[Math.atan2(this.ddpg.lastState[1],this.ddpg.lastState[0]),this.ddpg.lastState[2]]]);
		this.g.modelMat.appendTranslation(this.pot.width - 128,0,0);
		var currentState = this.ddpg.lastState;
		var currentAction = this.ddpg.lastActionWithoutNoise;
		var currentValue = this.ddpg.lastValueWithoutNoise;
		this.plot2D(-8.,8,-4.,4,32,128,function(velTorques) {
			if(_gthis.criticPlot == null || _gthis.frameCount % 3 == 0) {
				var _g3 = [];
				var _g13 = 0;
				while(_g13 < velTorques.length) {
					var velTorque = velTorques[_g13];
					++_g13;
					_g3.push([currentState[0],currentState[1],velTorque[0]]);
				}
				var states1 = _g3;
				var _g14 = [];
				var _g21 = 0;
				while(_g21 < velTorques.length) {
					var velTorque1 = velTorques[_g21];
					++_g21;
					_g14.push([velTorque1[1]]);
				}
				var actions1 = _g14;
				var _gthis2 = _gthis.ddpg.critic.network.isTraining;
				var this11 = _gthis.input.keyboard;
				var code1 = 65;
				if(!this11.keys.h.hasOwnProperty(code1)) {
					var this21 = this11.keys;
					var value1 = new pot_input_Key();
					this21.h[code1] = value1;
				}
				_gthis2.set0D(this11.keys.h[code1].down ? 1 : 0);
				var values = _gthis.ddpg.computeValues(states1,actions1);
				_gthis.ddpg.critic.network.isTraining.set0D(0);
				var _g22 = [];
				var _g31 = 0;
				while(_g31 < values.length) {
					var value2 = values[_g31];
					++_g31;
					_g22.push(value2 - currentValue);
				}
				_gthis.criticPlot = _g22;
			}
			return _gthis.criticPlot;
		},[[currentState[2],currentAction[0]]]);
		var tmp = "Action with noise: " + Std.string(this.ddpg.lastAction) + "<br>Action without noise: " + Std.string(this.ddpg.lastActionWithoutNoise) + "<br>Episode: " + this.ddpg.episode + "<br>Value: " + this.ddpg.lastValueWithoutNoise + "<br>Elapsed: ";
		window.document.getElementById("text").innerHTML = tmp + this.ddpg.episodeTime;
		var _this2 = this.g;
		if(!_this2.sceneOpen) {
			throw new Error("scene already ended");
		}
		_this2.sceneOpen = false;
		_this2.gl.flush();
	}
	,plot2D: function(sx1,sx2,sy1,sy2,div,size,xysToVals,points) {
		var dx = (sx2 - sx1) / div;
		var dy = (sy2 - sy1) / div;
		var blockSize = size / div;
		this.g.beginShape(4);
		var xys = [];
		var y = sy1;
		var _g1 = 0;
		var _g = div;
		while(_g1 < _g) {
			var i = _g1++;
			var x = sx1;
			var _g3 = 0;
			var _g2 = div;
			while(_g3 < _g2) {
				var j = _g3++;
				xys.push([x,y]);
				x += dx;
			}
			y += dy;
		}
		var vals = xysToVals(xys);
		var c = 0;
		var y1 = sy1;
		var _g11 = 0;
		var _g4 = div;
		while(_g11 < _g4) {
			var i1 = _g11++;
			var x1 = sx1;
			var _g31 = 0;
			var _g21 = div;
			while(_g31 < _g21) {
				var j1 = _g31++;
				var val = vals[c++];
				var _this = this.g;
				_this.colorR = 0.5 + val * 0.5;
				_this.colorG = 0;
				_this.colorB = 0.5 - val * 0.5;
				_this.colorA = 1;
				var bx1 = blockSize * j1;
				var by1 = blockSize * i1;
				var bx2 = blockSize * j1 + blockSize;
				var by2 = blockSize * i1 + blockSize;
				this.g.vertex(bx1,by1);
				this.g.vertex(bx1,by2);
				this.g.vertex(bx2,by2);
				this.g.vertex(bx1,by1);
				this.g.vertex(bx2,by2);
				this.g.vertex(bx2,by1);
				x1 += dx;
			}
			y1 += dy;
		}
		var _this1 = this.g;
		_this1.colorR = 1;
		_this1.colorG = 1;
		_this1.colorB = 1;
		_this1.colorA = 1;
		var _g5 = 0;
		while(_g5 < points.length) {
			var point = points[_g5];
			++_g5;
			var posx = (point[0] - sx1) / (sx2 - sx1);
			var posy = (point[1] - sy1) / (sy2 - sy1);
			posx *= size;
			posy *= size;
			this.g.vertex(posx - 2,posy - 2);
			this.g.vertex(posx - 2,posy + 2);
			this.g.vertex(posx + 2,posy + 2);
			this.g.vertex(posx - 2,posy - 2);
			this.g.vertex(posx + 2,posy + 2);
			this.g.vertex(posx + 2,posy - 2);
		}
		var _this2 = this.g;
		var shader = _this2.chooseShader();
		var pg = shader.pg;
		_this2.modelviewMat.mul(_this2.viewMat,_this2.modelMat);
		_this2.normalMat.inverse(_this2.modelviewMat);
		_this2.normalMat.transpose(_this2.normalMat);
		var tmp;
		var _this3 = shader.map;
		if(__map_reserved["model"] != null ? _this3.existsReserved("model") : _this3.h.hasOwnProperty("model")) {
			var _this11 = shader.map;
			tmp = __map_reserved["model"] != null ? _this11.getReserved("model") : _this11.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this21 = shader.map;
			if(__map_reserved["model"] != null) {
				_this21.setReserved("model",ul);
			} else {
				_this21.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",_this2.modelMat.array);
		}
		var tmp1;
		var _this31 = shader.map;
		if(__map_reserved["view"] != null ? _this31.existsReserved("view") : _this31.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",_this2.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",_this2.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this111 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this111.setReserved("transform",ul3);
			} else {
				_this111.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			_this2.mvpMat.mul(_this2.projMat,_this2.modelviewMat);
			shader.setMatrix("transform",_this2.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",_this2.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			_this2.normalMat.toMat3();
			shader.setMatrix("normalMatrix",_this2.normalMat.array3);
		}
		if(_this2.currentTexture != null) {
			shader.setTexture("texture",_this2.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",_this2.currentTexture.textureWidth,_this2.currentTexture.textureHeight);
			}
			var tmp7;
			var _this211 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this211.existsReserved("texViewport") : _this211.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x2 = 0;
				var y2 = 1 - _this2.currentTexture.height / _this2.currentTexture.textureHeight;
				var w = _this2.currentTexture.width / _this2.currentTexture.textureWidth;
				var h = _this2.currentTexture.height / _this2.currentTexture.textureHeight;
				shader.setFloat("texViewport",x2,y2,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",_this2.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",_this2.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this311 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this311.getReserved("specular") : _this311.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",_this2.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",_this2.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",_this2.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",_this2.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g12 = 0;
			var _g6 = _this2.numLights;
			while(_g12 < _g6) {
				var i2 = _g12++;
				var light = _this2.lightBuf[i2];
				var x11 = light.posX * _this2.viewMat.array[0] + light.posY * _this2.viewMat.array[4] + light.posZ * _this2.viewMat.array[8] + _this2.viewMat.array[12];
				var y11 = light.posX * _this2.viewMat.array[1] + light.posY * _this2.viewMat.array[5] + light.posZ * _this2.viewMat.array[9] + _this2.viewMat.array[13];
				var z = light.posX * _this2.viewMat.array[2] + light.posY * _this2.viewMat.array[6] + light.posZ * _this2.viewMat.array[10] + _this2.viewMat.array[14];
				shader.setFloat("lightPositions[" + i2 + "]",x11,y11,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g111 = 0;
			var _g22 = _this2.numLights;
			while(_g111 < _g22) {
				var i11 = _g111++;
				var light1 = _this2.lightBuf[i11];
				var x21 = light1.norX * _this2.viewMat.array[0] + light1.norY * _this2.viewMat.array[4] + light1.norZ * _this2.viewMat.array[8];
				var y21 = light1.norX * _this2.viewMat.array[1] + light1.norY * _this2.viewMat.array[5] + light1.norZ * _this2.viewMat.array[9];
				var z1 = light1.norX * _this2.viewMat.array[2] + light1.norY * _this2.viewMat.array[6] + light1.norZ * _this2.viewMat.array[10];
				shader.setFloat("lightNormals[" + i11 + "]",x21,y21,z1);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g121 = 0;
			var _g32 = _this2.numLights;
			while(_g121 < _g32) {
				var i21 = _g121++;
				var light2 = _this2.lightBuf[i21];
				shader.setFloat("lightColors[" + i21 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = _this2.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = _this2.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = _this2.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = _this2.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = _this2.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = _this2.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = _this2.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = _this2.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = _this2.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name1 = shader.uniforms.keys();
		while(name1.hasNext()) {
			var name11 = name1.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name11] != null ? _this60.getReserved(name11) : _this60.h[name11];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name3 = shader.uniforms.keys();
		while(name3.hasNext()) {
			var name31 = name3.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name31] != null ? _this61.getReserved(name31) : _this61.h[name31];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name31] != null ? _this62.existsReserved(name31) : _this62.h.hasOwnProperty(name31)) {
				var _this63 = shader.map;
				loc = __map_reserved[name31] != null ? _this63.getReserved(name31) : _this63.h[name31];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name31);
				var _this64 = shader.map;
				if(__map_reserved[name31] != null) {
					_this64.setReserved(name31,ul17);
				} else {
					_this64.h[name31] = ul17;
				}
				loc = ul17;
			}
			var _g41 = uniform1.type;
			switch(_g41) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = _this2.indexBuf;
		var mode = _this2.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
	}
	,setText: function(text) {
		window.document.getElementById("text").textContent = text;
	}
});
var webdl_rl_ddpg_Agent = function() { };
webdl_rl_ddpg_Agent.__name__ = true;
var _$PendulumTest_PendulumAgent = function(dt) {
	this.dt = dt;
};
_$PendulumTest_PendulumAgent.__name__ = true;
_$PendulumTest_PendulumAgent.__interfaces__ = [webdl_rl_ddpg_Agent];
_$PendulumTest_PendulumAgent.prototype = {
	reset: function() {
		this.theta = (Math.random() * 2 + -1) * Math.PI;
		this.thetaDot = Math.random() * 2 + -1;
		return [Math.cos(this.theta),Math.sin(this.theta),this.thetaDot];
	}
	,step: function(action) {
		var g = 15;
		var x = action[0];
		this.torque = x < -4. ? -4. : x > 4 ? 4 : x;
		var x1 = this.thetaDot += (this.torque + g * Math.sin(this.theta)) * this.dt;
		this.thetaDot = x1 < -8. ? -8. : x1 > 8 ? 8 : x1;
		this.theta += this.thetaDot * this.dt;
		var pi = Math.PI;
		var pi2 = pi * 2;
		this.theta = ((this.theta + pi) % pi2 + pi2) % pi2 - pi;
		var cost = this.theta * this.theta + this.thetaDot * this.thetaDot * 0.001 + this.torque * this.torque * 0.001;
		cost = this.theta * this.theta;
		return { nextState : [Math.cos(this.theta),Math.sin(this.theta),this.thetaDot], reward : -cost, done : false};
	}
	,clamp: function(x,min,max) {
		if(x < min) {
			return min;
		} else if(x > max) {
			return max;
		} else {
			return x;
		}
	}
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.random = function(x) {
	if(x <= 0) {
		return 0;
	} else {
		return Math.floor(Math.random() * x);
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe__$Int64__$_$_$Int64 = function(high,low) {
	this.high = high;
	this.low = low;
};
haxe__$Int64__$_$_$Int64.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,iterator: function() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			var i = this.it.next();
			return this.ref[i];
		}};
	}
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
};
var haxe_ds__$Vector_Vector_$Impl_$ = {};
haxe_ds__$Vector_Vector_$Impl_$.__name__ = true;
haxe_ds__$Vector_Vector_$Impl_$.blit = function(src,srcPos,dest,destPos,len) {
	if(src == dest) {
		if(srcPos < destPos) {
			var i = srcPos + len;
			var j = destPos + len;
			var _g1 = 0;
			var _g = len;
			while(_g1 < _g) {
				var k = _g1++;
				--i;
				--j;
				src[j] = src[i];
			}
		} else if(srcPos > destPos) {
			var i1 = srcPos;
			var j1 = destPos;
			var _g11 = 0;
			var _g2 = len;
			while(_g11 < _g2) {
				var k1 = _g11++;
				src[j1] = src[i1];
				++i1;
				++j1;
			}
		}
	} else {
		var _g12 = 0;
		var _g3 = len;
		while(_g12 < _g3) {
			var i2 = _g12++;
			dest[destPos + i2] = src[srcPos + i2];
		}
	}
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.ofString = function(s) {
	var a = [];
	var i = 0;
	while(i < s.length) {
		var c = s.charCodeAt(i++);
		if(55296 <= c && c <= 56319) {
			c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
		}
		if(c <= 127) {
			a.push(c);
		} else if(c <= 2047) {
			a.push(192 | c >> 6);
			a.push(128 | c & 63);
		} else if(c <= 65535) {
			a.push(224 | c >> 12);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		} else {
			a.push(240 | c >> 18);
			a.push(128 | c >> 12 & 63);
			a.push(128 | c >> 6 & 63);
			a.push(128 | c & 63);
		}
	}
	return new haxe_io_Bytes(new Uint8Array(a).buffer);
};
haxe_io_Bytes.prototype = {
	getString: function(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var s = "";
		var b = this.b;
		var fcc = String.fromCharCode;
		var i = pos;
		var max = pos + len;
		while(i < max) {
			var c = b[i++];
			if(c < 128) {
				if(c == 0) {
					break;
				}
				s += fcc(c);
			} else if(c < 224) {
				s += fcc((c & 63) << 6 | b[i++] & 127);
			} else if(c < 240) {
				var c2 = b[i++];
				s += fcc((c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127);
			} else {
				var c21 = b[i++];
				var c3 = b[i++];
				var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
				s += fcc((u >> 10) + 55232);
				s += fcc(u & 1023 | 56320);
			}
		}
		return s;
	}
	,toString: function() {
		return this.getString(0,this.length);
	}
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	addByte: function(byte) {
		if(this.pos == this.size) {
			this.grow(1);
		}
		this.view.setUint8(this.pos++,byte);
	}
	,addBytes: function(src,pos,len) {
		if(pos < 0 || len < 0 || pos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.pos + len > this.size) {
			this.grow(len);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset + pos,len);
		this.u8.set(sub,this.pos);
		this.pos += len;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
};
var haxe_io_Input = function() { };
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			var eof1 = (eof instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if((eof1 instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
	,close: function() {
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,readFloat: function() {
		return haxe_io_FPHelper.i32ToFloat(this.readInt32());
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.toString();
	}
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
});
var haxe_io_Output = function() { };
haxe_io_Output.__name__ = true;
haxe_io_Output.prototype = {
	writeByte: function(c) {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,writeBytes: function(s,pos,len) {
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		var b = s.b;
		var k = len;
		while(k > 0) {
			this.writeByte(b[pos]);
			++pos;
			--k;
		}
		return len;
	}
	,close: function() {
	}
	,writeFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.writeBytes(s,pos,len);
			pos += k;
			len -= k;
		}
	}
	,writeFloat: function(x) {
		this.writeInt32(haxe_io_FPHelper.floatToI32(x));
	}
	,writeInt32: function(x) {
		if(this.bigEndian) {
			this.writeByte(x >>> 24);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x & 255);
		} else {
			this.writeByte(x & 255);
			this.writeByte(x >> 8 & 255);
			this.writeByte(x >> 16 & 255);
			this.writeByte(x >>> 24);
		}
	}
	,writeString: function(s) {
		var b = haxe_io_Bytes.ofString(s);
		this.writeFullBytes(b,0,b.length);
	}
};
var haxe_io_BytesOutput = function() {
	this.b = new haxe_io_BytesBuffer();
};
haxe_io_BytesOutput.__name__ = true;
haxe_io_BytesOutput.__super__ = haxe_io_Output;
haxe_io_BytesOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		this.b.addByte(c);
	}
	,writeBytes: function(buf,pos,len) {
		this.b.addBytes(buf,pos,len);
		return len;
	}
	,getBytes: function() {
		return this.b.getBytes();
	}
});
var haxe_io_Eof = function() {
};
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_io_FPHelper = function() { };
haxe_io_FPHelper.__name__ = true;
haxe_io_FPHelper.i32ToFloat = function(i) {
	haxe_io_FPHelper.helper.setInt32(0,i,true);
	return haxe_io_FPHelper.helper.getFloat32(0,true);
};
haxe_io_FPHelper.floatToI32 = function(f) {
	haxe_io_FPHelper.helper.setFloat32(0,f,true);
	return haxe_io_FPHelper.helper.getInt32(0,true);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g11 = 0;
			var _g3 = l;
			while(_g11 < _g3) {
				var i1 = _g11++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
var js_Browser = function() { };
js_Browser.__name__ = true;
js_Browser.alert = function(v) {
	window.alert(js_Boot.__string_rec(v,""));
};
var js_html__$CanvasElement_CanvasUtil = function() { };
js_html__$CanvasElement_CanvasUtil.__name__ = true;
js_html__$CanvasElement_CanvasUtil.getContextWebGL = function(canvas,attribs) {
	var name = "webgl";
	var ctx = canvas.getContext(name,attribs);
	if(ctx != null) {
		return ctx;
	}
	var name1 = "experimental-webgl";
	var ctx1 = canvas.getContext(name1,attribs);
	if(ctx1 != null) {
		return ctx1;
	}
	return null;
};
var js_html_compat_ArrayBuffer = function(a) {
	if((a instanceof Array) && a.__enum__ == null) {
		this.a = a;
		this.byteLength = a.length;
	} else {
		var len = a;
		this.a = [];
		var _g1 = 0;
		var _g = len;
		while(_g1 < _g) {
			var i = _g1++;
			this.a[i] = 0;
		}
		this.byteLength = len;
	}
};
js_html_compat_ArrayBuffer.__name__ = true;
js_html_compat_ArrayBuffer.sliceImpl = function(begin,end) {
	var u = new Uint8Array(this,begin,end == null ? null : end - begin);
	var result = new ArrayBuffer(u.byteLength);
	var resultArray = new Uint8Array(result);
	resultArray.set(u);
	return result;
};
js_html_compat_ArrayBuffer.prototype = {
	slice: function(begin,end) {
		return new js_html_compat_ArrayBuffer(this.a.slice(begin,end));
	}
};
var js_html_compat_DataView = function(buffer,byteOffset,byteLength) {
	this.buf = buffer;
	this.offset = byteOffset == null ? 0 : byteOffset;
	this.length = byteLength == null ? buffer.byteLength - this.offset : byteLength;
	if(this.offset < 0 || this.length < 0 || this.offset + this.length > buffer.byteLength) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.byteLength = this.length;
	this.byteOffset = this.offset;
	this.buffer = this.buf;
};
js_html_compat_DataView.__name__ = true;
js_html_compat_DataView.prototype = {
	getInt8: function(byteOffset) {
		var v = this.buf.a[this.offset + byteOffset];
		if(v >= 128) {
			return v - 256;
		} else {
			return v;
		}
	}
	,getUint8: function(byteOffset) {
		return this.buf.a[this.offset + byteOffset];
	}
	,getInt16: function(byteOffset,littleEndian) {
		var v = this.getUint16(byteOffset,littleEndian);
		if(v >= 32768) {
			return v - 65536;
		} else {
			return v;
		}
	}
	,getUint16: function(byteOffset,littleEndian) {
		if(littleEndian) {
			return this.buf.a[this.offset + byteOffset] | this.buf.a[this.offset + byteOffset + 1] << 8;
		} else {
			return this.buf.a[this.offset + byteOffset] << 8 | this.buf.a[this.offset + byteOffset + 1];
		}
	}
	,getInt32: function(byteOffset,littleEndian) {
		var p = this.offset + byteOffset;
		var a = this.buf.a[p++];
		var b = this.buf.a[p++];
		var c = this.buf.a[p++];
		var d = this.buf.a[p++];
		if(littleEndian) {
			return a | b << 8 | c << 16 | d << 24;
		} else {
			return d | c << 8 | b << 16 | a << 24;
		}
	}
	,getUint32: function(byteOffset,littleEndian) {
		var v = this.getInt32(byteOffset,littleEndian);
		if(v < 0) {
			return v + 4294967296.;
		} else {
			return v;
		}
	}
	,getFloat32: function(byteOffset,littleEndian) {
		var i = this.getInt32(byteOffset,littleEndian);
		var sign = 1 - (i >>> 31 << 1);
		var e = i >> 23 & 255;
		if(e == 255) {
			if((i & 8388607) == 0) {
				if(sign > 0) {
					return Infinity;
				} else {
					return -Infinity;
				}
			} else {
				return NaN;
			}
		} else {
			var m = e == 0 ? (i & 8388607) << 1 : i & 8388607 | 8388608;
			return sign * m * Math.pow(2,e - 150);
		}
	}
	,getFloat64: function(byteOffset,littleEndian) {
		var a = this.getInt32(byteOffset,littleEndian);
		var b = this.getInt32(byteOffset + 4,littleEndian);
		var lo = littleEndian ? a : b;
		var hi = littleEndian ? b : a;
		var sign = 1 - (hi >>> 31 << 1);
		var e = hi >> 20 & 2047;
		if(e == 2047) {
			if(lo == 0 && (hi & 1048575) == 0) {
				if(sign > 0) {
					return Infinity;
				} else {
					return -Infinity;
				}
			} else {
				return NaN;
			}
		} else {
			var m = 2.220446049250313e-16 * ((hi & 1048575) * 4294967296. + (lo >>> 31) * 2147483648. + (lo & 2147483647));
			if(e == 0) {
				m *= 2.0;
			} else {
				m += 1.0;
			}
			return sign * m * Math.pow(2,e - 1023);
		}
	}
	,setInt8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value < 0 ? value + 128 & 255 : value & 255;
	}
	,setUint8: function(byteOffset,value) {
		this.buf.a[byteOffset + this.offset] = value & 255;
	}
	,setInt16: function(byteOffset,value,littleEndian) {
		this.setUint16(byteOffset,value < 0 ? value + 65536 : value,littleEndian);
	}
	,setUint16: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p++] = value & 255;
			this.buf.a[p] = value >> 8 & 255;
		} else {
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p] = value & 255;
		}
	}
	,setInt32: function(byteOffset,value,littleEndian) {
		this.setUint32(byteOffset,value,littleEndian);
	}
	,setUint32: function(byteOffset,value,littleEndian) {
		var p = byteOffset + this.offset;
		if(littleEndian) {
			this.buf.a[p++] = value & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >>> 24;
		} else {
			this.buf.a[p++] = value >>> 24;
			this.buf.a[p++] = value >> 16 & 255;
			this.buf.a[p++] = value >> 8 & 255;
			this.buf.a[p++] = value & 255;
		}
	}
	,setFloat32: function(byteOffset,value,littleEndian) {
		var tmp;
		if(value == 0) {
			tmp = 0;
		} else {
			var af = value < 0 ? -value : value;
			var exp = Math.floor(Math.log(af) / 0.6931471805599453);
			if(exp > 127) {
				tmp = 2139095040;
			} else {
				if(exp <= -127) {
					exp = -127;
					af *= 7.1362384635298e+44;
				} else {
					af = (af / Math.pow(2,exp) - 1.0) * 8388608;
				}
				tmp = (value < 0 ? -2147483648 : 0) | exp + 127 << 23 | Math.round(af);
			}
		}
		this.setUint32(byteOffset,tmp,littleEndian);
	}
	,setFloat64: function(byteOffset,value,littleEndian) {
		var i64 = haxe_io_FPHelper.i64tmp;
		if(value == 0) {
			i64.low = 0;
			i64.high = 0;
		} else if(!isFinite(value)) {
			i64.low = 0;
			i64.high = value > 0 ? 2146435072 : -1048576;
		} else {
			var av = value < 0 ? -value : value;
			var exp = Math.floor(Math.log(av) / 0.6931471805599453);
			if(exp > 1023) {
				i64.low = -1;
				i64.high = 2146435071;
			} else {
				if(exp <= -1023) {
					exp = -1023;
					av /= 2.2250738585072014e-308;
				} else {
					av = av / Math.pow(2,exp) - 1.0;
				}
				var sig = Math.round(av * 4503599627370496.);
				var sig_l = sig | 0;
				var sig_h = sig / 4294967296.0 | 0;
				i64.low = sig_l;
				i64.high = (value < 0 ? -2147483648 : 0) | exp + 1023 << 20 | sig_h;
			}
		}
		var i641 = i64;
		if(littleEndian) {
			this.setUint32(byteOffset,i641.low,true);
			this.setUint32(byteOffset + 4,i641.high,true);
		} else {
			this.setUint32(byteOffset,i641.high,false);
			this.setUint32(byteOffset + 4,i641.low,false);
		}
	}
};
var js_html_compat_Float32Array = function() { };
js_html_compat_Float32Array.__name__ = true;
js_html_compat_Float32Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		var _g2 = [];
		var _g21 = 0;
		var _g11 = arr.length << 2;
		while(_g21 < _g11) {
			var i1 = _g21++;
			_g2.push(0);
		}
		arr.buffer = new js_html_compat_ArrayBuffer(_g2);
	} else if((arg1 instanceof js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset >> 2;
		}
		arr = [];
		var _g12 = 0;
		var _g3 = length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var val = buffer.a[offset++] | buffer.a[offset++] << 8 | buffer.a[offset++] << 16 | buffer.a[offset++] << 24;
			arr.push(haxe_io_FPHelper.i32ToFloat(val));
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		var buffer1 = [];
		var _g4 = 0;
		while(_g4 < arr.length) {
			var f = arr[_g4];
			++_g4;
			var i3 = haxe_io_FPHelper.floatToI32(f);
			buffer1.push(i3 & 255);
			buffer1.push(i3 >> 8 & 255);
			buffer1.push(i3 >> 16 & 255);
			buffer1.push(i3 >>> 24);
		}
		arr.byteLength = arr.length << 2;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(buffer1);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Float32Array._subarray;
	arr.set = js_html_compat_Float32Array._set;
	return arr;
};
js_html_compat_Float32Array._set = function(arg,offset) {
	if(offset == null) {
		offset = 0;
	}
	if((arg.buffer instanceof js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Float32Array._subarray = function(start,end) {
	var a = js_html_compat_Float32Array._new(this.slice(start,end));
	a.byteOffset = start * 4;
	return a;
};
var js_html_compat_Uint8Array = function() { };
js_html_compat_Uint8Array.__name__ = true;
js_html_compat_Uint8Array._new = function(arg1,offset,length) {
	var arr;
	if(typeof(arg1) == "number") {
		arr = [];
		var _g1 = 0;
		var _g = arg1;
		while(_g1 < _g) {
			var i = _g1++;
			arr[i] = 0;
		}
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else if((arg1 instanceof js_html_compat_ArrayBuffer)) {
		var buffer = arg1;
		if(offset == null) {
			offset = 0;
		}
		if(length == null) {
			length = buffer.byteLength - offset;
		}
		if(offset == 0) {
			arr = buffer.a;
		} else {
			arr = buffer.a.slice(offset,offset + length);
		}
		arr.byteLength = arr.length;
		arr.byteOffset = offset;
		arr.buffer = buffer;
	} else if((arg1 instanceof Array) && arg1.__enum__ == null) {
		arr = arg1.slice();
		arr.byteLength = arr.length;
		arr.byteOffset = 0;
		arr.buffer = new js_html_compat_ArrayBuffer(arr);
	} else {
		throw new js__$Boot_HaxeError("TODO " + Std.string(arg1));
	}
	arr.subarray = js_html_compat_Uint8Array._subarray;
	arr.set = js_html_compat_Uint8Array._set;
	return arr;
};
js_html_compat_Uint8Array._set = function(arg,offset) {
	if(offset == null) {
		offset = 0;
	}
	if((arg.buffer instanceof js_html_compat_ArrayBuffer)) {
		var a = arg;
		if(arg.byteLength + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g1 = 0;
		var _g = arg.byteLength;
		while(_g1 < _g) {
			var i = _g1++;
			this[i + offset] = a[i];
		}
	} else if((arg instanceof Array) && arg.__enum__ == null) {
		var a1 = arg;
		if(a1.length + offset > this.byteLength) {
			throw new js__$Boot_HaxeError("set() outside of range");
		}
		var _g11 = 0;
		var _g2 = a1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			this[i1 + offset] = a1[i1];
		}
	} else {
		throw new js__$Boot_HaxeError("TODO");
	}
};
js_html_compat_Uint8Array._subarray = function(start,end) {
	var a = js_html_compat_Uint8Array._new(this.slice(start,end));
	a.byteOffset = start;
	return a;
};
var pot_core_Pot = function(app,canvas) {
	this.app = app;
	this.canvas = canvas;
	this.graphics = new pot_graphics_Graphics(canvas);
	this.timer = new pot_util_Timer($bind(this,this.frame));
};
pot_core_Pot.__name__ = true;
pot_core_Pot.prototype = {
	size: function(width,height) {
		this.width = width;
		this.height = height;
		this.canvas.width = width;
		this.canvas.height = height;
		this.canvas.style.width = width + "px";
		this.canvas.style.height = height + "px";
		var _this = this.graphics;
		_this.screenWidth = width;
		_this.screenHeight = height;
		if(_this.currentRenderTarget == null) {
			var width1;
			var height1;
			var targetHeight;
			if(_this.currentRenderTarget == null) {
				width1 = _this.canvas.width;
				height1 = _this.canvas.height;
				targetHeight = height1;
			} else {
				width1 = _this.currentRenderTarget.width;
				height1 = _this.currentRenderTarget.height;
				targetHeight = _this.currentRenderTarget.textureHeight;
			}
			_this.gl.viewport(0,targetHeight - height1,width1,height1);
		}
		var fovY = null;
		var near = null;
		var far = null;
		if(fovY == null) {
			fovY = Math.PI / 3;
		}
		if(near == null) {
			near = 0.1;
		}
		if(far == null) {
			far = 1000;
		}
		_this.cameraFov = fovY;
		_this.cameraNear = near;
		_this.cameraFar = far;
		_this.projMat.perspective(fovY,_this.screenWidth / _this.screenHeight,near,far);
	}
	,frameRate: function(fps) {
		this.timer.setFrameRate(fps);
	}
	,start: function() {
		this.timer.start();
	}
	,stop: function() {
		this.timer.stop();
	}
	,frame: function() {
		this.app.input.update();
		this.app.loop();
		this.app.frameCount++;
	}
};
var pot_graphics_Graphics = function(canvas) {
	this.canvas = canvas;
	this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(canvas,null);
	this.initGL();
	this.initShaders();
	this.initBuffers();
	this.initMatricies();
	this.cameraNear = 0.1;
	this.cameraFar = 10000;
	this.cameraFov = Math.PI / 3;
	this.cameraSet = false;
	this.cameraPosX = 0;
	this.cameraPosY = 0;
	this.cameraPosZ = 1;
	this.cameraAtX = 0;
	this.cameraAtY = 0;
	this.cameraAtZ = 0;
	this.cameraUpX = 0;
	this.cameraUpY = 1;
	this.cameraUpZ = 0;
	this.screenWidth = canvas.width;
	this.screenHeight = canvas.height;
	if(this.currentRenderTarget == null) {
		var width;
		var height;
		var targetHeight;
		if(this.currentRenderTarget == null) {
			width = this.canvas.width;
			height = this.canvas.height;
			targetHeight = height;
		} else {
			width = this.currentRenderTarget.width;
			height = this.currentRenderTarget.height;
			targetHeight = this.currentRenderTarget.textureHeight;
		}
		this.gl.viewport(0,targetHeight - height,width,height);
	}
	var fovY = null;
	var near = null;
	var far = null;
	if(fovY == null) {
		fovY = Math.PI / 3;
	}
	if(near == null) {
		near = 0.1;
	}
	if(far == null) {
		far = 1000;
	}
	this.cameraFov = fovY;
	this.cameraNear = near;
	this.cameraFar = far;
	this.projMat.perspective(fovY,this.screenWidth / this.screenHeight,near,far);
	this.numVertices = 0;
	this.colorR = 1;
	this.colorG = 1;
	this.colorB = 1;
	this.colorA = 1;
	this.normalX = 0;
	this.normalY = 0;
	this.normalZ = 0;
	this.texCoordU = 0;
	this.texCoordV = 0;
	var this1 = new Array(1024);
	this.matStack = this1;
	this.matStackCount = 0;
	this.currentTexture = null;
	this.currentRenderTarget = null;
	this.texMode = 1;
	this.sceneOpen = false;
	var this2 = new Array(8);
	this.lightBuf = this2;
	var _g = 0;
	while(_g < 8) {
		var i = _g++;
		this.lightBuf[i] = new pot_graphics__$Graphics_Light();
	}
	this.numLights = 0;
};
pot_graphics_Graphics.__name__ = true;
pot_graphics_Graphics.prototype = {
	initGL: function() {
		this.gl.getExtension("OES_texture_float");
		this.gl.getExtension("OES_texture_float_linear");
		this.gl.getExtension("WEBGL_color_buffer_float");
		this.gl.disable(2929);
		this.gl.enable(3042);
		this.gl.frontFace(2305);
		this.gl.cullFace(1029);
		this.gl.disable(2884);
		this.gl.blendFuncSeparate(770,771,1,1);
	}
	,init2D: function() {
		this.gl.disable(2929);
		this.gl.frontFace(2305);
		this.gl.cullFace(1029);
		this.gl.disable(2884);
		this.cameraSet = false;
		var width;
		var height;
		var targetHeight;
		if(this.currentRenderTarget == null) {
			width = this.canvas.width;
			height = this.canvas.height;
			targetHeight = height;
		} else {
			width = this.currentRenderTarget.width;
			height = this.currentRenderTarget.height;
			targetHeight = this.currentRenderTarget.textureHeight;
		}
		this.gl.viewport(0,targetHeight - height,width,height);
		this.currentTexture = null;
	}
	,init3D: function() {
		this.gl.enable(2929);
		this.gl.frontFace(2305);
		this.gl.cullFace(1029);
		this.gl.enable(2884);
		this.cameraSet = false;
		var width;
		var height;
		var targetHeight;
		if(this.currentRenderTarget == null) {
			width = this.canvas.width;
			height = this.canvas.height;
			targetHeight = height;
		} else {
			width = this.currentRenderTarget.width;
			height = this.currentRenderTarget.height;
			targetHeight = this.currentRenderTarget.textureHeight;
		}
		this.gl.viewport(0,targetHeight - height,width,height);
		this.currentTexture = null;
	}
	,initMatricies: function() {
		this.modelMat = new pot_graphics__$Graphics_UniformMatrix();
		this.viewMat = new pot_graphics__$Graphics_UniformMatrix();
		this.modelviewMat = new pot_graphics__$Graphics_UniformMatrix();
		this.normalMat = new pot_graphics__$Graphics_UniformMatrix();
		this.projMat = new pot_graphics__$Graphics_UniformMatrix();
		this.mvpMat = new pot_graphics__$Graphics_UniformMatrix();
	}
	,initShaders: function() {
		var vertexSource = "\n\t\t\tattribute vec4 position;\n\t\t\tattribute vec4 color;\n\t\t\tattribute vec3 normal;\n\t\t\tattribute vec2 texCoord;\n\n\t\t\tuniform mat4 transform;\n\t\t\tuniform mat4 modelview;\n\t\t\tuniform mat3 normalMatrix;\n\n\t\t\tvarying vec4 vColor;\n\t\t\tvarying vec3 vPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tvarying vec2 vTexCoord;\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = transform * position;\n\n\t\t\t\tvColor = color;\n\t\t\t\tvPosition = (modelview * position).xyz;\n\t\t\t\tvNormal = normalMatrix * normal;\n\t\t\t\tvTexCoord = texCoord;\n\t\t\t}\n\t\t";
		var fragmentSource = "\n\t\t\tprecision mediump float;\n\t\t\tvarying vec4 vColor;\n\t\t\tvarying vec3 vPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tvarying vec2 vTexCoord;\n\t\t\tuniform float ambient;\n\t\t\tuniform float diffuse;\n\t\t\tuniform float specular;\n\t\t\tuniform float shininess;\n\t\t\tuniform float emission;\n\t\t\tuniform int numLights;\n\t\t\tuniform vec4 lightPositions[8];\n\t\t\tuniform vec3 lightColors[8];\n\t\t\tuniform vec3 lightNormals[8];\n\n\t\t\tvoid main() {\n\t\t\t\tif (numLights == 0) {\n\t\t\t\t\tgl_FragColor = vColor;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvec3 eye = normalize(vPosition);\n\t\t\t\tvec3 n = normalize(vNormal);\n\t\t\t\tvec3 color = vColor.xyz;\n\t\t\t\tvec3 ambientTotal = vec3(0);\n\t\t\t\tvec3 diffuseTotal = vec3(0);\n\t\t\t\tvec3 specularTotal = vec3(0);\n\t\t\t\tvec3 emissionTotal = color * emission;\n\n\t\t\t\tif (!gl_FrontFacing) n = -n;\n\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tif (i == numLights) break;\n\t\t\t\t\tvec4 lp = lightPositions[i];\n\t\t\t\t\tvec3 lc = lightColors[i];\n\t\t\t\t\tvec3 ln = lightNormals[i];\n\t\t\t\t\tbool amb = lp.w == 0.0 && dot(ln, ln) == 0.0;\n\t\t\t\t\tbool dir = lp.w == 0.0;\n\t\t\t\t\tif (amb) {\n\t\t\t\t\t\tambientTotal += lc * color * ambient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dir) {\n\t\t\t\t\t\t\tln = normalize(vPosition - lp.xyz);\n\t\t\t\t\t\t\t// TODO: spot light\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfloat ldot = -dot(ln, n);\n\t\t\t\t\t\tif (ldot < 0.0) ldot = 0.0;\n\t\t\t\t\t\tdiffuseTotal += lc * color * ldot * diffuse;\n\t\t\t\t\t\tif (ldot > 0.0) {\n\t\t\t\t\t\t\tvec3 reflEye = eye - 2.0 * n * dot(eye, n);\n\t\t\t\t\t\t\tfloat rdot = -dot(reflEye, ln);\n\t\t\t\t\t\t\tif (rdot < 0.0) rdot = 0.0;\n\t\t\t\t\t\t\tspecularTotal += lc * pow(rdot, shininess) * specular;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(ambientTotal + diffuseTotal + specularTotal + emissionTotal, vColor.w);\n\t\t\t}\n\t\t";
		var fragmentTextureSource = "\n\t\t\tprecision mediump float;\n\t\t\tuniform sampler2D texture;\n\n\t\t\tvarying vec4 vColor;\n\t\t\tvarying vec3 vPosition;\n\t\t\tvarying vec3 vNormal;\n\t\t\tvarying vec2 vTexCoord;\n\t\t\tuniform float ambient;\n\t\t\tuniform float diffuse;\n\t\t\tuniform float specular;\n\t\t\tuniform float shininess;\n\t\t\tuniform float emission;\n\t\t\tuniform int numLights;\n\t\t\tuniform vec4 lightPositions[8];\n\t\t\tuniform vec3 lightColors[8];\n\t\t\tuniform vec3 lightNormals[8];\n\n\t\t\tvoid main() {\n\t\t\t\tvec4 texMulColor = texture2D(texture, vTexCoord) * vColor;\n\t\t\t\tif (numLights == 0) {\n\t\t\t\t\tgl_FragColor = texMulColor;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvec3 eye = normalize(vPosition);\n\t\t\t\tvec3 n = normalize(vNormal);\n\t\t\t\tvec3 color = texMulColor.xyz;\n\t\t\t\tvec3 ambientTotal = vec3(0);\n\t\t\t\tvec3 diffuseTotal = vec3(0);\n\t\t\t\tvec3 specularTotal = vec3(0);\n\t\t\t\tvec3 emissionTotal = color * emission;\n\n\t\t\t\tif (!gl_FrontFacing) n = -n;\n\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tif (i == numLights) break;\n\t\t\t\t\tvec4 lp = lightPositions[i];\n\t\t\t\t\tvec3 lc = lightColors[i];\n\t\t\t\t\tvec3 ln = lightNormals[i];\n\t\t\t\t\tbool amb = lp.w == 0.0 && dot(ln, ln) == 0.0;\n\t\t\t\t\tbool dir = lp.w == 0.0;\n\t\t\t\t\tif (amb) {\n\t\t\t\t\t\tambientTotal += lc * color * ambient;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dir) {\n\t\t\t\t\t\t\tln = normalize(vPosition - lp.xyz);\n\t\t\t\t\t\t\t// TODO: spot light\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfloat ldot = -dot(ln, n);\n\t\t\t\t\t\tif (ldot < 0.0) ldot = 0.0;\n\t\t\t\t\t\tdiffuseTotal += lc * color * ldot * diffuse;\n\t\t\t\t\t\tif (ldot > 0.0) {\n\t\t\t\t\t\t\tvec3 reflEye = eye - 2.0 * n * dot(eye, n);\n\t\t\t\t\t\t\tfloat rdot = -dot(reflEye, ln);\n\t\t\t\t\t\t\tif (rdot < 0.0) rdot = 0.0;\n\t\t\t\t\t\t\tspecularTotal += lc * pow(rdot, shininess) * specular;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgl_FragColor = vec4(ambientTotal + diffuseTotal + specularTotal + emissionTotal, texMulColor.w);\n\t\t\t}\n\t\t";
		this.defaultShader = new pot_graphics_Shader(this.gl);
		var _this = this.defaultShader;
		_this.vSource = vertexSource;
		_this.compiled = false;
		var _this1 = this.defaultShader;
		_this1.fSource = fragmentSource;
		_this1.compiled = false;
		var _this2 = this.defaultShader;
		_this2.map = new haxe_ds_StringMap();
		_this2.gl.shaderSource(_this2.vs,_this2.vSource);
		_this2.gl.compileShader(_this2.vs);
		if(!_this2.gl.getShaderParameter(_this2.vs,35713)) {
			js_Browser.alert(_this2.gl.getShaderInfoLog(_this2.vs));
		}
		_this2.gl.shaderSource(_this2.fs,_this2.fSource);
		_this2.gl.compileShader(_this2.fs);
		if(!_this2.gl.getShaderParameter(_this2.fs,35713)) {
			js_Browser.alert(_this2.gl.getShaderInfoLog(_this2.fs));
		}
		_this2.gl.attachShader(_this2.pg,_this2.vs);
		_this2.gl.attachShader(_this2.pg,_this2.fs);
		_this2.gl.linkProgram(_this2.pg);
		if(_this2.gl.getProgramParameter(_this2.pg,35714)) {
			_this2.compiled = true;
		} else {
			console.log("../Pot Engine/src/pot/graphics/Shader.hx:173:",_this2.gl.getProgramInfoLog(_this2.pg));
		}
		this.defaultShaderTexture = new pot_graphics_Shader(this.gl);
		var _this3 = this.defaultShaderTexture;
		_this3.vSource = vertexSource;
		_this3.compiled = false;
		var _this4 = this.defaultShaderTexture;
		_this4.fSource = fragmentTextureSource;
		_this4.compiled = false;
		var _this5 = this.defaultShaderTexture;
		_this5.map = new haxe_ds_StringMap();
		_this5.gl.shaderSource(_this5.vs,_this5.vSource);
		_this5.gl.compileShader(_this5.vs);
		if(!_this5.gl.getShaderParameter(_this5.vs,35713)) {
			js_Browser.alert(_this5.gl.getShaderInfoLog(_this5.vs));
		}
		_this5.gl.shaderSource(_this5.fs,_this5.fSource);
		_this5.gl.compileShader(_this5.fs);
		if(!_this5.gl.getShaderParameter(_this5.fs,35713)) {
			js_Browser.alert(_this5.gl.getShaderInfoLog(_this5.fs));
		}
		_this5.gl.attachShader(_this5.pg,_this5.vs);
		_this5.gl.attachShader(_this5.pg,_this5.fs);
		_this5.gl.linkProgram(_this5.pg);
		if(_this5.gl.getProgramParameter(_this5.pg,35714)) {
			_this5.compiled = true;
		} else {
			console.log("../Pot Engine/src/pot/graphics/Shader.hx:173:",_this5.gl.getProgramInfoLog(_this5.pg));
		}
		this.currentShader = null;
	}
	,initBuffers: function() {
		this.positionBuf = new pot_graphics__$Graphics_VertexBuffer(this.gl,"position",3);
		this.colorBuf = new pot_graphics__$Graphics_VertexBuffer(this.gl,"color",4);
		this.normalBuf = new pot_graphics__$Graphics_VertexBuffer(this.gl,"normal",3);
		this.texCoordBuf = new pot_graphics__$Graphics_VertexBuffer(this.gl,"texCoord",2);
		this.indexBuf = new pot_graphics__$Graphics_IndexBuffer(this.gl);
	}
	,chooseShader: function() {
		if(this.currentShader != null) {
			return this.currentShader;
		}
		if(this.currentTexture != null) {
			return this.defaultShaderTexture;
		}
		return this.defaultShader;
	}
	,screen: function(width,height) {
		this.screenWidth = width;
		this.screenHeight = height;
		if(this.currentRenderTarget == null) {
			var width1;
			var height1;
			var targetHeight;
			if(this.currentRenderTarget == null) {
				width1 = this.canvas.width;
				height1 = this.canvas.height;
				targetHeight = height1;
			} else {
				width1 = this.currentRenderTarget.width;
				height1 = this.currentRenderTarget.height;
				targetHeight = this.currentRenderTarget.textureHeight;
			}
			this.gl.viewport(0,targetHeight - height1,width1,height1);
		}
		var fovY = null;
		var near = null;
		var far = null;
		if(fovY == null) {
			fovY = Math.PI / 3;
		}
		if(near == null) {
			near = 0.1;
		}
		if(far == null) {
			far = 1000;
		}
		this.cameraFov = fovY;
		this.cameraNear = near;
		this.cameraFar = far;
		this.projMat.perspective(fovY,this.screenWidth / this.screenHeight,near,far);
	}
	,viewport: function(x,y,width,height) {
		var targetHeight = this.currentRenderTarget == null ? this.canvas.height : this.currentRenderTarget.textureHeight;
		this.gl.viewport(x,targetHeight - height - y,width,height);
	}
	,resetViewport: function() {
		var width;
		var height;
		var targetHeight;
		if(this.currentRenderTarget == null) {
			width = this.canvas.width;
			height = this.canvas.height;
			targetHeight = height;
		} else {
			width = this.currentRenderTarget.width;
			height = this.currentRenderTarget.height;
			targetHeight = this.currentRenderTarget.textureHeight;
		}
		this.gl.viewport(0,targetHeight - height,width,height);
	}
	,getRawGL: function() {
		return this.gl;
	}
	,beginScene: function() {
		if(this.sceneOpen) {
			throw new Error("scene already begun");
		}
		this.sceneOpen = true;
		this.modelMat.identity();
		this.numLights = 0;
		this.currentTexture = null;
		this.colorR = 1;
		this.colorG = 1;
		this.colorB = 1;
		this.colorA = 1;
		this.normalX = 0;
		this.normalY = 0;
		this.normalZ = 0;
		this.texCoordU = 0;
		this.texCoordV = 0;
		this.materialAmb = 1;
		this.materialDif = 1;
		this.materialSpc = 0;
		this.materialShn = 10;
		this.materialEmi = 0;
		if(!this.cameraSet) {
			this.defaultCameraPosX = this.screenWidth * 0.5;
			this.defaultCameraPosY = this.screenHeight * 0.5;
			this.defaultCameraPosZ = -this.screenHeight / (2 * Math.tan(this.cameraFov * 0.5));
			this.viewMat.lookAt(this.defaultCameraPosX,this.defaultCameraPosY,this.defaultCameraPosZ,this.defaultCameraPosX,this.defaultCameraPosY,0,0,-1,0);
		}
	}
	,endScene: function() {
		if(!this.sceneOpen) {
			throw new Error("scene already ended");
		}
		this.sceneOpen = false;
		this.gl.flush();
	}
	,enableDepthTest: function() {
		this.gl.enable(2929);
	}
	,disableDepthTest: function() {
		this.gl.disable(2929);
	}
	,culling: function(face) {
		if(face == 0) {
			this.gl.disable(2884);
		} else {
			this.gl.enable(2884);
			this.gl.cullFace(face);
		}
	}
	,clear: function(r,g,b,a) {
		if(a == null) {
			a = 1;
		}
		this.gl.clearColor(r,g,b,a);
		this.gl.clearDepth(1);
		this.gl.clear(16640);
	}
	,createShader: function(vertexSource,fragmentSource) {
		var shader = new pot_graphics_Shader(this.gl);
		shader.vSource = vertexSource;
		shader.compiled = false;
		shader.fSource = fragmentSource;
		shader.compiled = false;
		shader.map = new haxe_ds_StringMap();
		shader.gl.shaderSource(shader.vs,shader.vSource);
		shader.gl.compileShader(shader.vs);
		if(!shader.gl.getShaderParameter(shader.vs,35713)) {
			js_Browser.alert(shader.gl.getShaderInfoLog(shader.vs));
		}
		shader.gl.shaderSource(shader.fs,shader.fSource);
		shader.gl.compileShader(shader.fs);
		if(!shader.gl.getShaderParameter(shader.fs,35713)) {
			js_Browser.alert(shader.gl.getShaderInfoLog(shader.fs));
		}
		shader.gl.attachShader(shader.pg,shader.vs);
		shader.gl.attachShader(shader.pg,shader.fs);
		shader.gl.linkProgram(shader.pg);
		if(shader.gl.getProgramParameter(shader.pg,35714)) {
			shader.compiled = true;
		} else {
			console.log("../Pot Engine/src/pot/graphics/Shader.hx:173:",shader.gl.getProgramInfoLog(shader.pg));
		}
		return shader;
	}
	,shader: function(shader) {
		this.currentShader = shader;
	}
	,resetShader: function() {
		this.currentShader = null;
	}
	,createTexture: function(width,height,floating) {
		if(floating == null) {
			floating = false;
		}
		var img = new pot_graphics_Texture(this.gl);
		img.init(width,height,floating);
		return img;
	}
	,loadImage: function(image,scalingMode,floating) {
		if(floating == null) {
			floating = false;
		}
		if(scalingMode == null) {
			scalingMode = 0;
		}
		var img = new pot_graphics_Texture(this.gl);
		img.load(image,scalingMode,floating);
		return img;
	}
	,loadImageTo: function(texture,image,scalingMode,floating) {
		if(floating == null) {
			floating = false;
		}
		if(scalingMode == null) {
			scalingMode = 0;
		}
		texture.load(image,scalingMode,floating);
	}
	,renderTarget: function(target) {
		this.currentRenderTarget = target;
		if(target == null) {
			this.gl.bindFramebuffer(36160,null);
			this.gl.viewport(0,0,this.canvas.width,this.canvas.height);
		} else {
			this.gl.bindFramebuffer(36160,target.frameBuffer);
			this.gl.viewport(0,target.textureHeight - target.height,target.width,target.height);
		}
	}
	,pushMatrix: function() {
		if(this.matStackCount > 1008) {
			throw new Error("matrix stack overflowed");
		}
		var val = this.modelMat.array[0];
		this.matStack[this.matStackCount++] = val;
		var val1 = this.modelMat.array[1];
		this.matStack[this.matStackCount++] = val1;
		var val2 = this.modelMat.array[2];
		this.matStack[this.matStackCount++] = val2;
		var val3 = this.modelMat.array[3];
		this.matStack[this.matStackCount++] = val3;
		var val4 = this.modelMat.array[4];
		this.matStack[this.matStackCount++] = val4;
		var val5 = this.modelMat.array[5];
		this.matStack[this.matStackCount++] = val5;
		var val6 = this.modelMat.array[6];
		this.matStack[this.matStackCount++] = val6;
		var val7 = this.modelMat.array[7];
		this.matStack[this.matStackCount++] = val7;
		var val8 = this.modelMat.array[8];
		this.matStack[this.matStackCount++] = val8;
		var val9 = this.modelMat.array[9];
		this.matStack[this.matStackCount++] = val9;
		var val10 = this.modelMat.array[10];
		this.matStack[this.matStackCount++] = val10;
		var val11 = this.modelMat.array[11];
		this.matStack[this.matStackCount++] = val11;
		var val12 = this.modelMat.array[12];
		this.matStack[this.matStackCount++] = val12;
		var val13 = this.modelMat.array[13];
		this.matStack[this.matStackCount++] = val13;
		var val14 = this.modelMat.array[14];
		this.matStack[this.matStackCount++] = val14;
		var val15 = this.modelMat.array[15];
		this.matStack[this.matStackCount++] = val15;
	}
	,popMatrix: function() {
		if(this.matStackCount < 16) {
			throw new Error("cannot pop matrix");
		}
		this.modelMat.array[15] = this.matStack[--this.matStackCount];
		this.modelMat.array[14] = this.matStack[--this.matStackCount];
		this.modelMat.array[13] = this.matStack[--this.matStackCount];
		this.modelMat.array[12] = this.matStack[--this.matStackCount];
		this.modelMat.array[11] = this.matStack[--this.matStackCount];
		this.modelMat.array[10] = this.matStack[--this.matStackCount];
		this.modelMat.array[9] = this.matStack[--this.matStackCount];
		this.modelMat.array[8] = this.matStack[--this.matStackCount];
		this.modelMat.array[7] = this.matStack[--this.matStackCount];
		this.modelMat.array[6] = this.matStack[--this.matStackCount];
		this.modelMat.array[5] = this.matStack[--this.matStackCount];
		this.modelMat.array[4] = this.matStack[--this.matStackCount];
		this.modelMat.array[3] = this.matStack[--this.matStackCount];
		this.modelMat.array[2] = this.matStack[--this.matStackCount];
		this.modelMat.array[1] = this.matStack[--this.matStackCount];
		this.modelMat.array[0] = this.matStack[--this.matStackCount];
	}
	,scale: function(sx,sy,sz) {
		if(sz == null) {
			sz = 1;
		}
		this.modelMat.appendScale(sx,sy,sz);
	}
	,rotate: function(ang) {
		this.modelMat.appendRotation(ang,0,0,1);
	}
	,rotateX: function(ang) {
		this.modelMat.appendRotation(ang,1,0,0);
	}
	,rotateY: function(ang) {
		this.modelMat.appendRotation(ang,0,1,0);
	}
	,rotateZ: function(ang) {
		this.modelMat.appendRotation(ang,0,0,1);
	}
	,translate: function(tx,ty,tz) {
		if(tz == null) {
			tz = 0;
		}
		this.modelMat.appendTranslation(tx,ty,tz);
	}
	,resetCamera: function() {
		this.cameraSet = false;
	}
	,camera: function(posX,posY,posZ,atX,atY,atZ,upX,upY,upZ) {
		this.cameraSet = true;
		this.cameraPosX = posX;
		this.cameraPosY = posY;
		this.cameraPosZ = posZ;
		this.cameraAtX = atX;
		this.cameraAtY = atY;
		this.cameraAtZ = atZ;
		this.cameraUpX = upX;
		this.cameraUpY = upY;
		this.cameraUpZ = upZ;
		this.viewMat.lookAt(this.cameraPosX,this.cameraPosY,this.cameraPosZ,this.cameraAtX,this.cameraAtY,this.cameraAtZ,this.cameraUpX,this.cameraUpY,this.cameraUpZ);
	}
	,perspective: function(fovY,near,far) {
		if(fovY == null) {
			fovY = Math.PI / 3;
		}
		if(near == null) {
			near = 0.1;
		}
		if(far == null) {
			far = 1000;
		}
		this.cameraFov = fovY;
		this.cameraNear = near;
		this.cameraFar = far;
		this.projMat.perspective(fovY,this.screenWidth / this.screenHeight,near,far);
	}
	,beginShape: function(mode) {
		this.shapeMode = mode;
		this.numVertices = 0;
		this.positionBuf.length = 0;
		this.colorBuf.length = 0;
		this.normalBuf.length = 0;
		this.texCoordBuf.length = 0;
		this.indexBuf.length = 0;
	}
	,image: function(img,srcX,srcY,srcW,srcH,dstX,dstY,dstW,dstH) {
		var tmpTex = this.currentTexture;
		var tmpTexMode = this.texMode;
		this.currentTexture = img;
		this.texMode = 0;
		this.beginShape(5);
		this.normalX = 0;
		this.normalY = 0;
		this.normalZ = -1;
		var u = srcX;
		var v = srcY;
		if(this.currentTexture == null) {
			throw new Error("set texture before calling texCoord");
		}
		var _g = this.texMode;
		switch(_g) {
		case 0:
			u *= this.currentTexture.imageToU;
			v *= this.currentTexture.imageToV;
			break;
		case 1:
			u *= this.currentTexture.normalToU;
			v *= this.currentTexture.normalToV;
			break;
		case 2:
			break;
		}
		this.texCoordU = u;
		this.texCoordV = 1 - v;
		this.vertex(dstX,dstY,0);
		var u1 = srcX;
		var v1 = srcY + srcH;
		if(this.currentTexture == null) {
			throw new Error("set texture before calling texCoord");
		}
		var _g1 = this.texMode;
		switch(_g1) {
		case 0:
			u1 *= this.currentTexture.imageToU;
			v1 *= this.currentTexture.imageToV;
			break;
		case 1:
			u1 *= this.currentTexture.normalToU;
			v1 *= this.currentTexture.normalToV;
			break;
		case 2:
			break;
		}
		this.texCoordU = u1;
		this.texCoordV = 1 - v1;
		this.vertex(dstX,dstY + dstH,0);
		var u2 = srcX + srcW;
		var v2 = srcY;
		if(this.currentTexture == null) {
			throw new Error("set texture before calling texCoord");
		}
		var _g2 = this.texMode;
		switch(_g2) {
		case 0:
			u2 *= this.currentTexture.imageToU;
			v2 *= this.currentTexture.imageToV;
			break;
		case 1:
			u2 *= this.currentTexture.normalToU;
			v2 *= this.currentTexture.normalToV;
			break;
		case 2:
			break;
		}
		this.texCoordU = u2;
		this.texCoordV = 1 - v2;
		this.vertex(dstX + dstW,dstY,0);
		var u3 = srcX + srcW;
		var v3 = srcY + srcH;
		if(this.currentTexture == null) {
			throw new Error("set texture before calling texCoord");
		}
		var _g3 = this.texMode;
		switch(_g3) {
		case 0:
			u3 *= this.currentTexture.imageToU;
			v3 *= this.currentTexture.imageToV;
			break;
		case 1:
			u3 *= this.currentTexture.normalToU;
			v3 *= this.currentTexture.normalToV;
			break;
		case 2:
			break;
		}
		this.texCoordU = u3;
		this.texCoordV = 1 - v3;
		this.vertex(dstX + dstW,dstY + dstH,0);
		var shader = this.chooseShader();
		var pg = shader.pg;
		this.modelviewMat.mul(this.viewMat,this.modelMat);
		this.normalMat.inverse(this.modelviewMat);
		this.normalMat.transpose(this.normalMat);
		var tmp;
		var _this = shader.map;
		if(__map_reserved["model"] != null ? _this.existsReserved("model") : _this.h.hasOwnProperty("model")) {
			var _this1 = shader.map;
			tmp = __map_reserved["model"] != null ? _this1.getReserved("model") : _this1.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this2 = shader.map;
			if(__map_reserved["model"] != null) {
				_this2.setReserved("model",ul);
			} else {
				_this2.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",this.modelMat.array);
		}
		var tmp1;
		var _this3 = shader.map;
		if(__map_reserved["view"] != null ? _this3.existsReserved("view") : _this3.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",this.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",this.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this11 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this11.setReserved("transform",ul3);
			} else {
				_this11.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			this.mvpMat.mul(this.projMat,this.modelviewMat);
			shader.setMatrix("transform",this.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",this.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			this.normalMat.toMat3();
			shader.setMatrix("normalMatrix",this.normalMat.array3);
		}
		if(this.currentTexture != null) {
			shader.setTexture("texture",this.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",this.currentTexture.textureWidth,this.currentTexture.textureHeight);
			}
			var tmp7;
			var _this21 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this21.existsReserved("texViewport") : _this21.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x = 0;
				var y = 1 - this.currentTexture.height / this.currentTexture.textureHeight;
				var w = this.currentTexture.width / this.currentTexture.textureWidth;
				var h = this.currentTexture.height / this.currentTexture.textureHeight;
				shader.setFloat("texViewport",x,y,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",this.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",this.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this31 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this31.getReserved("specular") : _this31.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",this.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",this.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",this.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",this.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g11 = 0;
			var _g4 = this.numLights;
			while(_g11 < _g4) {
				var i = _g11++;
				var light = this.lightBuf[i];
				var x1 = light.posX * this.viewMat.array[0] + light.posY * this.viewMat.array[4] + light.posZ * this.viewMat.array[8] + this.viewMat.array[12];
				var y1 = light.posX * this.viewMat.array[1] + light.posY * this.viewMat.array[5] + light.posZ * this.viewMat.array[9] + this.viewMat.array[13];
				var z = light.posX * this.viewMat.array[2] + light.posY * this.viewMat.array[6] + light.posZ * this.viewMat.array[10] + this.viewMat.array[14];
				shader.setFloat("lightPositions[" + i + "]",x1,y1,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g12 = 0;
			var _g5 = this.numLights;
			while(_g12 < _g5) {
				var i1 = _g12++;
				var light1 = this.lightBuf[i1];
				var x2 = light1.norX * this.viewMat.array[0] + light1.norY * this.viewMat.array[4] + light1.norZ * this.viewMat.array[8];
				var y2 = light1.norX * this.viewMat.array[1] + light1.norY * this.viewMat.array[5] + light1.norZ * this.viewMat.array[9];
				var z1 = light1.norX * this.viewMat.array[2] + light1.norY * this.viewMat.array[6] + light1.norZ * this.viewMat.array[10];
				shader.setFloat("lightNormals[" + i1 + "]",x2,y2,z1);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g13 = 0;
			var _g6 = this.numLights;
			while(_g13 < _g6) {
				var i2 = _g13++;
				var light2 = this.lightBuf[i2];
				shader.setFloat("lightColors[" + i2 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = this.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = this.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = this.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = this.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = this.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = this.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = this.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = this.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = this.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name = shader.uniforms.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name1] != null ? _this60.getReserved(name1) : _this60.h[name1];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name2 = shader.uniforms.keys();
		while(name2.hasNext()) {
			var name3 = name2.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name3] != null ? _this61.getReserved(name3) : _this61.h[name3];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name3] != null ? _this62.existsReserved(name3) : _this62.h.hasOwnProperty(name3)) {
				var _this63 = shader.map;
				loc = __map_reserved[name3] != null ? _this63.getReserved(name3) : _this63.h[name3];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name3);
				var _this64 = shader.map;
				if(__map_reserved[name3] != null) {
					_this64.setReserved(name3,ul17);
				} else {
					_this64.h[name3] = ul17;
				}
				loc = ul17;
			}
			var _g7 = uniform1.type;
			switch(_g7) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = this.indexBuf;
		var mode = this.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
		this.currentTexture = tmpTex;
		this.texMode = tmpTexMode;
	}
	,rect: function(x,y,width,height) {
		var tmpTexMode = this.texMode;
		this.texMode = 1;
		this.beginShape(5);
		this.normalX = 0;
		this.normalY = 0;
		this.normalZ = -1;
		if(this.currentTexture != null) {
			var u = 0;
			var v = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g = this.texMode;
			switch(_g) {
			case 0:
				u *= this.currentTexture.imageToU;
				v *= this.currentTexture.imageToV;
				break;
			case 1:
				u *= this.currentTexture.normalToU;
				v *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u;
			this.texCoordV = 1 - v;
			this.vertex(x,y,0);
			var u1 = 0;
			var v1 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g1 = this.texMode;
			switch(_g1) {
			case 0:
				u1 *= this.currentTexture.imageToU;
				v1 *= this.currentTexture.imageToV;
				break;
			case 1:
				u1 *= this.currentTexture.normalToU;
				v1 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u1;
			this.texCoordV = 1 - v1;
			this.vertex(x,y + height,0);
			var u2 = 1;
			var v2 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g2 = this.texMode;
			switch(_g2) {
			case 0:
				u2 *= this.currentTexture.imageToU;
				v2 *= this.currentTexture.imageToV;
				break;
			case 1:
				u2 *= this.currentTexture.normalToU;
				v2 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u2;
			this.texCoordV = 1 - v2;
			this.vertex(x + width,y,0);
			var u3 = 1;
			var v3 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g3 = this.texMode;
			switch(_g3) {
			case 0:
				u3 *= this.currentTexture.imageToU;
				v3 *= this.currentTexture.imageToV;
				break;
			case 1:
				u3 *= this.currentTexture.normalToU;
				v3 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u3;
			this.texCoordV = 1 - v3;
			this.vertex(x + width,y + height,0);
		} else {
			this.vertex(x,y,0);
			this.vertex(x,y + height,0);
			this.vertex(x + width,y,0);
			this.vertex(x + width,y + height,0);
		}
		var shader = this.chooseShader();
		var pg = shader.pg;
		this.modelviewMat.mul(this.viewMat,this.modelMat);
		this.normalMat.inverse(this.modelviewMat);
		this.normalMat.transpose(this.normalMat);
		var tmp;
		var _this = shader.map;
		if(__map_reserved["model"] != null ? _this.existsReserved("model") : _this.h.hasOwnProperty("model")) {
			var _this1 = shader.map;
			tmp = __map_reserved["model"] != null ? _this1.getReserved("model") : _this1.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this2 = shader.map;
			if(__map_reserved["model"] != null) {
				_this2.setReserved("model",ul);
			} else {
				_this2.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",this.modelMat.array);
		}
		var tmp1;
		var _this3 = shader.map;
		if(__map_reserved["view"] != null ? _this3.existsReserved("view") : _this3.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",this.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",this.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this11 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this11.setReserved("transform",ul3);
			} else {
				_this11.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			this.mvpMat.mul(this.projMat,this.modelviewMat);
			shader.setMatrix("transform",this.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",this.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			this.normalMat.toMat3();
			shader.setMatrix("normalMatrix",this.normalMat.array3);
		}
		if(this.currentTexture != null) {
			shader.setTexture("texture",this.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",this.currentTexture.textureWidth,this.currentTexture.textureHeight);
			}
			var tmp7;
			var _this21 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this21.existsReserved("texViewport") : _this21.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x1 = 0;
				var y1 = 1 - this.currentTexture.height / this.currentTexture.textureHeight;
				var w = this.currentTexture.width / this.currentTexture.textureWidth;
				var h = this.currentTexture.height / this.currentTexture.textureHeight;
				shader.setFloat("texViewport",x1,y1,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",this.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",this.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this31 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this31.getReserved("specular") : _this31.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",this.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",this.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",this.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",this.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g11 = 0;
			var _g4 = this.numLights;
			while(_g11 < _g4) {
				var i = _g11++;
				var light = this.lightBuf[i];
				var x2 = light.posX * this.viewMat.array[0] + light.posY * this.viewMat.array[4] + light.posZ * this.viewMat.array[8] + this.viewMat.array[12];
				var y2 = light.posX * this.viewMat.array[1] + light.posY * this.viewMat.array[5] + light.posZ * this.viewMat.array[9] + this.viewMat.array[13];
				var z = light.posX * this.viewMat.array[2] + light.posY * this.viewMat.array[6] + light.posZ * this.viewMat.array[10] + this.viewMat.array[14];
				shader.setFloat("lightPositions[" + i + "]",x2,y2,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g12 = 0;
			var _g5 = this.numLights;
			while(_g12 < _g5) {
				var i1 = _g12++;
				var light1 = this.lightBuf[i1];
				var x3 = light1.norX * this.viewMat.array[0] + light1.norY * this.viewMat.array[4] + light1.norZ * this.viewMat.array[8];
				var y3 = light1.norX * this.viewMat.array[1] + light1.norY * this.viewMat.array[5] + light1.norZ * this.viewMat.array[9];
				var z1 = light1.norX * this.viewMat.array[2] + light1.norY * this.viewMat.array[6] + light1.norZ * this.viewMat.array[10];
				shader.setFloat("lightNormals[" + i1 + "]",x3,y3,z1);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g13 = 0;
			var _g6 = this.numLights;
			while(_g13 < _g6) {
				var i2 = _g13++;
				var light2 = this.lightBuf[i2];
				shader.setFloat("lightColors[" + i2 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = this.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = this.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = this.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = this.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = this.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = this.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = this.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = this.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = this.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name = shader.uniforms.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name1] != null ? _this60.getReserved(name1) : _this60.h[name1];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name2 = shader.uniforms.keys();
		while(name2.hasNext()) {
			var name3 = name2.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name3] != null ? _this61.getReserved(name3) : _this61.h[name3];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name3] != null ? _this62.existsReserved(name3) : _this62.h.hasOwnProperty(name3)) {
				var _this63 = shader.map;
				loc = __map_reserved[name3] != null ? _this63.getReserved(name3) : _this63.h[name3];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name3);
				var _this64 = shader.map;
				if(__map_reserved[name3] != null) {
					_this64.setReserved(name3,ul17);
				} else {
					_this64.h[name3] = ul17;
				}
				loc = ul17;
			}
			var _g7 = uniform1.type;
			switch(_g7) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = this.indexBuf;
		var mode = this.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
		this.texMode = tmpTexMode;
	}
	,line: function(a,b,c,d,e,f) {
		var tmpTex = this.currentTexture;
		var tmpNumLights = this.numLights;
		this.currentTexture = null;
		this.numLights = 0;
		this.beginShape(1);
		if(e != null && f != null) {
			this.vertex(a,b,c);
			this.vertex(d,e,f);
		} else {
			this.vertex(a,b,0);
			this.vertex(c,d,0);
		}
		var shader = this.chooseShader();
		var pg = shader.pg;
		this.modelviewMat.mul(this.viewMat,this.modelMat);
		this.normalMat.inverse(this.modelviewMat);
		this.normalMat.transpose(this.normalMat);
		var tmp;
		var _this = shader.map;
		if(__map_reserved["model"] != null ? _this.existsReserved("model") : _this.h.hasOwnProperty("model")) {
			var _this1 = shader.map;
			tmp = __map_reserved["model"] != null ? _this1.getReserved("model") : _this1.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this2 = shader.map;
			if(__map_reserved["model"] != null) {
				_this2.setReserved("model",ul);
			} else {
				_this2.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",this.modelMat.array);
		}
		var tmp1;
		var _this3 = shader.map;
		if(__map_reserved["view"] != null ? _this3.existsReserved("view") : _this3.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",this.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",this.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this11 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this11.setReserved("transform",ul3);
			} else {
				_this11.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			this.mvpMat.mul(this.projMat,this.modelviewMat);
			shader.setMatrix("transform",this.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",this.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			this.normalMat.toMat3();
			shader.setMatrix("normalMatrix",this.normalMat.array3);
		}
		if(this.currentTexture != null) {
			shader.setTexture("texture",this.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",this.currentTexture.textureWidth,this.currentTexture.textureHeight);
			}
			var tmp7;
			var _this21 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this21.existsReserved("texViewport") : _this21.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x = 0;
				var y = 1 - this.currentTexture.height / this.currentTexture.textureHeight;
				var w = this.currentTexture.width / this.currentTexture.textureWidth;
				var h = this.currentTexture.height / this.currentTexture.textureHeight;
				shader.setFloat("texViewport",x,y,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",this.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",this.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this31 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this31.getReserved("specular") : _this31.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",this.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",this.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",this.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",this.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g1 = 0;
			var _g = this.numLights;
			while(_g1 < _g) {
				var i = _g1++;
				var light = this.lightBuf[i];
				var x1 = light.posX * this.viewMat.array[0] + light.posY * this.viewMat.array[4] + light.posZ * this.viewMat.array[8] + this.viewMat.array[12];
				var y1 = light.posX * this.viewMat.array[1] + light.posY * this.viewMat.array[5] + light.posZ * this.viewMat.array[9] + this.viewMat.array[13];
				var z = light.posX * this.viewMat.array[2] + light.posY * this.viewMat.array[6] + light.posZ * this.viewMat.array[10] + this.viewMat.array[14];
				shader.setFloat("lightPositions[" + i + "]",x1,y1,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g11 = 0;
			var _g2 = this.numLights;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var light1 = this.lightBuf[i1];
				var x2 = light1.norX * this.viewMat.array[0] + light1.norY * this.viewMat.array[4] + light1.norZ * this.viewMat.array[8];
				var y2 = light1.norX * this.viewMat.array[1] + light1.norY * this.viewMat.array[5] + light1.norZ * this.viewMat.array[9];
				var z1 = light1.norX * this.viewMat.array[2] + light1.norY * this.viewMat.array[6] + light1.norZ * this.viewMat.array[10];
				shader.setFloat("lightNormals[" + i1 + "]",x2,y2,z1);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g12 = 0;
			var _g3 = this.numLights;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var light2 = this.lightBuf[i2];
				shader.setFloat("lightColors[" + i2 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = this.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = this.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = this.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = this.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = this.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = this.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = this.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = this.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = this.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name = shader.uniforms.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name1] != null ? _this60.getReserved(name1) : _this60.h[name1];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name2 = shader.uniforms.keys();
		while(name2.hasNext()) {
			var name3 = name2.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name3] != null ? _this61.getReserved(name3) : _this61.h[name3];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name3] != null ? _this62.existsReserved(name3) : _this62.h.hasOwnProperty(name3)) {
				var _this63 = shader.map;
				loc = __map_reserved[name3] != null ? _this63.getReserved(name3) : _this63.h[name3];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name3);
				var _this64 = shader.map;
				if(__map_reserved[name3] != null) {
					_this64.setReserved(name3,ul17);
				} else {
					_this64.h[name3] = ul17;
				}
				loc = ul17;
			}
			var _g4 = uniform1.type;
			switch(_g4) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = this.indexBuf;
		var mode = this.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
		this.currentTexture = tmpTex;
		this.numLights = tmpNumLights;
	}
	,box: function(width,height,depth) {
		var tmpTexMode = this.texMode;
		this.texMode = 1;
		this.beginShape(4);
		width *= 0.5;
		height *= 0.5;
		depth *= 0.5;
		var x1 = -width;
		var x2 = width;
		var y1 = -height;
		var y2 = height;
		var z1 = -depth;
		var z2 = depth;
		if(this.currentTexture != null) {
			this.normalX = -1;
			this.normalY = 0;
			this.normalZ = 0;
			var u = 0;
			var v = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g = this.texMode;
			switch(_g) {
			case 0:
				u *= this.currentTexture.imageToU;
				v *= this.currentTexture.imageToV;
				break;
			case 1:
				u *= this.currentTexture.normalToU;
				v *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u;
			this.texCoordV = 1 - v;
			this.vertex(x1,y1,z1);
			var u1 = 0;
			var v1 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g1 = this.texMode;
			switch(_g1) {
			case 0:
				u1 *= this.currentTexture.imageToU;
				v1 *= this.currentTexture.imageToV;
				break;
			case 1:
				u1 *= this.currentTexture.normalToU;
				v1 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u1;
			this.texCoordV = 1 - v1;
			this.vertex(x1,y1,z2);
			var u2 = 1;
			var v2 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g2 = this.texMode;
			switch(_g2) {
			case 0:
				u2 *= this.currentTexture.imageToU;
				v2 *= this.currentTexture.imageToV;
				break;
			case 1:
				u2 *= this.currentTexture.normalToU;
				v2 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u2;
			this.texCoordV = 1 - v2;
			this.vertex(x1,y2,z2);
			var u3 = 0;
			var v3 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g3 = this.texMode;
			switch(_g3) {
			case 0:
				u3 *= this.currentTexture.imageToU;
				v3 *= this.currentTexture.imageToV;
				break;
			case 1:
				u3 *= this.currentTexture.normalToU;
				v3 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u3;
			this.texCoordV = 1 - v3;
			this.vertex(x1,y1,z1);
			var u4 = 1;
			var v4 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g4 = this.texMode;
			switch(_g4) {
			case 0:
				u4 *= this.currentTexture.imageToU;
				v4 *= this.currentTexture.imageToV;
				break;
			case 1:
				u4 *= this.currentTexture.normalToU;
				v4 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u4;
			this.texCoordV = 1 - v4;
			this.vertex(x1,y2,z2);
			var u5 = 1;
			var v5 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g5 = this.texMode;
			switch(_g5) {
			case 0:
				u5 *= this.currentTexture.imageToU;
				v5 *= this.currentTexture.imageToV;
				break;
			case 1:
				u5 *= this.currentTexture.normalToU;
				v5 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u5;
			this.texCoordV = 1 - v5;
			this.vertex(x1,y2,z1);
			this.normalX = 1;
			this.normalY = 0;
			this.normalZ = 0;
			var u6 = 0;
			var v6 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g6 = this.texMode;
			switch(_g6) {
			case 0:
				u6 *= this.currentTexture.imageToU;
				v6 *= this.currentTexture.imageToV;
				break;
			case 1:
				u6 *= this.currentTexture.normalToU;
				v6 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u6;
			this.texCoordV = 1 - v6;
			this.vertex(x2,y1,z1);
			var u7 = 0;
			var v7 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g7 = this.texMode;
			switch(_g7) {
			case 0:
				u7 *= this.currentTexture.imageToU;
				v7 *= this.currentTexture.imageToV;
				break;
			case 1:
				u7 *= this.currentTexture.normalToU;
				v7 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u7;
			this.texCoordV = 1 - v7;
			this.vertex(x2,y2,z1);
			var u8 = 1;
			var v8 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g8 = this.texMode;
			switch(_g8) {
			case 0:
				u8 *= this.currentTexture.imageToU;
				v8 *= this.currentTexture.imageToV;
				break;
			case 1:
				u8 *= this.currentTexture.normalToU;
				v8 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u8;
			this.texCoordV = 1 - v8;
			this.vertex(x2,y2,z2);
			var u9 = 0;
			var v9 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g9 = this.texMode;
			switch(_g9) {
			case 0:
				u9 *= this.currentTexture.imageToU;
				v9 *= this.currentTexture.imageToV;
				break;
			case 1:
				u9 *= this.currentTexture.normalToU;
				v9 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u9;
			this.texCoordV = 1 - v9;
			this.vertex(x2,y1,z1);
			var u10 = 1;
			var v10 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g10 = this.texMode;
			switch(_g10) {
			case 0:
				u10 *= this.currentTexture.imageToU;
				v10 *= this.currentTexture.imageToV;
				break;
			case 1:
				u10 *= this.currentTexture.normalToU;
				v10 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u10;
			this.texCoordV = 1 - v10;
			this.vertex(x2,y2,z2);
			var u11 = 1;
			var v11 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g11 = this.texMode;
			switch(_g11) {
			case 0:
				u11 *= this.currentTexture.imageToU;
				v11 *= this.currentTexture.imageToV;
				break;
			case 1:
				u11 *= this.currentTexture.normalToU;
				v11 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u11;
			this.texCoordV = 1 - v11;
			this.vertex(x2,y1,z2);
			this.normalX = 0;
			this.normalY = -1;
			this.normalZ = 0;
			var u12 = 0;
			var v12 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g12 = this.texMode;
			switch(_g12) {
			case 0:
				u12 *= this.currentTexture.imageToU;
				v12 *= this.currentTexture.imageToV;
				break;
			case 1:
				u12 *= this.currentTexture.normalToU;
				v12 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u12;
			this.texCoordV = 1 - v12;
			this.vertex(x1,y1,z1);
			var u13 = 0;
			var v13 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g13 = this.texMode;
			switch(_g13) {
			case 0:
				u13 *= this.currentTexture.imageToU;
				v13 *= this.currentTexture.imageToV;
				break;
			case 1:
				u13 *= this.currentTexture.normalToU;
				v13 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u13;
			this.texCoordV = 1 - v13;
			this.vertex(x2,y1,z1);
			var u14 = 1;
			var v14 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g14 = this.texMode;
			switch(_g14) {
			case 0:
				u14 *= this.currentTexture.imageToU;
				v14 *= this.currentTexture.imageToV;
				break;
			case 1:
				u14 *= this.currentTexture.normalToU;
				v14 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u14;
			this.texCoordV = 1 - v14;
			this.vertex(x2,y1,z2);
			var u15 = 0;
			var v15 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g15 = this.texMode;
			switch(_g15) {
			case 0:
				u15 *= this.currentTexture.imageToU;
				v15 *= this.currentTexture.imageToV;
				break;
			case 1:
				u15 *= this.currentTexture.normalToU;
				v15 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u15;
			this.texCoordV = 1 - v15;
			this.vertex(x1,y1,z1);
			var u16 = 1;
			var v16 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g16 = this.texMode;
			switch(_g16) {
			case 0:
				u16 *= this.currentTexture.imageToU;
				v16 *= this.currentTexture.imageToV;
				break;
			case 1:
				u16 *= this.currentTexture.normalToU;
				v16 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u16;
			this.texCoordV = 1 - v16;
			this.vertex(x2,y1,z2);
			var u17 = 1;
			var v17 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g17 = this.texMode;
			switch(_g17) {
			case 0:
				u17 *= this.currentTexture.imageToU;
				v17 *= this.currentTexture.imageToV;
				break;
			case 1:
				u17 *= this.currentTexture.normalToU;
				v17 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u17;
			this.texCoordV = 1 - v17;
			this.vertex(x1,y1,z2);
			this.normalX = 0;
			this.normalY = 1;
			this.normalZ = 0;
			var u18 = 0;
			var v18 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g18 = this.texMode;
			switch(_g18) {
			case 0:
				u18 *= this.currentTexture.imageToU;
				v18 *= this.currentTexture.imageToV;
				break;
			case 1:
				u18 *= this.currentTexture.normalToU;
				v18 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u18;
			this.texCoordV = 1 - v18;
			this.vertex(x1,y2,z1);
			var u19 = 0;
			var v19 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g19 = this.texMode;
			switch(_g19) {
			case 0:
				u19 *= this.currentTexture.imageToU;
				v19 *= this.currentTexture.imageToV;
				break;
			case 1:
				u19 *= this.currentTexture.normalToU;
				v19 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u19;
			this.texCoordV = 1 - v19;
			this.vertex(x1,y2,z2);
			var u20 = 1;
			var v20 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g20 = this.texMode;
			switch(_g20) {
			case 0:
				u20 *= this.currentTexture.imageToU;
				v20 *= this.currentTexture.imageToV;
				break;
			case 1:
				u20 *= this.currentTexture.normalToU;
				v20 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u20;
			this.texCoordV = 1 - v20;
			this.vertex(x2,y2,z2);
			var u21 = 0;
			var v21 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g21 = this.texMode;
			switch(_g21) {
			case 0:
				u21 *= this.currentTexture.imageToU;
				v21 *= this.currentTexture.imageToV;
				break;
			case 1:
				u21 *= this.currentTexture.normalToU;
				v21 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u21;
			this.texCoordV = 1 - v21;
			this.vertex(x1,y2,z1);
			var u22 = 1;
			var v22 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g22 = this.texMode;
			switch(_g22) {
			case 0:
				u22 *= this.currentTexture.imageToU;
				v22 *= this.currentTexture.imageToV;
				break;
			case 1:
				u22 *= this.currentTexture.normalToU;
				v22 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u22;
			this.texCoordV = 1 - v22;
			this.vertex(x2,y2,z2);
			var u23 = 1;
			var v23 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g23 = this.texMode;
			switch(_g23) {
			case 0:
				u23 *= this.currentTexture.imageToU;
				v23 *= this.currentTexture.imageToV;
				break;
			case 1:
				u23 *= this.currentTexture.normalToU;
				v23 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u23;
			this.texCoordV = 1 - v23;
			this.vertex(x2,y2,z1);
			this.normalX = 0;
			this.normalY = 0;
			this.normalZ = -1;
			var u24 = 0;
			var v24 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g24 = this.texMode;
			switch(_g24) {
			case 0:
				u24 *= this.currentTexture.imageToU;
				v24 *= this.currentTexture.imageToV;
				break;
			case 1:
				u24 *= this.currentTexture.normalToU;
				v24 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u24;
			this.texCoordV = 1 - v24;
			this.vertex(x1,y1,z1);
			var u25 = 0;
			var v25 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g25 = this.texMode;
			switch(_g25) {
			case 0:
				u25 *= this.currentTexture.imageToU;
				v25 *= this.currentTexture.imageToV;
				break;
			case 1:
				u25 *= this.currentTexture.normalToU;
				v25 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u25;
			this.texCoordV = 1 - v25;
			this.vertex(x1,y2,z1);
			var u26 = 1;
			var v26 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g26 = this.texMode;
			switch(_g26) {
			case 0:
				u26 *= this.currentTexture.imageToU;
				v26 *= this.currentTexture.imageToV;
				break;
			case 1:
				u26 *= this.currentTexture.normalToU;
				v26 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u26;
			this.texCoordV = 1 - v26;
			this.vertex(x2,y2,z1);
			var u27 = 0;
			var v27 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g27 = this.texMode;
			switch(_g27) {
			case 0:
				u27 *= this.currentTexture.imageToU;
				v27 *= this.currentTexture.imageToV;
				break;
			case 1:
				u27 *= this.currentTexture.normalToU;
				v27 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u27;
			this.texCoordV = 1 - v27;
			this.vertex(x1,y1,z1);
			var u28 = 1;
			var v28 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g28 = this.texMode;
			switch(_g28) {
			case 0:
				u28 *= this.currentTexture.imageToU;
				v28 *= this.currentTexture.imageToV;
				break;
			case 1:
				u28 *= this.currentTexture.normalToU;
				v28 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u28;
			this.texCoordV = 1 - v28;
			this.vertex(x2,y2,z1);
			var u29 = 1;
			var v29 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g29 = this.texMode;
			switch(_g29) {
			case 0:
				u29 *= this.currentTexture.imageToU;
				v29 *= this.currentTexture.imageToV;
				break;
			case 1:
				u29 *= this.currentTexture.normalToU;
				v29 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u29;
			this.texCoordV = 1 - v29;
			this.vertex(x2,y1,z1);
			this.normalX = 0;
			this.normalY = 0;
			this.normalZ = 1;
			var u30 = 0;
			var v30 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g30 = this.texMode;
			switch(_g30) {
			case 0:
				u30 *= this.currentTexture.imageToU;
				v30 *= this.currentTexture.imageToV;
				break;
			case 1:
				u30 *= this.currentTexture.normalToU;
				v30 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u30;
			this.texCoordV = 1 - v30;
			this.vertex(x1,y1,z2);
			var u31 = 0;
			var v31 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g31 = this.texMode;
			switch(_g31) {
			case 0:
				u31 *= this.currentTexture.imageToU;
				v31 *= this.currentTexture.imageToV;
				break;
			case 1:
				u31 *= this.currentTexture.normalToU;
				v31 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u31;
			this.texCoordV = 1 - v31;
			this.vertex(x2,y1,z2);
			var u32 = 1;
			var v32 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g32 = this.texMode;
			switch(_g32) {
			case 0:
				u32 *= this.currentTexture.imageToU;
				v32 *= this.currentTexture.imageToV;
				break;
			case 1:
				u32 *= this.currentTexture.normalToU;
				v32 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u32;
			this.texCoordV = 1 - v32;
			this.vertex(x2,y2,z2);
			var u33 = 0;
			var v33 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g33 = this.texMode;
			switch(_g33) {
			case 0:
				u33 *= this.currentTexture.imageToU;
				v33 *= this.currentTexture.imageToV;
				break;
			case 1:
				u33 *= this.currentTexture.normalToU;
				v33 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u33;
			this.texCoordV = 1 - v33;
			this.vertex(x1,y1,z2);
			var u34 = 1;
			var v34 = 1;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g34 = this.texMode;
			switch(_g34) {
			case 0:
				u34 *= this.currentTexture.imageToU;
				v34 *= this.currentTexture.imageToV;
				break;
			case 1:
				u34 *= this.currentTexture.normalToU;
				v34 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u34;
			this.texCoordV = 1 - v34;
			this.vertex(x2,y2,z2);
			var u35 = 1;
			var v35 = 0;
			if(this.currentTexture == null) {
				throw new Error("set texture before calling texCoord");
			}
			var _g35 = this.texMode;
			switch(_g35) {
			case 0:
				u35 *= this.currentTexture.imageToU;
				v35 *= this.currentTexture.imageToV;
				break;
			case 1:
				u35 *= this.currentTexture.normalToU;
				v35 *= this.currentTexture.normalToV;
				break;
			case 2:
				break;
			}
			this.texCoordU = u35;
			this.texCoordV = 1 - v35;
			this.vertex(x1,y2,z2);
		} else {
			this.normalX = -1;
			this.normalY = 0;
			this.normalZ = 0;
			this.vertex(x1,y1,z1);
			this.vertex(x1,y1,z2);
			this.vertex(x1,y2,z2);
			this.vertex(x1,y1,z1);
			this.vertex(x1,y2,z2);
			this.vertex(x1,y2,z1);
			this.normalX = 1;
			this.normalY = 0;
			this.normalZ = 0;
			this.vertex(x2,y1,z1);
			this.vertex(x2,y2,z1);
			this.vertex(x2,y2,z2);
			this.vertex(x2,y1,z1);
			this.vertex(x2,y2,z2);
			this.vertex(x2,y1,z2);
			this.normalX = 0;
			this.normalY = -1;
			this.normalZ = 0;
			this.vertex(x1,y1,z1);
			this.vertex(x2,y1,z1);
			this.vertex(x2,y1,z2);
			this.vertex(x1,y1,z1);
			this.vertex(x2,y1,z2);
			this.vertex(x1,y1,z2);
			this.normalX = 0;
			this.normalY = 1;
			this.normalZ = 0;
			this.vertex(x1,y2,z1);
			this.vertex(x1,y2,z2);
			this.vertex(x2,y2,z2);
			this.vertex(x1,y2,z1);
			this.vertex(x2,y2,z2);
			this.vertex(x2,y2,z1);
			this.normalX = 0;
			this.normalY = 0;
			this.normalZ = -1;
			this.vertex(x1,y1,z1);
			this.vertex(x1,y2,z1);
			this.vertex(x2,y2,z1);
			this.vertex(x1,y1,z1);
			this.vertex(x2,y2,z1);
			this.vertex(x2,y1,z1);
			this.normalX = 0;
			this.normalY = 0;
			this.normalZ = 1;
			this.vertex(x1,y1,z2);
			this.vertex(x2,y1,z2);
			this.vertex(x2,y2,z2);
			this.vertex(x1,y1,z2);
			this.vertex(x2,y2,z2);
			this.vertex(x1,y2,z2);
		}
		var shader = this.chooseShader();
		var pg = shader.pg;
		this.modelviewMat.mul(this.viewMat,this.modelMat);
		this.normalMat.inverse(this.modelviewMat);
		this.normalMat.transpose(this.normalMat);
		var tmp;
		var _this = shader.map;
		if(__map_reserved["model"] != null ? _this.existsReserved("model") : _this.h.hasOwnProperty("model")) {
			var _this1 = shader.map;
			tmp = __map_reserved["model"] != null ? _this1.getReserved("model") : _this1.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this2 = shader.map;
			if(__map_reserved["model"] != null) {
				_this2.setReserved("model",ul);
			} else {
				_this2.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",this.modelMat.array);
		}
		var tmp1;
		var _this3 = shader.map;
		if(__map_reserved["view"] != null ? _this3.existsReserved("view") : _this3.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",this.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",this.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this11 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this11.setReserved("transform",ul3);
			} else {
				_this11.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			this.mvpMat.mul(this.projMat,this.modelviewMat);
			shader.setMatrix("transform",this.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",this.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			this.normalMat.toMat3();
			shader.setMatrix("normalMatrix",this.normalMat.array3);
		}
		if(this.currentTexture != null) {
			shader.setTexture("texture",this.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",this.currentTexture.textureWidth,this.currentTexture.textureHeight);
			}
			var tmp7;
			var _this21 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this21.existsReserved("texViewport") : _this21.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x = 0;
				var y = 1 - this.currentTexture.height / this.currentTexture.textureHeight;
				var w = this.currentTexture.width / this.currentTexture.textureWidth;
				var h = this.currentTexture.height / this.currentTexture.textureHeight;
				shader.setFloat("texViewport",x,y,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",this.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",this.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this31 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this31.getReserved("specular") : _this31.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",this.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",this.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",this.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",this.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g110 = 0;
			var _g36 = this.numLights;
			while(_g110 < _g36) {
				var i = _g110++;
				var light = this.lightBuf[i];
				var x3 = light.posX * this.viewMat.array[0] + light.posY * this.viewMat.array[4] + light.posZ * this.viewMat.array[8] + this.viewMat.array[12];
				var y3 = light.posX * this.viewMat.array[1] + light.posY * this.viewMat.array[5] + light.posZ * this.viewMat.array[9] + this.viewMat.array[13];
				var z = light.posX * this.viewMat.array[2] + light.posY * this.viewMat.array[6] + light.posZ * this.viewMat.array[10] + this.viewMat.array[14];
				shader.setFloat("lightPositions[" + i + "]",x3,y3,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g111 = 0;
			var _g37 = this.numLights;
			while(_g111 < _g37) {
				var i1 = _g111++;
				var light1 = this.lightBuf[i1];
				var x4 = light1.norX * this.viewMat.array[0] + light1.norY * this.viewMat.array[4] + light1.norZ * this.viewMat.array[8];
				var y4 = light1.norX * this.viewMat.array[1] + light1.norY * this.viewMat.array[5] + light1.norZ * this.viewMat.array[9];
				var z3 = light1.norX * this.viewMat.array[2] + light1.norY * this.viewMat.array[6] + light1.norZ * this.viewMat.array[10];
				shader.setFloat("lightNormals[" + i1 + "]",x4,y4,z3);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g112 = 0;
			var _g38 = this.numLights;
			while(_g112 < _g38) {
				var i2 = _g112++;
				var light2 = this.lightBuf[i2];
				shader.setFloat("lightColors[" + i2 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = this.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = this.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = this.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = this.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = this.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = this.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = this.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = this.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = this.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name = shader.uniforms.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name1] != null ? _this60.getReserved(name1) : _this60.h[name1];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name2 = shader.uniforms.keys();
		while(name2.hasNext()) {
			var name3 = name2.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name3] != null ? _this61.getReserved(name3) : _this61.h[name3];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name3] != null ? _this62.existsReserved(name3) : _this62.h.hasOwnProperty(name3)) {
				var _this63 = shader.map;
				loc = __map_reserved[name3] != null ? _this63.getReserved(name3) : _this63.h[name3];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name3);
				var _this64 = shader.map;
				if(__map_reserved[name3] != null) {
					_this64.setReserved(name3,ul17);
				} else {
					_this64.h[name3] = ul17;
				}
				loc = ul17;
			}
			var _g39 = uniform1.type;
			switch(_g39) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = this.indexBuf;
		var mode = this.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
		this.texMode = tmpTexMode;
	}
	,color: function(r,g,b,a) {
		if(a == null) {
			a = 1;
		}
		this.colorR = r;
		this.colorG = g;
		this.colorB = b;
		this.colorA = a;
	}
	,normal: function(x,y,z) {
		this.normalX = x;
		this.normalY = y;
		this.normalZ = z;
	}
	,noLights: function() {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		this.numLights = 0;
	}
	,lights: function() {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		if(this.numLights == 8) {
			throw new Error("too many lights");
		}
		var light = this.lightBuf[this.numLights++];
		light.r = 0.2;
		light.g = 0.2;
		light.b = 0.2;
		light.posX = 0;
		light.posY = 0;
		light.posZ = 0;
		light.posW = 0;
		light.norX = 0;
		light.norY = 0;
		light.norZ = 0;
		var dirX = -this.viewMat.array[2];
		var dirY = -this.viewMat.array[6];
		var dirZ = -this.viewMat.array[10];
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		if(this.numLights == 8) {
			throw new Error("too many lights");
		}
		var light1 = this.lightBuf[this.numLights++];
		var invLen = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
		if(invLen > 0) {
			invLen = 1 / invLen;
		}
		dirX *= invLen;
		dirY *= invLen;
		dirZ *= invLen;
		light1.r = 0.8;
		light1.g = 0.8;
		light1.b = 0.8;
		light1.posX = 0;
		light1.posY = 0;
		light1.posZ = 0;
		light1.posW = 0;
		light1.norX = dirX;
		light1.norY = dirY;
		light1.norZ = dirZ;
	}
	,ambientLight: function(r,g,b) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		if(this.numLights == 8) {
			throw new Error("too many lights");
		}
		var light = this.lightBuf[this.numLights++];
		light.r = r;
		light.g = g;
		light.b = b;
		light.posX = 0;
		light.posY = 0;
		light.posZ = 0;
		light.posW = 0;
		light.norX = 0;
		light.norY = 0;
		light.norZ = 0;
	}
	,directionalLight: function(r,g,b,dirX,dirY,dirZ) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		if(this.numLights == 8) {
			throw new Error("too many lights");
		}
		var light = this.lightBuf[this.numLights++];
		var invLen = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
		if(invLen > 0) {
			invLen = 1 / invLen;
		}
		dirX *= invLen;
		dirY *= invLen;
		dirZ *= invLen;
		light.r = r;
		light.g = g;
		light.b = b;
		light.posX = 0;
		light.posY = 0;
		light.posZ = 0;
		light.posW = 0;
		light.norX = dirX;
		light.norY = dirY;
		light.norZ = dirZ;
	}
	,pointLight: function(r,g,b,x,y,z) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting lights");
		}
		if(this.numLights == 8) {
			throw new Error("too many lights");
		}
		var light = this.lightBuf[this.numLights++];
		light.r = r;
		light.g = g;
		light.b = b;
		light.posX = x;
		light.posY = y;
		light.posZ = z;
		light.posW = 1;
		light.norX = 0;
		light.norY = 0;
		light.norZ = 0;
	}
	,ambient: function(v) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting material");
		}
		this.materialAmb = v;
	}
	,diffuse: function(v) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting material");
		}
		this.materialDif = v;
	}
	,specular: function(v) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting material");
		}
		this.materialSpc = v;
	}
	,shininess: function(v) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting material");
		}
		this.materialShn = v;
	}
	,emission: function(v) {
		if(!this.sceneOpen) {
			throw new Error("begin scene before setting material");
		}
		this.materialEmi = v;
	}
	,texCoord: function(u,v) {
		if(this.currentTexture == null) {
			throw new Error("set texture before calling texCoord");
		}
		var _g = this.texMode;
		switch(_g) {
		case 0:
			u *= this.currentTexture.imageToU;
			v *= this.currentTexture.imageToV;
			break;
		case 1:
			u *= this.currentTexture.normalToU;
			v *= this.currentTexture.normalToV;
			break;
		case 2:
			break;
		}
		this.texCoordU = u;
		this.texCoordV = 1 - v;
	}
	,textureMode: function(mode) {
		this.texMode = mode;
	}
	,texture: function(tex) {
		this.currentTexture = tex;
	}
	,noTexture: function() {
		this.currentTexture = null;
	}
	,vertex: function(x,y,z) {
		if(z == null) {
			z = 0;
		}
		var _this = this.indexBuf;
		var i = this.numVertices++;
		if(_this.length == _this.array.length) {
			var oldLength = _this.array.length;
			var newArray = new Int16Array(oldLength << 1);
			var _g1 = 0;
			var _g = oldLength;
			while(_g1 < _g) {
				var i1 = _g1++;
				newArray[i1] = _this.array[i1];
			}
			_this.array = newArray;
		}
		_this.array[_this.length++] = i;
		var _this1 = this.positionBuf;
		if(_this1.length == _this1.array.length) {
			var oldLength1 = _this1.array.length;
			var newArray1 = new Float32Array(oldLength1 << 1);
			var _g11 = 0;
			var _g2 = oldLength1;
			while(_g11 < _g2) {
				var i2 = _g11++;
				newArray1[i2] = _this1.array[i2];
			}
			_this1.array = newArray1;
		}
		_this1.array[_this1.length++] = x;
		var _this2 = this.positionBuf;
		if(_this2.length == _this2.array.length) {
			var oldLength2 = _this2.array.length;
			var newArray2 = new Float32Array(oldLength2 << 1);
			var _g12 = 0;
			var _g3 = oldLength2;
			while(_g12 < _g3) {
				var i3 = _g12++;
				newArray2[i3] = _this2.array[i3];
			}
			_this2.array = newArray2;
		}
		_this2.array[_this2.length++] = y;
		var _this3 = this.positionBuf;
		if(_this3.length == _this3.array.length) {
			var oldLength3 = _this3.array.length;
			var newArray3 = new Float32Array(oldLength3 << 1);
			var _g13 = 0;
			var _g4 = oldLength3;
			while(_g13 < _g4) {
				var i4 = _g13++;
				newArray3[i4] = _this3.array[i4];
			}
			_this3.array = newArray3;
		}
		_this3.array[_this3.length++] = z;
		var _this4 = this.colorBuf;
		var f = this.colorR;
		if(_this4.length == _this4.array.length) {
			var oldLength4 = _this4.array.length;
			var newArray4 = new Float32Array(oldLength4 << 1);
			var _g14 = 0;
			var _g5 = oldLength4;
			while(_g14 < _g5) {
				var i5 = _g14++;
				newArray4[i5] = _this4.array[i5];
			}
			_this4.array = newArray4;
		}
		_this4.array[_this4.length++] = f;
		var _this5 = this.colorBuf;
		var f1 = this.colorG;
		if(_this5.length == _this5.array.length) {
			var oldLength5 = _this5.array.length;
			var newArray5 = new Float32Array(oldLength5 << 1);
			var _g15 = 0;
			var _g6 = oldLength5;
			while(_g15 < _g6) {
				var i6 = _g15++;
				newArray5[i6] = _this5.array[i6];
			}
			_this5.array = newArray5;
		}
		_this5.array[_this5.length++] = f1;
		var _this6 = this.colorBuf;
		var f2 = this.colorB;
		if(_this6.length == _this6.array.length) {
			var oldLength6 = _this6.array.length;
			var newArray6 = new Float32Array(oldLength6 << 1);
			var _g16 = 0;
			var _g7 = oldLength6;
			while(_g16 < _g7) {
				var i7 = _g16++;
				newArray6[i7] = _this6.array[i7];
			}
			_this6.array = newArray6;
		}
		_this6.array[_this6.length++] = f2;
		var _this7 = this.colorBuf;
		var f3 = this.colorA;
		if(_this7.length == _this7.array.length) {
			var oldLength7 = _this7.array.length;
			var newArray7 = new Float32Array(oldLength7 << 1);
			var _g17 = 0;
			var _g8 = oldLength7;
			while(_g17 < _g8) {
				var i8 = _g17++;
				newArray7[i8] = _this7.array[i8];
			}
			_this7.array = newArray7;
		}
		_this7.array[_this7.length++] = f3;
		var _this8 = this.normalBuf;
		var f4 = this.normalX;
		if(_this8.length == _this8.array.length) {
			var oldLength8 = _this8.array.length;
			var newArray8 = new Float32Array(oldLength8 << 1);
			var _g18 = 0;
			var _g9 = oldLength8;
			while(_g18 < _g9) {
				var i9 = _g18++;
				newArray8[i9] = _this8.array[i9];
			}
			_this8.array = newArray8;
		}
		_this8.array[_this8.length++] = f4;
		var _this9 = this.normalBuf;
		var f5 = this.normalY;
		if(_this9.length == _this9.array.length) {
			var oldLength9 = _this9.array.length;
			var newArray9 = new Float32Array(oldLength9 << 1);
			var _g19 = 0;
			var _g10 = oldLength9;
			while(_g19 < _g10) {
				var i10 = _g19++;
				newArray9[i10] = _this9.array[i10];
			}
			_this9.array = newArray9;
		}
		_this9.array[_this9.length++] = f5;
		var _this10 = this.normalBuf;
		var f6 = this.normalZ;
		if(_this10.length == _this10.array.length) {
			var oldLength10 = _this10.array.length;
			var newArray10 = new Float32Array(oldLength10 << 1);
			var _g110 = 0;
			var _g20 = oldLength10;
			while(_g110 < _g20) {
				var i11 = _g110++;
				newArray10[i11] = _this10.array[i11];
			}
			_this10.array = newArray10;
		}
		_this10.array[_this10.length++] = f6;
		var _this11 = this.texCoordBuf;
		var f7 = this.texCoordU;
		if(_this11.length == _this11.array.length) {
			var oldLength11 = _this11.array.length;
			var newArray11 = new Float32Array(oldLength11 << 1);
			var _g111 = 0;
			var _g21 = oldLength11;
			while(_g111 < _g21) {
				var i12 = _g111++;
				newArray11[i12] = _this11.array[i12];
			}
			_this11.array = newArray11;
		}
		_this11.array[_this11.length++] = f7;
		var _this12 = this.texCoordBuf;
		var f8 = this.texCoordV;
		if(_this12.length == _this12.array.length) {
			var oldLength12 = _this12.array.length;
			var newArray12 = new Float32Array(oldLength12 << 1);
			var _g112 = 0;
			var _g22 = oldLength12;
			while(_g112 < _g22) {
				var i13 = _g112++;
				newArray12[i13] = _this12.array[i13];
			}
			_this12.array = newArray12;
		}
		_this12.array[_this12.length++] = f8;
	}
	,endShape: function() {
		var shader = this.chooseShader();
		var pg = shader.pg;
		this.modelviewMat.mul(this.viewMat,this.modelMat);
		this.normalMat.inverse(this.modelviewMat);
		this.normalMat.transpose(this.normalMat);
		var tmp;
		var _this = shader.map;
		if(__map_reserved["model"] != null ? _this.existsReserved("model") : _this.h.hasOwnProperty("model")) {
			var _this1 = shader.map;
			tmp = __map_reserved["model"] != null ? _this1.getReserved("model") : _this1.h["model"];
		} else {
			var ul = shader.gl.getUniformLocation(shader.pg,"model");
			var _this2 = shader.map;
			if(__map_reserved["model"] != null) {
				_this2.setReserved("model",ul);
			} else {
				_this2.h["model"] = ul;
			}
			tmp = ul;
		}
		if(tmp != null) {
			shader.setMatrix("model",this.modelMat.array);
		}
		var tmp1;
		var _this3 = shader.map;
		if(__map_reserved["view"] != null ? _this3.existsReserved("view") : _this3.h.hasOwnProperty("view")) {
			var _this4 = shader.map;
			tmp1 = __map_reserved["view"] != null ? _this4.getReserved("view") : _this4.h["view"];
		} else {
			var ul1 = shader.gl.getUniformLocation(shader.pg,"view");
			var _this5 = shader.map;
			if(__map_reserved["view"] != null) {
				_this5.setReserved("view",ul1);
			} else {
				_this5.h["view"] = ul1;
			}
			tmp1 = ul1;
		}
		if(tmp1 != null) {
			shader.setMatrix("view",this.viewMat.array);
		}
		var tmp2;
		var _this6 = shader.map;
		if(__map_reserved["projection"] != null ? _this6.existsReserved("projection") : _this6.h.hasOwnProperty("projection")) {
			var _this7 = shader.map;
			tmp2 = __map_reserved["projection"] != null ? _this7.getReserved("projection") : _this7.h["projection"];
		} else {
			var ul2 = shader.gl.getUniformLocation(shader.pg,"projection");
			var _this8 = shader.map;
			if(__map_reserved["projection"] != null) {
				_this8.setReserved("projection",ul2);
			} else {
				_this8.h["projection"] = ul2;
			}
			tmp2 = ul2;
		}
		if(tmp2 != null) {
			shader.setMatrix("projection",this.projMat.array);
		}
		var tmp3;
		var _this9 = shader.map;
		if(__map_reserved["transform"] != null ? _this9.existsReserved("transform") : _this9.h.hasOwnProperty("transform")) {
			var _this10 = shader.map;
			tmp3 = __map_reserved["transform"] != null ? _this10.getReserved("transform") : _this10.h["transform"];
		} else {
			var ul3 = shader.gl.getUniformLocation(shader.pg,"transform");
			var _this11 = shader.map;
			if(__map_reserved["transform"] != null) {
				_this11.setReserved("transform",ul3);
			} else {
				_this11.h["transform"] = ul3;
			}
			tmp3 = ul3;
		}
		if(tmp3 != null) {
			this.mvpMat.mul(this.projMat,this.modelviewMat);
			shader.setMatrix("transform",this.mvpMat.array);
		}
		var tmp4;
		var _this12 = shader.map;
		if(__map_reserved["modelview"] != null ? _this12.existsReserved("modelview") : _this12.h.hasOwnProperty("modelview")) {
			var _this13 = shader.map;
			tmp4 = __map_reserved["modelview"] != null ? _this13.getReserved("modelview") : _this13.h["modelview"];
		} else {
			var ul4 = shader.gl.getUniformLocation(shader.pg,"modelview");
			var _this14 = shader.map;
			if(__map_reserved["modelview"] != null) {
				_this14.setReserved("modelview",ul4);
			} else {
				_this14.h["modelview"] = ul4;
			}
			tmp4 = ul4;
		}
		if(tmp4 != null) {
			shader.setMatrix("modelview",this.modelviewMat.array);
		}
		var tmp5;
		var _this15 = shader.map;
		if(__map_reserved["normalMatrix"] != null ? _this15.existsReserved("normalMatrix") : _this15.h.hasOwnProperty("normalMatrix")) {
			var _this16 = shader.map;
			tmp5 = __map_reserved["normalMatrix"] != null ? _this16.getReserved("normalMatrix") : _this16.h["normalMatrix"];
		} else {
			var ul5 = shader.gl.getUniformLocation(shader.pg,"normalMatrix");
			var _this17 = shader.map;
			if(__map_reserved["normalMatrix"] != null) {
				_this17.setReserved("normalMatrix",ul5);
			} else {
				_this17.h["normalMatrix"] = ul5;
			}
			tmp5 = ul5;
		}
		if(tmp5 != null) {
			this.normalMat.toMat3();
			shader.setMatrix("normalMatrix",this.normalMat.array3);
		}
		if(this.currentTexture != null) {
			shader.setTexture("texture",this.currentTexture);
			var tmp6;
			var _this18 = shader.map;
			if(__map_reserved["texResolution"] != null ? _this18.existsReserved("texResolution") : _this18.h.hasOwnProperty("texResolution")) {
				var _this19 = shader.map;
				tmp6 = __map_reserved["texResolution"] != null ? _this19.getReserved("texResolution") : _this19.h["texResolution"];
			} else {
				var ul6 = shader.gl.getUniformLocation(shader.pg,"texResolution");
				var _this20 = shader.map;
				if(__map_reserved["texResolution"] != null) {
					_this20.setReserved("texResolution",ul6);
				} else {
					_this20.h["texResolution"] = ul6;
				}
				tmp6 = ul6;
			}
			if(tmp6 != null) {
				shader.setFloat("texResolution",this.currentTexture.textureWidth,this.currentTexture.textureHeight);
			}
			var tmp7;
			var _this21 = shader.map;
			if(__map_reserved["texViewport"] != null ? _this21.existsReserved("texViewport") : _this21.h.hasOwnProperty("texViewport")) {
				var _this22 = shader.map;
				tmp7 = __map_reserved["texViewport"] != null ? _this22.getReserved("texViewport") : _this22.h["texViewport"];
			} else {
				var ul7 = shader.gl.getUniformLocation(shader.pg,"texViewport");
				var _this23 = shader.map;
				if(__map_reserved["texViewport"] != null) {
					_this23.setReserved("texViewport",ul7);
				} else {
					_this23.h["texViewport"] = ul7;
				}
				tmp7 = ul7;
			}
			if(tmp7 != null) {
				var x = 0;
				var y = 1 - this.currentTexture.height / this.currentTexture.textureHeight;
				var w = this.currentTexture.width / this.currentTexture.textureWidth;
				var h = this.currentTexture.height / this.currentTexture.textureHeight;
				shader.setFloat("texViewport",x,y,w,h);
			}
		}
		var tmp8;
		var _this24 = shader.map;
		if(__map_reserved["ambient"] != null ? _this24.existsReserved("ambient") : _this24.h.hasOwnProperty("ambient")) {
			var _this25 = shader.map;
			tmp8 = __map_reserved["ambient"] != null ? _this25.getReserved("ambient") : _this25.h["ambient"];
		} else {
			var ul8 = shader.gl.getUniformLocation(shader.pg,"ambient");
			var _this26 = shader.map;
			if(__map_reserved["ambient"] != null) {
				_this26.setReserved("ambient",ul8);
			} else {
				_this26.h["ambient"] = ul8;
			}
			tmp8 = ul8;
		}
		if(tmp8 != null) {
			shader.setFloat("ambient",this.materialAmb);
		}
		var tmp9;
		var _this27 = shader.map;
		if(__map_reserved["diffuse"] != null ? _this27.existsReserved("diffuse") : _this27.h.hasOwnProperty("diffuse")) {
			var _this28 = shader.map;
			tmp9 = __map_reserved["diffuse"] != null ? _this28.getReserved("diffuse") : _this28.h["diffuse"];
		} else {
			var ul9 = shader.gl.getUniformLocation(shader.pg,"diffuse");
			var _this29 = shader.map;
			if(__map_reserved["diffuse"] != null) {
				_this29.setReserved("diffuse",ul9);
			} else {
				_this29.h["diffuse"] = ul9;
			}
			tmp9 = ul9;
		}
		if(tmp9 != null) {
			shader.setFloat("diffuse",this.materialDif);
		}
		var tmp10;
		var _this30 = shader.map;
		if(__map_reserved["specular"] != null ? _this30.existsReserved("specular") : _this30.h.hasOwnProperty("specular")) {
			var _this31 = shader.map;
			tmp10 = __map_reserved["specular"] != null ? _this31.getReserved("specular") : _this31.h["specular"];
		} else {
			var ul10 = shader.gl.getUniformLocation(shader.pg,"specular");
			var _this32 = shader.map;
			if(__map_reserved["specular"] != null) {
				_this32.setReserved("specular",ul10);
			} else {
				_this32.h["specular"] = ul10;
			}
			tmp10 = ul10;
		}
		if(tmp10 != null) {
			shader.setFloat("specular",this.materialSpc);
		}
		var tmp11;
		var _this33 = shader.map;
		if(__map_reserved["shininess"] != null ? _this33.existsReserved("shininess") : _this33.h.hasOwnProperty("shininess")) {
			var _this34 = shader.map;
			tmp11 = __map_reserved["shininess"] != null ? _this34.getReserved("shininess") : _this34.h["shininess"];
		} else {
			var ul11 = shader.gl.getUniformLocation(shader.pg,"shininess");
			var _this35 = shader.map;
			if(__map_reserved["shininess"] != null) {
				_this35.setReserved("shininess",ul11);
			} else {
				_this35.h["shininess"] = ul11;
			}
			tmp11 = ul11;
		}
		if(tmp11 != null) {
			shader.setFloat("shininess",this.materialShn);
		}
		var tmp12;
		var _this36 = shader.map;
		if(__map_reserved["emission"] != null ? _this36.existsReserved("emission") : _this36.h.hasOwnProperty("emission")) {
			var _this37 = shader.map;
			tmp12 = __map_reserved["emission"] != null ? _this37.getReserved("emission") : _this37.h["emission"];
		} else {
			var ul12 = shader.gl.getUniformLocation(shader.pg,"emission");
			var _this38 = shader.map;
			if(__map_reserved["emission"] != null) {
				_this38.setReserved("emission",ul12);
			} else {
				_this38.h["emission"] = ul12;
			}
			tmp12 = ul12;
		}
		if(tmp12 != null) {
			shader.setFloat("emission",this.materialEmi);
		}
		var tmp13;
		var _this39 = shader.map;
		if(__map_reserved["numLights"] != null ? _this39.existsReserved("numLights") : _this39.h.hasOwnProperty("numLights")) {
			var _this40 = shader.map;
			tmp13 = __map_reserved["numLights"] != null ? _this40.getReserved("numLights") : _this40.h["numLights"];
		} else {
			var ul13 = shader.gl.getUniformLocation(shader.pg,"numLights");
			var _this41 = shader.map;
			if(__map_reserved["numLights"] != null) {
				_this41.setReserved("numLights",ul13);
			} else {
				_this41.h["numLights"] = ul13;
			}
			tmp13 = ul13;
		}
		if(tmp13 != null) {
			shader.setInt("numLights",this.numLights);
		}
		var tmp14;
		var _this42 = shader.map;
		if(__map_reserved["lightPositions"] != null ? _this42.existsReserved("lightPositions") : _this42.h.hasOwnProperty("lightPositions")) {
			var _this43 = shader.map;
			tmp14 = __map_reserved["lightPositions"] != null ? _this43.getReserved("lightPositions") : _this43.h["lightPositions"];
		} else {
			var ul14 = shader.gl.getUniformLocation(shader.pg,"lightPositions");
			var _this44 = shader.map;
			if(__map_reserved["lightPositions"] != null) {
				_this44.setReserved("lightPositions",ul14);
			} else {
				_this44.h["lightPositions"] = ul14;
			}
			tmp14 = ul14;
		}
		if(tmp14 != null) {
			var _g1 = 0;
			var _g = this.numLights;
			while(_g1 < _g) {
				var i = _g1++;
				var light = this.lightBuf[i];
				var x1 = light.posX * this.viewMat.array[0] + light.posY * this.viewMat.array[4] + light.posZ * this.viewMat.array[8] + this.viewMat.array[12];
				var y1 = light.posX * this.viewMat.array[1] + light.posY * this.viewMat.array[5] + light.posZ * this.viewMat.array[9] + this.viewMat.array[13];
				var z = light.posX * this.viewMat.array[2] + light.posY * this.viewMat.array[6] + light.posZ * this.viewMat.array[10] + this.viewMat.array[14];
				shader.setFloat("lightPositions[" + i + "]",x1,y1,z,light.posW);
			}
		}
		var tmp15;
		var _this45 = shader.map;
		if(__map_reserved["lightNormals"] != null ? _this45.existsReserved("lightNormals") : _this45.h.hasOwnProperty("lightNormals")) {
			var _this46 = shader.map;
			tmp15 = __map_reserved["lightNormals"] != null ? _this46.getReserved("lightNormals") : _this46.h["lightNormals"];
		} else {
			var ul15 = shader.gl.getUniformLocation(shader.pg,"lightNormals");
			var _this47 = shader.map;
			if(__map_reserved["lightNormals"] != null) {
				_this47.setReserved("lightNormals",ul15);
			} else {
				_this47.h["lightNormals"] = ul15;
			}
			tmp15 = ul15;
		}
		if(tmp15 != null) {
			var _g11 = 0;
			var _g2 = this.numLights;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var light1 = this.lightBuf[i1];
				var x2 = light1.norX * this.viewMat.array[0] + light1.norY * this.viewMat.array[4] + light1.norZ * this.viewMat.array[8];
				var y2 = light1.norX * this.viewMat.array[1] + light1.norY * this.viewMat.array[5] + light1.norZ * this.viewMat.array[9];
				var z1 = light1.norX * this.viewMat.array[2] + light1.norY * this.viewMat.array[6] + light1.norZ * this.viewMat.array[10];
				shader.setFloat("lightNormals[" + i1 + "]",x2,y2,z1);
			}
		}
		var tmp16;
		var _this48 = shader.map;
		if(__map_reserved["lightColors"] != null ? _this48.existsReserved("lightColors") : _this48.h.hasOwnProperty("lightColors")) {
			var _this49 = shader.map;
			tmp16 = __map_reserved["lightColors"] != null ? _this49.getReserved("lightColors") : _this49.h["lightColors"];
		} else {
			var ul16 = shader.gl.getUniformLocation(shader.pg,"lightColors");
			var _this50 = shader.map;
			if(__map_reserved["lightColors"] != null) {
				_this50.setReserved("lightColors",ul16);
			} else {
				_this50.h["lightColors"] = ul16;
			}
			tmp16 = ul16;
		}
		if(tmp16 != null) {
			var _g12 = 0;
			var _g3 = this.numLights;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var light2 = this.lightBuf[i2];
				shader.setFloat("lightColors[" + i2 + "]",light2.r,light2.g,light2.b);
			}
		}
		var _this51 = this.indexBuf;
		_this51.gl.bindBuffer(34963,_this51.buffer);
		_this51.gl.bufferData(34963,new Int16Array(_this51.array.buffer,0,_this51.length),35044);
		_this51.gl.bindBuffer(34963,null);
		var _this52 = this.positionBuf;
		_this52.gl.bindBuffer(34962,_this52.buffer);
		_this52.gl.bufferData(34962,new Float32Array(_this52.array.buffer,0,_this52.length),35044);
		_this52.gl.bindBuffer(34962,null);
		var _this53 = this.colorBuf;
		_this53.gl.bindBuffer(34962,_this53.buffer);
		_this53.gl.bufferData(34962,new Float32Array(_this53.array.buffer,0,_this53.length),35044);
		_this53.gl.bindBuffer(34962,null);
		var _this54 = this.normalBuf;
		_this54.gl.bindBuffer(34962,_this54.buffer);
		_this54.gl.bufferData(34962,new Float32Array(_this54.array.buffer,0,_this54.length),35044);
		_this54.gl.bindBuffer(34962,null);
		var _this55 = this.texCoordBuf;
		_this55.gl.bindBuffer(34962,_this55.buffer);
		_this55.gl.bufferData(34962,new Float32Array(_this55.array.buffer,0,_this55.length),35044);
		_this55.gl.bindBuffer(34962,null);
		var _this56 = this.positionBuf;
		var idx = _this56.gl.getAttribLocation(pg,_this56.name);
		if(idx != -1) {
			_this56.gl.bindBuffer(34962,_this56.buffer);
			_this56.gl.enableVertexAttribArray(idx);
			_this56.gl.vertexAttribPointer(idx,_this56.size,5126,false,0,0);
			_this56.gl.bindBuffer(34962,null);
		}
		var _this57 = this.colorBuf;
		var idx1 = _this57.gl.getAttribLocation(pg,_this57.name);
		if(idx1 != -1) {
			_this57.gl.bindBuffer(34962,_this57.buffer);
			_this57.gl.enableVertexAttribArray(idx1);
			_this57.gl.vertexAttribPointer(idx1,_this57.size,5126,false,0,0);
			_this57.gl.bindBuffer(34962,null);
		}
		var _this58 = this.normalBuf;
		var idx2 = _this58.gl.getAttribLocation(pg,_this58.name);
		if(idx2 != -1) {
			_this58.gl.bindBuffer(34962,_this58.buffer);
			_this58.gl.enableVertexAttribArray(idx2);
			_this58.gl.vertexAttribPointer(idx2,_this58.size,5126,false,0,0);
			_this58.gl.bindBuffer(34962,null);
		}
		var _this59 = this.texCoordBuf;
		var idx3 = _this59.gl.getAttribLocation(pg,_this59.name);
		if(idx3 != -1) {
			_this59.gl.bindBuffer(34962,_this59.buffer);
			_this59.gl.enableVertexAttribArray(idx3);
			_this59.gl.vertexAttribPointer(idx3,_this59.size,5126,false,0,0);
			_this59.gl.bindBuffer(34962,null);
		}
		if(!shader.compiled) {
			throw new Error("shader is not compiled");
		}
		shader.gl.useProgram(shader.pg);
		var texUnit = 0;
		var name = shader.uniforms.keys();
		while(name.hasNext()) {
			var name1 = name.next();
			var _this60 = shader.uniforms;
			var uniform = __map_reserved[name1] != null ? _this60.getReserved(name1) : _this60.h[name1];
			if(uniform.type == 11) {
				uniform.texUnit = texUnit;
				++texUnit;
			}
		}
		var name2 = shader.uniforms.keys();
		while(name2.hasNext()) {
			var name3 = name2.next();
			var _this61 = shader.uniforms;
			var uniform1 = __map_reserved[name3] != null ? _this61.getReserved(name3) : _this61.h[name3];
			var loc;
			var _this62 = shader.map;
			if(__map_reserved[name3] != null ? _this62.existsReserved(name3) : _this62.h.hasOwnProperty(name3)) {
				var _this63 = shader.map;
				loc = __map_reserved[name3] != null ? _this63.getReserved(name3) : _this63.h[name3];
			} else {
				var ul17 = shader.gl.getUniformLocation(shader.pg,name3);
				var _this64 = shader.map;
				if(__map_reserved[name3] != null) {
					_this64.setReserved(name3,ul17);
				} else {
					_this64.h[name3] = ul17;
				}
				loc = ul17;
			}
			var _g4 = uniform1.type;
			switch(_g4) {
			case 0:
				shader.gl.uniform1i(loc,uniform1.i1);
				break;
			case 1:
				shader.gl.uniform2i(loc,uniform1.i1,uniform1.i2);
				break;
			case 2:
				shader.gl.uniform3i(loc,uniform1.i1,uniform1.i2,uniform1.i3);
				break;
			case 3:
				shader.gl.uniform4i(loc,uniform1.i1,uniform1.i2,uniform1.i3,uniform1.i4);
				break;
			case 4:
				shader.gl.uniform1f(loc,uniform1.f1);
				break;
			case 5:
				shader.gl.uniform2f(loc,uniform1.f1,uniform1.f2);
				break;
			case 6:
				shader.gl.uniform3f(loc,uniform1.f1,uniform1.f2,uniform1.f3);
				break;
			case 7:
				shader.gl.uniform4f(loc,uniform1.f1,uniform1.f2,uniform1.f3,uniform1.f4);
				break;
			case 8:
				shader.gl.uniformMatrix2fv(loc,false,uniform1.m2);
				break;
			case 9:
				shader.gl.uniformMatrix3fv(loc,false,uniform1.m3);
				break;
			case 10:
				shader.gl.uniformMatrix4fv(loc,false,uniform1.m4);
				break;
			case 11:
				shader.gl.activeTexture(33984 + uniform1.texUnit);
				shader.gl.bindTexture(3553,uniform1.tex == null ? null : uniform1.tex.texture);
				shader.gl.uniform1i(loc,uniform1.texUnit);
				break;
			}
		}
		shader.gl.activeTexture(33984);
		var _this65 = this.indexBuf;
		var mode = this.shapeMode;
		_this65.gl.bindBuffer(34963,_this65.buffer);
		_this65.gl.drawElements(mode,_this65.length,5123,0);
		_this65.gl.bindBuffer(34963,null);
	}
};
var pot_graphics__$Graphics_Light = function() {
};
pot_graphics__$Graphics_Light.__name__ = true;
var pot_graphics__$Graphics_UniformMatrix = function() {
	var _g = [];
	var _g1 = 0;
	while(_g1 < 16) {
		var i = _g1++;
		_g.push(0);
	}
	this.array = _g;
	var _g11 = [];
	var _g2 = 0;
	while(_g2 < 9) {
		var i1 = _g2++;
		_g11.push(0);
	}
	this.array3 = _g11;
};
pot_graphics__$Graphics_UniformMatrix.__name__ = true;
pot_graphics__$Graphics_UniformMatrix.prototype = {
	identity: function() {
		this.array[0] = 1;
		this.array[1] = 0;
		this.array[2] = 0;
		this.array[3] = 0;
		this.array[4] = 0;
		this.array[5] = 1;
		this.array[6] = 0;
		this.array[7] = 0;
		this.array[8] = 0;
		this.array[9] = 0;
		this.array[10] = 1;
		this.array[11] = 0;
		this.array[12] = 0;
		this.array[13] = 0;
		this.array[14] = 0;
		this.array[15] = 1;
	}
	,lookAt: function(eyeX,eyeY,eyeZ,atX,atY,atZ,upX,upY,upZ) {
		var zx = eyeX - atX;
		var zy = eyeY - atY;
		var zz = eyeZ - atZ;
		var tmp = 1 / Math.sqrt(zx * zx + zy * zy + zz * zz);
		zx *= tmp;
		zy *= tmp;
		zz *= tmp;
		var xx = upY * zz - upZ * zy;
		var xy = upZ * zx - upX * zz;
		var xz = upX * zy - upY * zx;
		tmp = 1 / Math.sqrt(xx * xx + xy * xy + xz * xz);
		xx *= tmp;
		xy *= tmp;
		xz *= tmp;
		var yx = zy * xz - zz * xy;
		var yy = zz * xx - zx * xz;
		var yz = zx * xy - zy * xx;
		this.array[0] = xx;
		this.array[1] = yx;
		this.array[2] = zx;
		this.array[3] = 0;
		this.array[4] = xy;
		this.array[5] = yy;
		this.array[6] = zy;
		this.array[7] = 0;
		this.array[8] = xz;
		this.array[9] = yz;
		this.array[10] = zz;
		this.array[11] = 0;
		this.array[12] = -(xx * eyeX + xy * eyeY + xz * eyeZ);
		this.array[13] = -(yx * eyeX + yy * eyeY + yz * eyeZ);
		this.array[14] = -(zx * eyeX + zy * eyeY + zz * eyeZ);
		this.array[15] = 1;
	}
	,perspective: function(fovY,aspect,near,far) {
		var h = 1 / Math.tan(fovY * 0.5);
		var fnf = far / (near - far);
		this.array[0] = h / aspect;
		this.array[1] = 0;
		this.array[2] = 0;
		this.array[3] = 0;
		this.array[4] = 0;
		this.array[5] = h;
		this.array[6] = 0;
		this.array[7] = 0;
		this.array[8] = 0;
		this.array[9] = 0;
		this.array[10] = fnf;
		this.array[11] = -1;
		this.array[12] = 0;
		this.array[13] = 0;
		this.array[14] = near * fnf;
		this.array[15] = 0;
	}
	,ortho: function(width,height,near,far) {
		var nf = 1 / (near - far);
		this.array[0] = 2 / width;
		this.array[1] = 0;
		this.array[2] = 0;
		this.array[3] = 0;
		this.array[4] = 0;
		this.array[5] = 2 / height;
		this.array[6] = 0;
		this.array[7] = 0;
		this.array[8] = 0;
		this.array[9] = 0;
		this.array[10] = nf;
		this.array[11] = 0;
		this.array[12] = 0;
		this.array[13] = 0;
		this.array[14] = near * nf;
		this.array[15] = 1;
	}
	,appendScale: function(sx,sy,sz) {
		this.array[0] *= sx;
		this.array[1] *= sx;
		this.array[2] *= sx;
		this.array[3] *= sx;
		this.array[4] *= sy;
		this.array[5] *= sy;
		this.array[6] *= sy;
		this.array[7] *= sy;
		this.array[8] *= sz;
		this.array[9] *= sz;
		this.array[10] *= sz;
		this.array[11] *= sz;
	}
	,appendRotation: function(rad,ax,ay,az) {
		var s = Math.sin(rad);
		var c = Math.cos(rad);
		var c1 = 1 - c;
		var r00 = ax * ax * c1 + c;
		var r01 = ax * ay * c1 - az * s;
		var r02 = ax * az * c1 + ay * s;
		var r10 = ay * ax * c1 + az * s;
		var r11 = ay * ay * c1 + c;
		var r12 = ay * az * c1 - ax * s;
		var r20 = az * ax * c1 - ay * s;
		var r21 = az * ay * c1 + ax * s;
		var r22 = az * az * c1 + c;
		var e00 = this.array[0];
		var e10 = this.array[1];
		var e20 = this.array[2];
		var e30 = this.array[3];
		var e01 = this.array[4];
		var e11 = this.array[5];
		var e21 = this.array[6];
		var e31 = this.array[7];
		var e02 = this.array[8];
		var e12 = this.array[9];
		var e22 = this.array[10];
		var e32 = this.array[11];
		var e03 = this.array[12];
		var e13 = this.array[13];
		var e23 = this.array[14];
		var e33 = this.array[15];
		this.array[0] = e00 * r00 + e01 * r10 + e02 * r20;
		this.array[1] = e10 * r00 + e11 * r10 + e12 * r20;
		this.array[2] = e20 * r00 + e21 * r10 + e22 * r20;
		this.array[3] = e30 * r00 + e31 * r10 + e32 * r20;
		this.array[4] = e00 * r01 + e01 * r11 + e02 * r21;
		this.array[5] = e10 * r01 + e11 * r11 + e12 * r21;
		this.array[6] = e20 * r01 + e21 * r11 + e22 * r21;
		this.array[7] = e30 * r01 + e31 * r11 + e32 * r21;
		this.array[8] = e00 * r02 + e01 * r12 + e02 * r22;
		this.array[9] = e10 * r02 + e11 * r12 + e12 * r22;
		this.array[10] = e20 * r02 + e21 * r12 + e22 * r22;
		this.array[11] = e30 * r02 + e31 * r12 + e32 * r22;
		this.array[12] = e03;
		this.array[13] = e13;
		this.array[14] = e23;
		this.array[15] = e33;
	}
	,mul: function(a,b) {
		var a00 = a.array[0];
		var a10 = a.array[1];
		var a20 = a.array[2];
		var a30 = a.array[3];
		var a01 = a.array[4];
		var a11 = a.array[5];
		var a21 = a.array[6];
		var a31 = a.array[7];
		var a02 = a.array[8];
		var a12 = a.array[9];
		var a22 = a.array[10];
		var a32 = a.array[11];
		var a03 = a.array[12];
		var a13 = a.array[13];
		var a23 = a.array[14];
		var a33 = a.array[15];
		var b00 = b.array[0];
		var b10 = b.array[1];
		var b20 = b.array[2];
		var b30 = b.array[3];
		var b01 = b.array[4];
		var b11 = b.array[5];
		var b21 = b.array[6];
		var b31 = b.array[7];
		var b02 = b.array[8];
		var b12 = b.array[9];
		var b22 = b.array[10];
		var b32 = b.array[11];
		var b03 = b.array[12];
		var b13 = b.array[13];
		var b23 = b.array[14];
		var b33 = b.array[15];
		this.array[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
		this.array[1] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
		this.array[2] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
		this.array[3] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;
		this.array[4] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
		this.array[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
		this.array[6] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
		this.array[7] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;
		this.array[8] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
		this.array[9] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
		this.array[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
		this.array[11] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;
		this.array[12] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
		this.array[13] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
		this.array[14] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
		this.array[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;
	}
	,transpose: function(a) {
		var e01 = a.array[1];
		var e02 = a.array[2];
		var e03 = a.array[3];
		var e10 = a.array[4];
		var e11 = a.array[5];
		var e12 = a.array[6];
		var e13 = a.array[7];
		var e20 = a.array[8];
		var e21 = a.array[9];
		var e22 = a.array[10];
		var e23 = a.array[11];
		var e30 = a.array[12];
		var e31 = a.array[13];
		var e32 = a.array[14];
		var e33 = a.array[15];
		this.array[0] = a.array[0];
		this.array[1] = e10;
		this.array[2] = e20;
		this.array[3] = e30;
		this.array[4] = e01;
		this.array[5] = e11;
		this.array[6] = e21;
		this.array[7] = e31;
		this.array[8] = e02;
		this.array[9] = e12;
		this.array[10] = e22;
		this.array[11] = e32;
		this.array[12] = e03;
		this.array[13] = e13;
		this.array[14] = e23;
		this.array[15] = e33;
	}
	,inverse: function(a) {
		var e00 = a.array[0];
		var e10 = a.array[1];
		var e20 = a.array[2];
		var e30 = a.array[3];
		var e01 = a.array[4];
		var e11 = a.array[5];
		var e21 = a.array[6];
		var e31 = a.array[7];
		var e02 = a.array[8];
		var e12 = a.array[9];
		var e22 = a.array[10];
		var e32 = a.array[11];
		var e03 = a.array[12];
		var e13 = a.array[13];
		var e23 = a.array[14];
		var e33 = a.array[15];
		var d01_01 = e00 * e11 - e01 * e10;
		var d01_02 = e00 * e12 - e02 * e10;
		var d01_03 = e00 * e13 - e03 * e10;
		var d01_12 = e01 * e12 - e02 * e11;
		var d01_13 = e01 * e13 - e03 * e11;
		var d01_23 = e02 * e13 - e03 * e12;
		var d23_01 = e20 * e31 - e21 * e30;
		var d23_02 = e20 * e32 - e22 * e30;
		var d23_03 = e20 * e33 - e23 * e30;
		var d23_12 = e21 * e32 - e22 * e31;
		var d23_13 = e21 * e33 - e23 * e31;
		var d23_23 = e22 * e33 - e23 * e32;
		var d00 = e11 * d23_23 - e12 * d23_13 + e13 * d23_12;
		var d01 = e10 * d23_23 - e12 * d23_03 + e13 * d23_02;
		var d02 = e10 * d23_13 - e11 * d23_03 + e13 * d23_01;
		var d03 = e10 * d23_12 - e11 * d23_02 + e12 * d23_01;
		var d10 = e01 * d23_23 - e02 * d23_13 + e03 * d23_12;
		var d11 = e00 * d23_23 - e02 * d23_03 + e03 * d23_02;
		var d12 = e00 * d23_13 - e01 * d23_03 + e03 * d23_01;
		var d13 = e00 * d23_12 - e01 * d23_02 + e02 * d23_01;
		var d20 = e31 * d01_23 - e32 * d01_13 + e33 * d01_12;
		var d21 = e30 * d01_23 - e32 * d01_03 + e33 * d01_02;
		var d22 = e30 * d01_13 - e31 * d01_03 + e33 * d01_01;
		var d23 = e30 * d01_12 - e31 * d01_02 + e32 * d01_01;
		var d30 = e21 * d01_23 - e22 * d01_13 + e23 * d01_12;
		var d31 = e20 * d01_23 - e22 * d01_03 + e23 * d01_02;
		var d32 = e20 * d01_13 - e21 * d01_03 + e23 * d01_01;
		var d33 = e20 * d01_12 - e21 * d01_02 + e22 * d01_01;
		var invDet = e00 * d00 - e01 * d01 + e02 * d02 - e03 * d03;
		if(invDet != 0) {
			invDet = 1 / invDet;
		}
		this.array[0] = d00 * invDet;
		this.array[1] = -d01 * invDet;
		this.array[2] = d02 * invDet;
		this.array[3] = -d03 * invDet;
		this.array[4] = -d10 * invDet;
		this.array[5] = d11 * invDet;
		this.array[6] = -d12 * invDet;
		this.array[7] = d13 * invDet;
		this.array[8] = d20 * invDet;
		this.array[9] = -d21 * invDet;
		this.array[10] = d22 * invDet;
		this.array[11] = -d23 * invDet;
		this.array[12] = -d30 * invDet;
		this.array[13] = d31 * invDet;
		this.array[14] = -d32 * invDet;
		this.array[15] = d33 * invDet;
	}
	,appendTranslation: function(tx,ty,tz) {
		this.array[12] += this.array[0] * tx + this.array[4] * ty + this.array[8] * tz;
		this.array[13] += this.array[1] * tx + this.array[5] * ty + this.array[9] * tz;
		this.array[14] += this.array[2] * tx + this.array[6] * ty + this.array[10] * tz;
		this.array[15] += this.array[3] * tx + this.array[7] * ty + this.array[11] * tz;
	}
	,toMat3: function() {
		this.array3[0] = this.array[0];
		this.array3[1] = this.array[1];
		this.array3[2] = this.array[2];
		this.array3[3] = this.array[4];
		this.array3[4] = this.array[5];
		this.array3[5] = this.array[6];
		this.array3[6] = this.array[8];
		this.array3[7] = this.array[9];
		this.array3[8] = this.array[10];
	}
};
var pot_graphics__$Graphics_VertexBuffer = function(gl,name,size) {
	this.gl = gl;
	this.name = name;
	this.size = size;
	this.array = new Float32Array(64);
	this.length = 0;
	this.buffer = gl.createBuffer();
};
pot_graphics__$Graphics_VertexBuffer.__name__ = true;
var pot_graphics__$Graphics_IndexBuffer = function(gl) {
	this.gl = gl;
	this.array = new Int16Array(512);
	this.length = 0;
	this.buffer = gl.createBuffer();
};
pot_graphics__$Graphics_IndexBuffer.__name__ = true;
var pot_graphics_Shader = function(gl) {
	this.gl = gl;
	this.pg = gl.createProgram();
	this.vs = gl.createShader(35633);
	this.fs = gl.createShader(35632);
	this.map = null;
	this.vSource = null;
	this.fSource = null;
	this.compiled = false;
	this.uniforms = new haxe_ds_StringMap();
};
pot_graphics_Shader.__name__ = true;
pot_graphics_Shader.prototype = {
	setInt: function(name,x,y,z,w) {
		var _this = this.uniforms;
		var uniform = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
		if(uniform == null) {
			uniform = new pot_graphics__$Shader_Uniform();
		}
		uniform.type = 0;
		uniform.i1 = x;
		if(y != null) {
			uniform.type = 1;
			uniform.i2 = y;
		}
		if(z != null) {
			uniform.type = 2;
			uniform.i3 = z;
		}
		if(w != null) {
			uniform.type = 3;
			uniform.i4 = w;
		}
		var _this1 = this.uniforms;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,uniform);
		} else {
			_this1.h[name] = uniform;
		}
	}
	,setFloat: function(name,x,y,z,w) {
		var _this = this.uniforms;
		var uniform = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
		if(uniform == null) {
			uniform = new pot_graphics__$Shader_Uniform();
		}
		uniform.type = 4;
		uniform.f1 = x;
		if(y != null) {
			uniform.type = 5;
			uniform.f2 = y;
		}
		if(z != null) {
			uniform.type = 6;
			uniform.f3 = z;
		}
		if(w != null) {
			uniform.type = 7;
			uniform.f4 = w;
		}
		var _this1 = this.uniforms;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,uniform);
		} else {
			_this1.h[name] = uniform;
		}
	}
	,setMatrix: function(name,mat) {
		var _this = this.uniforms;
		var uniform = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
		if(uniform == null) {
			uniform = new pot_graphics__$Shader_Uniform();
		}
		var _g = mat.length;
		switch(_g) {
		case 4:
			uniform.type = 8;
			if(uniform.m2 == null) {
				uniform.m2 = new Float32Array(4);
			}
			var _g1 = 0;
			while(_g1 < 4) {
				var i = _g1++;
				uniform.m2[i] = mat[i];
			}
			break;
		case 9:
			uniform.type = 9;
			if(uniform.m3 == null) {
				uniform.m3 = new Float32Array(9);
			}
			var _g2 = 0;
			while(_g2 < 9) {
				var i1 = _g2++;
				uniform.m3[i1] = mat[i1];
			}
			break;
		case 16:
			uniform.type = 10;
			if(uniform.m4 == null) {
				uniform.m4 = new Float32Array(16);
			}
			var _g3 = 0;
			while(_g3 < 16) {
				var i2 = _g3++;
				uniform.m4[i2] = mat[i2];
			}
			break;
		default:
			throw new Error("invalid matrix array length: " + mat.length);
		}
		var _this1 = this.uniforms;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,uniform);
		} else {
			_this1.h[name] = uniform;
		}
	}
	,setTexture: function(name,tex) {
		var _this = this.uniforms;
		var uniform = __map_reserved[name] != null ? _this.getReserved(name) : _this.h[name];
		if(uniform == null) {
			uniform = new pot_graphics__$Shader_Uniform();
		}
		uniform.type = 11;
		uniform.tex = tex;
		var _this1 = this.uniforms;
		if(__map_reserved[name] != null) {
			_this1.setReserved(name,uniform);
		} else {
			_this1.h[name] = uniform;
		}
	}
	,hasUniform: function(name) {
		var tmp;
		var _this = this.map;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			var _this1 = this.map;
			tmp = __map_reserved[name] != null ? _this1.getReserved(name) : _this1.h[name];
		} else {
			var ul = this.gl.getUniformLocation(this.pg,name);
			var _this2 = this.map;
			if(__map_reserved[name] != null) {
				_this2.setReserved(name,ul);
			} else {
				_this2.h[name] = ul;
			}
			tmp = ul;
		}
		return tmp != null;
	}
};
var pot_graphics__$Shader_Uniform = function() {
};
pot_graphics__$Shader_Uniform.__name__ = true;
var pot_graphics_Texture = function(gl) {
	this.gl = gl;
	this.texture = null;
	this.texWrap = 33071;
	this.texFilter = 9729;
	this.texture = gl.createTexture();
	this.frameBuffer = gl.createFramebuffer();
	this.depthBuffer = gl.createRenderbuffer();
};
pot_graphics_Texture.__name__ = true;
pot_graphics_Texture.prototype = {
	init: function(width,height,floating) {
		this.width = width;
		this.height = height;
		this.floating = floating;
		var x = width;
		--x;
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		this.textureWidth = x + 1;
		var x1 = height;
		--x1;
		x1 |= x1 >> 1;
		x1 |= x1 >> 2;
		x1 |= x1 >> 4;
		x1 |= x1 >> 8;
		x1 |= x1 >> 16;
		this.textureHeight = x1 + 1;
		this.imageToU = 1 / this.textureWidth;
		this.imageToV = 1 / this.textureHeight;
		this.normalToU = width / this.textureWidth;
		this.normalToV = height / this.textureHeight;
		this.gl.bindTexture(3553,this.texture);
		this.gl.texImage2D(3553,0,6408,this.textureWidth,this.textureHeight,0,6408,floating ? 5126 : 5121,null);
		this.gl.bindTexture(3553,null);
		if(floating) {
			this.pixelBufferFloat = new Float32Array(this.textureWidth * this.textureHeight * 4);
		} else {
			this.pixelBufferByte = new Uint8Array(this.textureWidth * this.textureHeight * 4);
		}
		var filter = this.texFilter;
		this.texFilter = filter;
		this.gl.bindTexture(3553,this.texture);
		switch(filter) {
		case 9728:
			this.gl.texParameteri(3553,10240,9728);
			this.gl.texParameteri(3553,10241,9728);
			break;
		case 9729:
			this.gl.texParameteri(3553,10240,9729);
			this.gl.texParameteri(3553,10241,9729);
			break;
		}
		this.gl.bindTexture(3553,null);
		var wrap = this.texWrap;
		this.texWrap = wrap;
		this.gl.bindTexture(3553,this.texture);
		this.gl.texParameteri(3553,10242,wrap);
		this.gl.texParameteri(3553,10243,wrap);
		this.gl.bindTexture(3553,null);
		this.initFBO();
	}
	,load: function(image,scalingMode,floating) {
		this.floating = floating;
		var imageWidth = image.width;
		var imageHeight = image.height;
		var x = imageWidth;
		--x;
		x |= x >> 1;
		x |= x >> 2;
		x |= x >> 4;
		x |= x >> 8;
		x |= x >> 16;
		this.textureWidth = x + 1;
		var x1 = imageHeight;
		--x1;
		x1 |= x1 >> 1;
		x1 |= x1 >> 2;
		x1 |= x1 >> 4;
		x1 |= x1 >> 8;
		x1 |= x1 >> 16;
		this.textureHeight = x1 + 1;
		var canvas = window.document.createElement("canvas");
		canvas.width = this.textureWidth;
		canvas.height = this.textureHeight;
		var g = canvas.getContext("2d",null);
		g.transform(1,0,0,-1,0,this.textureHeight);
		switch(scalingMode) {
		case 0:
			g.drawImage(image,0,0,imageWidth,imageHeight,0,0,this.textureWidth,this.textureHeight);
			this.width = this.textureWidth;
			this.height = this.textureHeight;
			this.imageToU = 1 / imageWidth;
			this.imageToV = 1 / imageHeight;
			this.normalToU = 1;
			this.normalToV = 1;
			break;
		case 1:
			g.drawImage(image,0,0,imageWidth,imageHeight,0,0,imageWidth,imageHeight);
			g.drawImage(image,imageWidth - 0.5,0,0.5,imageHeight,imageWidth,0,this.textureWidth - imageWidth,imageHeight);
			g.drawImage(image,0,imageHeight - 0.5,imageWidth,0.5,0,imageHeight,imageWidth,this.textureHeight - imageHeight);
			g.drawImage(image,imageWidth - 0.5,imageHeight - 0.5,0.5,0.5,imageWidth,imageHeight,this.textureWidth - imageWidth,this.textureHeight - imageHeight);
			this.width = this.textureWidth;
			this.height = this.textureHeight;
			this.imageToU = 1 / this.textureWidth;
			this.imageToV = 1 / this.textureHeight;
			this.normalToU = imageWidth / this.textureWidth;
			this.normalToV = imageHeight / this.textureHeight;
			break;
		}
		this.gl.bindTexture(3553,this.texture);
		this.gl.texImage2D(3553,0,6408,6408,floating ? 5126 : 5121,canvas);
		this.gl.bindTexture(3553,null);
		if(floating) {
			this.pixelBufferFloat = new Float32Array(this.textureWidth * this.textureHeight * 4);
		} else {
			this.pixelBufferByte = new Uint8Array(this.textureWidth * this.textureHeight * 4);
		}
		var filter = this.texFilter;
		this.texFilter = filter;
		this.gl.bindTexture(3553,this.texture);
		switch(filter) {
		case 9728:
			this.gl.texParameteri(3553,10240,9728);
			this.gl.texParameteri(3553,10241,9728);
			break;
		case 9729:
			this.gl.texParameteri(3553,10240,9729);
			this.gl.texParameteri(3553,10241,9729);
			break;
		}
		this.gl.bindTexture(3553,null);
		var wrap = this.texWrap;
		this.texWrap = wrap;
		this.gl.bindTexture(3553,this.texture);
		this.gl.texParameteri(3553,10242,wrap);
		this.gl.texParameteri(3553,10243,wrap);
		this.gl.bindTexture(3553,null);
		this.initFBO();
	}
	,uploadPixelsFloat: function(xOffset,yOffset,width,height,pixelsRGBA) {
		if(this.texture == null) {
			throw new js__$Boot_HaxeError("not initialized");
		}
		if(!this.floating) {
			throw new js__$Boot_HaxeError("not floating point texture");
		}
		if(pixelsRGBA.length != width * height * 4) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		var srcIdx = 0;
		var dstIdx = width * (height - 1) * 4;
		var _g1 = 0;
		var _g = height;
		while(_g1 < _g) {
			var i = _g1++;
			var _g3 = 0;
			var _g2 = width;
			while(_g3 < _g2) {
				var j = _g3++;
				this.pixelBufferFloat[dstIdx++] = pixelsRGBA[srcIdx++];
				this.pixelBufferFloat[dstIdx++] = pixelsRGBA[srcIdx++];
				this.pixelBufferFloat[dstIdx++] = pixelsRGBA[srcIdx++];
				this.pixelBufferFloat[dstIdx++] = pixelsRGBA[srcIdx++];
			}
			dstIdx -= width << 3;
		}
		this.gl.bindTexture(3553,this.texture);
		this.gl.texSubImage2D(3553,0,xOffset,this.textureHeight - height - yOffset,width,height,6408,5126,this.pixelBufferFloat);
		this.gl.bindTexture(3553,null);
	}
	,uploadPixelsInt: function(xOffset,yOffset,width,height,pixelsInt32) {
		if(this.texture == null) {
			throw new js__$Boot_HaxeError("not initialized");
		}
		if(this.floating) {
			throw new js__$Boot_HaxeError("not int texture");
		}
		if(pixelsInt32.length != width * height) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		var srcIdx = 0;
		var dstIdx = width * (height - 1) * 4;
		var _g1 = 0;
		var _g = height;
		while(_g1 < _g) {
			var i = _g1++;
			var _g3 = 0;
			var _g2 = width;
			while(_g3 < _g2) {
				var j = _g3++;
				var pix = pixelsInt32[srcIdx++];
				var pixA = pix >>> 24;
				var pixR = pix >>> 16 & 255;
				var pixG = pix >>> 8 & 255;
				var pixB = pix & 255;
				this.pixelBufferByte[dstIdx++] = pixR;
				this.pixelBufferByte[dstIdx++] = pixG;
				this.pixelBufferByte[dstIdx++] = pixB;
				this.pixelBufferByte[dstIdx++] = pixA;
			}
			dstIdx -= width << 3;
		}
		this.gl.bindTexture(3553,this.texture);
		this.gl.texSubImage2D(3553,0,xOffset,this.textureHeight - height - yOffset,width,height,6408,5121,this.pixelBufferByte);
		this.gl.bindTexture(3553,null);
	}
	,initFBO: function() {
		this.gl.bindRenderbuffer(36161,this.depthBuffer);
		this.gl.renderbufferStorage(36161,33189,this.textureWidth,this.textureHeight);
		this.gl.bindRenderbuffer(36161,null);
		this.gl.bindFramebuffer(36160,this.frameBuffer);
		this.gl.framebufferRenderbuffer(36160,36096,36161,this.depthBuffer);
		this.gl.framebufferTexture2D(36160,36064,3553,this.texture,0);
		this.gl.bindFramebuffer(36160,null);
	}
	,filter: function(filter) {
		this.texFilter = filter;
		this.gl.bindTexture(3553,this.texture);
		switch(filter) {
		case 9728:
			this.gl.texParameteri(3553,10240,9728);
			this.gl.texParameteri(3553,10241,9728);
			break;
		case 9729:
			this.gl.texParameteri(3553,10240,9729);
			this.gl.texParameteri(3553,10241,9729);
			break;
		}
		this.gl.bindTexture(3553,null);
	}
	,wrap: function(wrap) {
		this.texWrap = wrap;
		this.gl.bindTexture(3553,this.texture);
		this.gl.texParameteri(3553,10242,wrap);
		this.gl.texParameteri(3553,10243,wrap);
		this.gl.bindTexture(3553,null);
	}
};
var pot_input_Input = function(canvas) {
	this.mouse = new pot_input_Mouse();
	var this1 = new pot_input_TouchesData();
	this.touches = this1;
	var this2 = new pot_input_KeyboardData();
	this.keyboard = this2;
	this.addEvents(canvas);
};
pot_input_Input.__name__ = true;
pot_input_Input.prototype = {
	addEvents: function(canvas) {
		this.mouse.addEvents(canvas,canvas);
		var this1 = this.touches;
		var canvas1 = canvas;
		var elem = canvas;
		elem.addEventListener("touchstart",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			var touches = e.changedTouches;
			var _g1 = 0;
			var _g = touches.length;
			while(_g1 < _g) {
				var i = _g1++;
				var rawTouch = touches[i];
				var rawId = rawTouch.identifier;
				var touch = this1.getByRawId(rawId,true);
				var x = (rawTouch.clientX - elem.getBoundingClientRect().left) * (canvas1.width / canvas1.clientWidth);
				var y = (rawTouch.clientY - elem.getBoundingClientRect().top) * (canvas1.height / canvas1.clientHeight);
				touch.nx = x;
				touch.ny = y;
				touch.ntouching = true;
				touch.ntouching2 = true;
			}
			return;
		});
		elem.addEventListener("touchmove",function(e1) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
			var touches1 = e1.changedTouches;
			var _g11 = 0;
			var _g2 = touches1.length;
			while(_g11 < _g2) {
				var i1 = _g11++;
				var rawTouch1 = touches1[i1];
				var rawId1 = rawTouch1.identifier;
				var touch1 = this1.getByRawId(rawId1);
				if(touch1 != null) {
					var x1 = (rawTouch1.clientX - elem.getBoundingClientRect().left) * (canvas1.width / canvas1.clientWidth);
					var y1 = (rawTouch1.clientY - elem.getBoundingClientRect().top) * (canvas1.height / canvas1.clientHeight);
					touch1.nx = x1;
					touch1.ny = y1;
				}
			}
			return;
		});
		var end = function(e2) {
			if(e2.cancelable) {
				e2.preventDefault();
			}
			var touches2 = e2.changedTouches;
			var _g12 = 0;
			var _g3 = touches2.length;
			while(_g12 < _g3) {
				var i2 = _g12++;
				var rawTouch2 = touches2[i2];
				var rawId2 = rawTouch2.identifier;
				var touch2 = this1.getByRawId(rawId2);
				if(touch2 != null) {
					var x2 = (rawTouch2.clientX - elem.getBoundingClientRect().left) * (canvas1.width / canvas1.clientWidth);
					var y2 = (rawTouch2.clientY - elem.getBoundingClientRect().top) * (canvas1.height / canvas1.clientHeight);
					touch2.nx = x2;
					touch2.ny = y2;
					touch2.ntouching = false;
				}
			}
			return;
		};
		elem.addEventListener("touchend",end);
		elem.addEventListener("touchcancel",end);
		var this2 = this.keyboard;
		var elem1 = window.document.body;
		elem1.addEventListener("keydown",function(e3) {
			var code = e3.keyCode;
			if(code < 112 || code > 135) {
				if(e3.cancelable) {
					e3.preventDefault();
				}
			}
			if(!this2.keys.h.hasOwnProperty(code)) {
				var this3 = this2.keys;
				var value = new pot_input_Key();
				this3.h[code] = value;
			}
			this2.keys.h[code].press();
			return;
		});
		elem1.addEventListener("keyup",function(e4) {
			var code1 = e4.keyCode;
			if(e4.keyCode < 112 || e4.keyCode > 135) {
				if(e4.cancelable) {
					e4.preventDefault();
				}
			}
			if(!this2.keys.h.hasOwnProperty(code1)) {
				var this4 = this2.keys;
				var value1 = new pot_input_Key();
				this4.h[code1] = value1;
			}
			this2.keys.h[code1].release();
			return;
		});
	}
	,update: function() {
		this.mouse.update();
		var this1 = this.touches;
		var i = 0;
		while(i < this1.touches.length) {
			var touch = this1.touches[i];
			if(!touch.ptouching && !touch.touching && !touch.ntouching) {
				HxOverrides.remove(this1.touches,touch);
			} else {
				touch.update();
				++i;
			}
		}
		var i1 = 0;
		var key = this.keyboard.keys.iterator();
		while(key.hasNext()) {
			var key1 = key.next();
			key1.update();
		}
	}
};
var pot_input_InputTools = function() { };
pot_input_InputTools.__name__ = true;
var pot_input_Key = function() {
	this.down = false;
	this.pdown = false;
	this.ndown = false;
	this.ndown2 = false;
	this.ddown = 0;
};
pot_input_Key.__name__ = true;
pot_input_Key.prototype = {
	press: function() {
		this.ndown = true;
		this.ndown2 = true;
	}
	,release: function() {
		this.ndown = false;
	}
	,update: function() {
		this.pdown = this.down;
		this.down = this.ndown || this.ndown2;
		this.ndown2 = false;
		this.ddown = (this.down ? 1 : 0) - (this.pdown ? 1 : 0);
	}
};
var pot_input__$Keyboard_Keyboard_$Impl_$ = {};
pot_input__$Keyboard_Keyboard_$Impl_$.__name__ = true;
pot_input__$Keyboard_Keyboard_$Impl_$._new = function() {
	var this1 = new pot_input_KeyboardData();
	return this1;
};
pot_input__$Keyboard_Keyboard_$Impl_$.get = function(this1,code) {
	if(!this1.keys.h.hasOwnProperty(code)) {
		var this2 = this1.keys;
		var value = new pot_input_Key();
		this2.h[code] = value;
	}
	return this1.keys.h[code];
};
pot_input__$Keyboard_Keyboard_$Impl_$.getNum = function(this1,index) {
	var i = 48 + index;
	if(!this1.keys.h.hasOwnProperty(i)) {
		var this2 = this1.keys;
		var value = new pot_input_Key();
		this2.h[i] = value;
	}
	return this1.keys.h[i];
};
pot_input__$Keyboard_Keyboard_$Impl_$.addEvents = function(this1,canvas,elem) {
	elem.addEventListener("keydown",function(e) {
		var code = e.keyCode;
		if(code < 112 || code > 135) {
			if(e.cancelable) {
				e.preventDefault();
			}
		}
		if(!this1.keys.h.hasOwnProperty(code)) {
			var this2 = this1.keys;
			var value = new pot_input_Key();
			this2.h[code] = value;
		}
		this1.keys.h[code].press();
		return;
	});
	elem.addEventListener("keyup",function(e1) {
		var code1 = e1.keyCode;
		if(e1.keyCode < 112 || e1.keyCode > 135) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
		}
		if(!this1.keys.h.hasOwnProperty(code1)) {
			var this3 = this1.keys;
			var value1 = new pot_input_Key();
			this3.h[code1] = value1;
		}
		this1.keys.h[code1].release();
		return;
	});
};
pot_input__$Keyboard_Keyboard_$Impl_$.update = function(this1) {
	var i = 0;
	var key = this1.keys.iterator();
	while(key.hasNext()) {
		var key1 = key.next();
		key1.update();
	}
};
var pot_input_KeyboardData = function() {
	this.keys = new haxe_ds_IntMap();
};
pot_input_KeyboardData.__name__ = true;
var pot_input_Mouse = function() {
	this.px = 0;
	this.py = 0;
	this.x = 0;
	this.y = 0;
	this.nx = 0;
	this.ny = 0;
	this.dx = 0;
	this.dy = 0;
	this.pleft = false;
	this.pmiddle = false;
	this.pright = false;
	this.left = false;
	this.middle = false;
	this.right = false;
	this.nleft = false;
	this.nmiddle = false;
	this.nright = false;
	this.dleft = 0;
	this.dmiddle = 0;
	this.dright = 0;
};
pot_input_Mouse.__name__ = true;
pot_input_Mouse.prototype = {
	addEvents: function(canvas,elem) {
		var _gthis = this;
		elem.addEventListener("mousedown",function(e) {
			if(e.cancelable) {
				e.preventDefault();
			}
			var _g = e.button;
			switch(_g) {
			case 0:
				_gthis.nleft = true;
				_gthis.nleft2 = true;
				break;
			case 1:
				_gthis.nmiddle = true;
				_gthis.nmiddle2 = true;
				break;
			case 2:
				_gthis.nright = true;
				_gthis.nright2 = true;
				break;
			}
			var tmp = e.clientX - elem.getBoundingClientRect().left;
			_gthis.nx = tmp * (canvas.width / canvas.clientWidth);
			var tmp1 = e.clientY - elem.getBoundingClientRect().top;
			return _gthis.ny = tmp1 * (canvas.height / canvas.clientHeight);
		});
		elem.addEventListener("mouseup",function(e1) {
			if(e1.cancelable) {
				e1.preventDefault();
			}
			var _g1 = e1.button;
			switch(_g1) {
			case 0:
				_gthis.nleft = false;
				break;
			case 1:
				_gthis.nmiddle = false;
				break;
			case 2:
				_gthis.nright = false;
				break;
			}
			var tmp2 = e1.clientX - elem.getBoundingClientRect().left;
			_gthis.nx = tmp2 * (canvas.width / canvas.clientWidth);
			var tmp3 = e1.clientY - elem.getBoundingClientRect().top;
			return _gthis.ny = tmp3 * (canvas.height / canvas.clientHeight);
		});
		elem.addEventListener("mousemove",function(e2) {
			var tmp4 = e2.clientX - elem.getBoundingClientRect().left;
			_gthis.nx = tmp4 * (canvas.width / canvas.clientWidth);
			var tmp5 = e2.clientY - elem.getBoundingClientRect().top;
			return _gthis.ny = tmp5 * (canvas.height / canvas.clientHeight);
		});
		elem.addEventListener("contextmenu",function(e3) {
			e3.preventDefault();
			return;
		});
	}
	,update: function() {
		this.px = this.x;
		this.py = this.y;
		this.x = this.nx;
		this.y = this.ny;
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		this.pleft = this.left;
		this.pmiddle = this.middle;
		this.pright = this.right;
		this.left = this.nleft || this.nleft2;
		this.middle = this.nmiddle || this.nmiddle2;
		this.right = this.nright || this.nright2;
		this.nleft2 = false;
		this.nmiddle2 = false;
		this.nright2 = false;
		this.dleft = (this.left ? 1 : 0) - (this.pleft ? 1 : 0);
		this.dmiddle = (this.middle ? 1 : 0) - (this.pmiddle ? 1 : 0);
		this.dright = (this.right ? 1 : 0) - (this.pright ? 1 : 0);
	}
};
var pot_input_Touch = function() {
	this.px = 0;
	this.py = 0;
	this.x = 0;
	this.y = 0;
	this.nx = 0;
	this.ny = 0;
	this.dx = 0;
	this.dy = 0;
	this.ptouching = false;
	this.touching = false;
	this.ntouching = false;
	this.ntouching2 = false;
	this.dtouching = 0;
	this.rawId = 0;
};
pot_input_Touch.__name__ = true;
pot_input_Touch.prototype = {
	update: function() {
		this.px = this.x;
		this.py = this.y;
		this.x = this.nx;
		this.y = this.ny;
		this.dx = this.x - this.px;
		this.dy = this.y - this.py;
		this.ptouching = this.touching;
		this.touching = this.ntouching || this.ntouching2;
		this.ntouching2 = false;
		this.dtouching = (this.touching ? 1 : 0) - (this.ptouching ? 1 : 0);
	}
};
var pot_input__$Touches_Touches_$Impl_$ = {};
pot_input__$Touches_Touches_$Impl_$.__name__ = true;
pot_input__$Touches_Touches_$Impl_$._new = function() {
	var this1 = new pot_input_TouchesData();
	return this1;
};
pot_input__$Touches_Touches_$Impl_$.get_length = function(this1) {
	return this1.touches.length;
};
pot_input__$Touches_Touches_$Impl_$.get = function(this1,index) {
	return this1.touches[index];
};
pot_input__$Touches_Touches_$Impl_$.addEvents = function(this1,canvas,elem) {
	elem.addEventListener("touchstart",function(e) {
		if(e.cancelable) {
			e.preventDefault();
		}
		var touches = e.changedTouches;
		var _g1 = 0;
		var _g = touches.length;
		while(_g1 < _g) {
			var i = _g1++;
			var rawTouch = touches[i];
			var rawId = rawTouch.identifier;
			var touch = this1.getByRawId(rawId,true);
			var x = (rawTouch.clientX - elem.getBoundingClientRect().left) * (canvas.width / canvas.clientWidth);
			var y = (rawTouch.clientY - elem.getBoundingClientRect().top) * (canvas.height / canvas.clientHeight);
			touch.nx = x;
			touch.ny = y;
			touch.ntouching = true;
			touch.ntouching2 = true;
		}
		return;
	});
	elem.addEventListener("touchmove",function(e1) {
		if(e1.cancelable) {
			e1.preventDefault();
		}
		var touches1 = e1.changedTouches;
		var _g11 = 0;
		var _g2 = touches1.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var rawTouch1 = touches1[i1];
			var rawId1 = rawTouch1.identifier;
			var touch1 = this1.getByRawId(rawId1);
			if(touch1 != null) {
				var x1 = (rawTouch1.clientX - elem.getBoundingClientRect().left) * (canvas.width / canvas.clientWidth);
				var y1 = (rawTouch1.clientY - elem.getBoundingClientRect().top) * (canvas.height / canvas.clientHeight);
				touch1.nx = x1;
				touch1.ny = y1;
			}
		}
		return;
	});
	var end = function(e2) {
		if(e2.cancelable) {
			e2.preventDefault();
		}
		var touches2 = e2.changedTouches;
		var _g12 = 0;
		var _g3 = touches2.length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			var rawTouch2 = touches2[i2];
			var rawId2 = rawTouch2.identifier;
			var touch2 = this1.getByRawId(rawId2);
			if(touch2 != null) {
				var x2 = (rawTouch2.clientX - elem.getBoundingClientRect().left) * (canvas.width / canvas.clientWidth);
				var y2 = (rawTouch2.clientY - elem.getBoundingClientRect().top) * (canvas.height / canvas.clientHeight);
				touch2.nx = x2;
				touch2.ny = y2;
				touch2.ntouching = false;
			}
		}
		return;
	};
	elem.addEventListener("touchend",end);
	elem.addEventListener("touchcancel",end);
};
pot_input__$Touches_Touches_$Impl_$.update = function(this1) {
	var i = 0;
	while(i < this1.touches.length) {
		var touch = this1.touches[i];
		if(!touch.ptouching && !touch.touching && !touch.ntouching) {
			HxOverrides.remove(this1.touches,touch);
		} else {
			touch.update();
			++i;
		}
	}
};
pot_input__$Touches_Touches_$Impl_$.iterator = function(this1) {
	return HxOverrides.iter(this1.touches);
};
var pot_input_TouchesData = function() {
	this.touches = [];
};
pot_input_TouchesData.__name__ = true;
pot_input_TouchesData.prototype = {
	getByRawId: function(rawId,create) {
		if(create == null) {
			create = false;
		}
		var _g = 0;
		var _g1 = this.touches;
		while(_g < _g1.length) {
			var t = _g1[_g];
			++_g;
			if(t.rawId == rawId) {
				return t;
			}
		}
		if(create) {
			return this.newTouch(rawId);
		} else {
			return null;
		}
	}
	,newTouch: function(rawId) {
		var minId = 0;
		while(true) {
			var tmp = minId;
			var _g = 0;
			var _g1 = this.touches;
			while(_g < _g1.length) {
				var t = _g1[_g];
				++_g;
				if(t.id == minId) {
					++minId;
				}
			}
			if(tmp == minId) {
				break;
			}
		}
		var touch = new pot_input_Touch();
		touch.rawId = rawId;
		touch.id = minId;
		this.touches.push(touch);
		return touch;
	}
};
var pot_util_Timer = function(frame) {
	this.frame = frame;
	this.targetSleep = 16.666666666666668;
};
pot_util_Timer.__name__ = true;
pot_util_Timer.prototype = {
	start: function() {
		if(this.running) {
			return;
		}
		this.nextTime = Date.now();
		this.running = true;
		window.setTimeout($bind(this,this.loop),0);
	}
	,stop: function() {
		if(!this.running) {
			return;
		}
		this.running = false;
	}
	,setFrameRate: function(frameRate) {
		this.targetSleep = 1000 / frameRate;
	}
	,loop: function() {
		if(!this.running) {
			return;
		}
		this.frame();
		var currentTime = Date.now();
		this.nextTime += this.targetSleep;
		if(this.nextTime < currentTime + 4) {
			this.nextTime = currentTime + 4;
		}
		var sleep = this.nextTime - currentTime + 0.5 | 0;
		window.setTimeout($bind(this,this.loop),sleep);
	}
	,now: function() {
		return Date.now();
	}
};
var webdl_core_Operation = function(inputs,outputs) {
	this.inputs = inputs.slice(0);
	this.outputs = outputs.slice(0);
	this.edge = new webdl_core_graph_Edge(this);
	this.name = "op";
};
webdl_core_Operation.__name__ = true;
webdl_core_Operation.prototype = {
	run: function() {
	}
	,backwardRun: function() {
		throw new js__$Boot_HaxeError("backward operation is not supported");
	}
	,onAfterRun: function() {
	}
};
var webdl_core_RandUtil = function() { };
webdl_core_RandUtil.__name__ = true;
webdl_core_RandUtil.normal = function(mu,sigma2) {
	if(sigma2 == null) {
		sigma2 = 1;
	}
	if(mu == null) {
		mu = 0;
	}
	return mu + Math.sqrt(-2 * sigma2 * Math.log(Math.random())) * Math.sin(2 * Math.PI * Math.random());
};
webdl_core_RandUtil.uniform = function(min,max) {
	if(max == null) {
		max = 1;
	}
	if(min == null) {
		min = -1;
	}
	return Math.random() * (max - min) + min;
};
webdl_core_RandUtil.normalPdf = function(x,mu,sigma2) {
	return 1 / Math.sqrt(2 * Math.PI * sigma2) * Math.exp(-(x - mu) * (x - mu) / (2 * sigma2));
};
var webdl_core_ShapeInference = function() { };
webdl_core_ShapeInference.__name__ = true;
webdl_core_ShapeInference.inferShapeBinOp = function(a,b) {
	return webdl_core_ShapeInference.broadcast(a,b);
};
webdl_core_ShapeInference.inferShapeMatMul = function(a,b) {
	if(a.length < 2 || b.length < 2) {
		throw new js__$Boot_HaxeError("insufficient ranks");
	}
	if(a.length != b.length) {
		throw new js__$Boot_HaxeError("ranks mismatch");
	}
	var aLast = a.length - 1;
	var bLast = b.length - 1;
	if(a[aLast] != -1 && b[bLast - 1] != -1 && a[aLast] != b[bLast - 1]) {
		throw new js__$Boot_HaxeError("cannot multiply matrices");
	}
	var res = a.slice(0);
	res[aLast - 1] = a[aLast - 1];
	res[bLast] = b[bLast];
	var _g1 = 0;
	var _g = a.length - 2;
	while(_g1 < _g) {
		var i = _g1++;
		res[i] = a[i] == -1 ? b[i] : a[i];
	}
	return res;
};
webdl_core_ShapeInference.inferShapeTensorDot = function(a,b,count,axes) {
	if(count == null) {
		count = -1;
	}
	if(count == -1 && axes == null || count != -1 && axes != null) {
		throw new js__$Boot_HaxeError("specify either count or axes");
	}
	var res = [];
	if(count != -1) {
		if(a.length < count || b.length < count) {
			throw new js__$Boot_HaxeError("insufficient ranks");
		}
		var _g1 = 0;
		var _g = count;
		while(_g1 < _g) {
			var i = _g1++;
			var adummySize = a[a.length - count + i];
			var bdummySize = b[i];
			if(adummySize != -1 && bdummySize != -1 && adummySize != bdummySize) {
				throw new js__$Boot_HaxeError("cannot multiply tensors");
			}
		}
		var _g11 = 0;
		var _g2 = a.length - count;
		while(_g11 < _g2) {
			var i1 = _g11++;
			res.push(a[i1]);
		}
		var _g12 = count;
		var _g3 = b.length;
		while(_g12 < _g3) {
			var i2 = _g12++;
			res.push(b[i2]);
		}
	} else {
		if(axes.length != 2) {
			throw new js__$Boot_HaxeError("invalid argument");
		}
		if(axes[0].length != axes[1].length) {
			throw new js__$Boot_HaxeError("invalid axes");
		}
		var _g13 = 0;
		var _g4 = axes[0].length;
		while(_g13 < _g4) {
			var i3 = _g13++;
			var adummyAxis = axes[0][i3];
			var bdummyAxis = axes[1][i3];
			if(adummyAxis < 0 || adummyAxis >= a.length) {
				throw new js__$Boot_HaxeError("invalid axes");
			}
			if(bdummyAxis < 0 || bdummyAxis >= b.length) {
				throw new js__$Boot_HaxeError("invalid axes");
			}
			var adummySize1 = a[adummyAxis];
			var bdummySize1 = b[bdummyAxis];
			if(adummySize1 != -1 && bdummySize1 != -1 && adummySize1 != bdummySize1) {
				throw new js__$Boot_HaxeError("cannot multiply tensors");
			}
		}
		var _g14 = 0;
		var _g5 = a.length;
		while(_g14 < _g5) {
			var i4 = _g14++;
			if(axes[0].indexOf(i4) == -1) {
				res.push(a[i4]);
			}
		}
		var _g15 = 0;
		var _g6 = b.length;
		while(_g15 < _g6) {
			var i5 = _g15++;
			if(axes[1].indexOf(i5) == -1) {
				res.push(b[i5]);
			}
		}
	}
	return res;
};
webdl_core_ShapeInference.inferShapeReduce = function(a,axis,keepDim) {
	if(axis < 0 || axis >= a.length) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var res;
	if(keepDim) {
		res = a.slice(0);
		res[axis] = 1;
		return res;
	}
	res = [];
	var _g1 = 0;
	var _g = a.length;
	while(_g1 < _g) {
		var i = _g1++;
		if(i != axis) {
			res.push(a[i]);
		}
	}
	return res;
};
webdl_core_ShapeInference.inferShapesSplit = function(a,axis,sizes) {
	if(axis < 0 || axis >= a.length) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var res = [];
	var sizeSum = 0;
	var _g = 0;
	while(_g < sizes.length) {
		var size = sizes[_g];
		++_g;
		var shape = a.slice(0);
		shape[axis] = size;
		res.push(shape);
		sizeSum += size;
	}
	if(sizeSum != a[axis]) {
		throw new js__$Boot_HaxeError("invalid sizes: sum of the split sizes " + sizeSum + " should equal to the dimension size along the splitting axis " + a[axis]);
	}
	return res;
};
webdl_core_ShapeInference.inferShapeMerge = function(as,axis) {
	if(axis < 0 || axis >= as[0].length) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var res = as[0].slice(0);
	var totalSize = 0;
	var _g = 0;
	while(_g < as.length) {
		var a = as[_g];
		++_g;
		if(a[axis] == -1) {
			totalSize = -1;
			break;
		}
		totalSize += a[axis];
	}
	res[axis] = totalSize;
	return res;
};
webdl_core_ShapeInference.broadcast = function(a,b,aActual,bActual) {
	if(aActual == null != (bActual == null)) {
		throw new js__$Boot_HaxeError("invalid argument");
	}
	if(aActual != null && bActual != null) {
		if(aActual.length == 0) {
			return b.slice(0);
		}
		if(bActual.length == 0) {
			return a.slice(0);
		}
		if(aActual.length != bActual.length) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		var res = [];
		var _g1 = 0;
		var _g = a.length;
		while(_g1 < _g) {
			var i = _g1++;
			var ai = a[i];
			var bi = b[i];
			var aiActual = aActual[i];
			var biActual = bActual[i];
			if(ai == 1) {
				if(bi == 1) {
					res.push(1);
				} else {
					res.push(biActual);
				}
			} else if(bi == 1) {
				res.push(aiActual);
			} else if(aiActual == biActual) {
				res.push(aiActual);
			} else if(aiActual == 1 || biActual == 1) {
				throw new js__$Boot_HaxeError("shapes mismatch; cannot broadcast along an unspecified dimension");
			} else {
				throw new js__$Boot_HaxeError("shapes mismatch");
			}
		}
		return res;
	} else {
		if(a.length == 0) {
			return b.slice(0);
		}
		if(b.length == 0) {
			return a.slice(0);
		}
		if(a.length != b.length) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		var res1 = [];
		var _g11 = 0;
		var _g2 = a.length;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var ai1 = a[i1];
			var bi1 = b[i1];
			switch(ai1) {
			case -1:
				switch(bi1) {
				case -1:
					var n = bi1;
					res1.push(n);
					break;
				case 1:
					res1.push(-1);
					break;
				default:
					var n1 = bi1;
					res1.push(n1);
				}
				break;
			case 1:
				switch(bi1) {
				case -1:
					res1.push(-1);
					break;
				case 1:
					var n2 = bi1;
					res1.push(n2);
					break;
				default:
					var n3 = bi1;
					res1.push(n3);
				}
				break;
			default:
				switch(bi1) {
				case -1:case 1:
					var n4 = ai1;
					res1.push(n4);
					break;
				default:
					if(ai1 == bi1) {
						res1.push(ai1);
					} else {
						throw new js__$Boot_HaxeError("shapes mismatch");
					}
				}
			}
		}
		return res1;
	}
};
webdl_core_ShapeInference.getBroadcastedAxes = function(dst,a) {
	if(a.length == 0) {
		var _g = [];
		var _g2 = 0;
		var _g1 = dst.length;
		while(_g2 < _g1) {
			var i = _g2++;
			if(dst[i] != 1) {
				_g.push(i);
			}
		}
		return _g;
	}
	var res = [];
	var _g11 = 0;
	var _g3 = a.length;
	while(_g11 < _g3) {
		var i1 = _g11++;
		if(dst[i1] != 1 && a[i1] == 1) {
			res.push(i1);
		}
	}
	return res;
};
var webdl_core_Tensor = function(backend,shape) {
	this.backend = backend;
	this.shape = shape.slice(0);
	this.rank = shape.length;
	if(this.rank > 4) {
		throw new js__$Boot_HaxeError("rank too high");
	}
	this.size = 1;
	var _g1 = 0;
	var _g = this.rank;
	while(_g1 < _g) {
		var i = _g1++;
		if(shape[i] == -1) {
			this.size = -1;
			break;
		}
		this.size *= shape[i];
	}
	this.actualSize = this.size;
	var this1 = this.shape;
	var this2 = new Array(this1.length);
	var r = this2;
	haxe_ds__$Vector_Vector_$Impl_$.blit(this1,0,r,0,this1.length);
	this.actualShape = r;
	if(this.size != -1) {
		this.data = backend.requestTensorData(this.size);
		this.data.clearValue(0);
		this.data.clearDiff(0);
	}
	this.node = new webdl_core_graph_Node(this);
	this.trainable = false;
	this.shouldBeSaved = false;
	this.doNotDecay = false;
};
webdl_core_Tensor.__name__ = true;
webdl_core_Tensor.prototype = {
	set: function(value) {
		var _g = this.rank;
		switch(_g) {
		case 0:
			this.set0D(value);
			return;
		case 1:
			this.set1D(value);
			return;
		case 2:
			this.set2D(value);
			return;
		case 3:
			this.set3D(value);
			return;
		default:
			this.set4D(value);
			return;
		}
	}
	,set0D: function(value) {
		if(this.rank != 0) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		this.assignShape([]);
		this.data.setValue([value]);
	}
	,set1D: function(value) {
		if(this.rank != 1) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		this.assignShape([value.length]);
		this.sizeCheck();
		this.data.setValue(value);
	}
	,set2D: function(value) {
		if(this.rank != 2) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		this.assignShape([value.length,value[0].length]);
		this.data.setValue(this.flatten(value));
	}
	,set3D: function(value) {
		if(this.rank != 3) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		this.assignShape([value.length,value[0].length,value[0][0].length]);
		this.data.setValue(this.flatten(this.flatten(value)));
	}
	,set4D: function(value) {
		if(this.rank != 4) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		this.assignShape([value.length,value[0].length,value[0][0].length,value[0][0][0].length]);
		this.data.setValue(this.flatten(this.flatten(this.flatten(value))));
	}
	,setArray: function(array) {
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("cannot assign flattened data to a tensor of ambiguous shape");
		}
		if(this.actualSize != array.length) {
			throw new js__$Boot_HaxeError("data sizes mismatch");
		}
		this.data.setValue(array);
	}
	,fill: function(value) {
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("cannot fill a tensor of ambiguous shape");
		}
		this.data.clearValue(value);
	}
	,fillByGenerator: function(valueGen) {
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("cannot fill a tensor of ambiguous shape");
		}
		var tmp = this.data;
		var _g = [];
		var _g2 = 0;
		var _g1 = this.actualSize;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push(valueGen());
		}
		tmp.setValue(_g);
	}
	,fillDiff: function(diff) {
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("cannot fill a tensor of ambiguous shape");
		}
		this.data.clearDiff(diff);
	}
	,get: function() {
		var _g = this.rank;
		switch(_g) {
		case 0:
			return this.get0D();
		case 1:
			return this.get1D();
		case 2:
			return this.get2D();
		case 3:
			return this.get3D();
		default:
			return this.get4D();
		}
	}
	,get0D: function() {
		if(this.rank != 0) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.reshape0D(this.data.getValue(this.actualSize));
	}
	,get1D: function() {
		if(this.rank != 1) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.reshape1D(this.data.getValue(this.actualSize));
	}
	,get2D: function() {
		if(this.rank != 2) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.reshape2D(this.data.getValue(this.actualSize));
	}
	,get3D: function() {
		if(this.rank != 3) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.reshape3D(this.data.getValue(this.actualSize));
	}
	,get4D: function() {
		if(this.rank != 4) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.reshape4D(this.data.getValue(this.actualSize));
	}
	,getArray: function() {
		if(this.actualSize == -1) {
			throw new js__$Boot_HaxeError("no data assigned");
		}
		return this.data.getValue(this.actualSize);
	}
	,print: function() {
		var _g = this.rank;
		switch(_g) {
		case 0:
			var v = this.get0D();
			return "" + v;
		case 1:
			var v1 = this.get1D();
			return "[" + v1.join(", ") + "]";
		case 2:
			var v2 = this.get2D();
			return "[\n" + v2.map(function(a) {
				return "  [" + a.join(", ") + "]";
			}).join(",\n") + "\n]";
		case 3:
			var v3 = this.get3D();
			return "[\n" + v3.map(function(b) {
				return "  [\n" + b.map(function(a1) {
					return "    [" + a1.join(", ") + "]";
				}).join(",\n") + "\n  ]";
			}).join(",\n") + "\n]";
		default:
			var v4 = this.get4D();
			return "[\n" + v4.map(function(c) {
				return "  [\n" + c.map(function(b1) {
					return "    [\n" + b1.map(function(a2) {
						return "      [" + a2.join(", ") + "]";
					}).join(",\n") + "\n    ]";
				}).join(",\n") + "\n  ]";
			}).join(",\n") + "\n]";
		}
	}
	,printDiff: function() {
		var _g = this.rank;
		switch(_g) {
		case 0:
			var v = this.reshape0D(this.data.getDiff(this.actualSize));
			return "" + v;
		case 1:
			var v1 = this.reshape1D(this.data.getDiff(this.actualSize));
			return "[" + v1.join(", ") + "]";
		case 2:
			var v2 = this.reshape2D(this.data.getDiff(this.actualSize));
			return "[\n" + v2.map(function(a) {
				return "  [" + a.join(", ") + "]";
			}).join(",\n") + "\n]";
		case 3:
			var v3 = this.reshape3D(this.data.getDiff(this.actualSize));
			return "[\n" + v3.map(function(b) {
				return "  [\n" + b.map(function(a1) {
					return "    [" + a1.join(", ") + "]";
				}).join(",\n") + "\n  ]";
			}).join(",\n") + "\n]";
		default:
			var v4 = this.reshape4D(this.data.getDiff(this.actualSize));
			return "[\n" + v4.map(function(c) {
				return "  [\n" + c.map(function(b1) {
					return "    [\n" + b1.map(function(a2) {
						return "      [" + a2.join(", ") + "]";
					}).join(",\n") + "\n    ]";
				}).join(",\n") + "\n  ]";
			}).join(",\n") + "\n]";
		}
	}
	,assignShape: function(rhs) {
		if(this.rank != rhs.length) {
			throw new js__$Boot_HaxeError("ranks mismatch");
		}
		var _g1 = 0;
		var _g = this.rank;
		while(_g1 < _g) {
			var i = _g1++;
			if(this.shape[i] != -1 && this.shape[i] != rhs[i]) {
				throw new js__$Boot_HaxeError("dimension size mismatch");
			}
			if(rhs[i] == -1) {
				throw new js__$Boot_HaxeError("no data assigned");
			}
			this.actualShape[i] = rhs[i];
		}
		this.sizeCheck();
	}
	,sizeCheck: function() {
		this.actualSize = 1;
		var _g = 0;
		var _g1 = this.actualShape;
		while(_g < _g1.length) {
			var s = _g1[_g];
			++_g;
			this.actualSize *= s;
		}
		if(this.data == null || !this.data.isPreferableSize(this.actualSize)) {
			if(this.data != null) {
				this.backend.disposeTensorData(this.data);
			}
			this.data = this.backend.requestTensorData(this.actualSize);
		}
	}
	,flatten: function(array) {
		var flattened = [];
		var _g = 0;
		while(_g < array.length) {
			var a = array[_g];
			++_g;
			if(a.length != array[0].length) {
				throw new js__$Boot_HaxeError("inconsistent array size");
			}
			var _g1 = 0;
			while(_g1 < a.length) {
				var b = a[_g1];
				++_g1;
				flattened.push(b);
			}
		}
		return flattened;
	}
	,reshape0D: function(value) {
		if(this.rank != 0) {
			throw new js__$Boot_HaxeError("!?");
		}
		if(this.actualSize != value.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		return value[0];
	}
	,reshape1D: function(value) {
		if(this.rank != 1) {
			throw new js__$Boot_HaxeError("!?");
		}
		if(this.actualSize != value.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		return value.slice();
	}
	,reshape2D: function(value) {
		if(this.rank != 2) {
			throw new js__$Boot_HaxeError("!?");
		}
		if(this.actualSize != value.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		var idx = 0;
		var _g = [];
		var _g2 = 0;
		var _g1 = this.actualShape[0];
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.actualShape[1];
			while(_g5 < _g4) {
				var j = _g5++;
				_g3.push(value[idx++]);
			}
			_g.push(_g3);
		}
		return _g;
	}
	,reshape3D: function(value) {
		if(this.rank != 3) {
			throw new js__$Boot_HaxeError("!?");
		}
		if(this.actualSize != value.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		var idx = 0;
		var _g = [];
		var _g2 = 0;
		var _g1 = this.actualShape[0];
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.actualShape[1];
			while(_g5 < _g4) {
				var j = _g5++;
				var _g6 = [];
				var _g8 = 0;
				var _g7 = this.actualShape[2];
				while(_g8 < _g7) {
					var k = _g8++;
					_g6.push(value[idx++]);
				}
				_g3.push(_g6);
			}
			_g.push(_g3);
		}
		return _g;
	}
	,reshape4D: function(value) {
		if(this.rank != 4) {
			throw new js__$Boot_HaxeError("!?");
		}
		if(this.actualSize != value.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		var idx = 0;
		var _g = [];
		var _g2 = 0;
		var _g1 = this.actualShape[0];
		while(_g2 < _g1) {
			var i = _g2++;
			var _g3 = [];
			var _g5 = 0;
			var _g4 = this.actualShape[1];
			while(_g5 < _g4) {
				var j = _g5++;
				var _g6 = [];
				var _g8 = 0;
				var _g7 = this.actualShape[2];
				while(_g8 < _g7) {
					var k = _g8++;
					var _g9 = [];
					var _g11 = 0;
					var _g10 = this.actualShape[3];
					while(_g11 < _g10) {
						var l = _g11++;
						_g9.push(value[idx++]);
					}
					_g6.push(_g9);
				}
				_g3.push(_g6);
			}
			_g.push(_g3);
		}
		return _g;
	}
};
var webdl_core_TensorData = function() { };
webdl_core_TensorData.__name__ = true;
var webdl_core_WebDL = function() { };
webdl_core_WebDL.__name__ = true;
webdl_core_WebDL.setBackend = function(backend) {
	var _g = backend.toLowerCase();
	var tmp;
	switch(_g) {
	case "cpu":
		tmp = null;
		break;
	case "gpu":
		tmp = new webdl_core_backend_gpu_GpuBackend();
		break;
	default:
		throw new js__$Boot_HaxeError("invalid backend: " + backend);
	}
	webdl_core_WebDL.backend = tmp;
};
webdl_core_WebDL.tensorOfShape = function(shape) {
	var _g = 0;
	while(_g < shape.length) {
		var dimSize = shape[_g];
		++_g;
		if(dimSize != -1 && dimSize <= 0) {
			throw new js__$Boot_HaxeError("all the dimension size must be positive");
		}
	}
	return new webdl_core_Tensor(webdl_core_WebDL.backend,shape);
};
webdl_core_WebDL.tensorOfRank = function(rank) {
	if(rank < 0) {
		throw new js__$Boot_HaxeError("invalid rank");
	}
	var tmp = webdl_core_WebDL.backend;
	var _g = [];
	var _g2 = 0;
	var _g1 = rank;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(-1);
	}
	return new webdl_core_Tensor(tmp,_g);
};
webdl_core_WebDL.tensorOfValue = function(value) {
	if(typeof(value) == "number") {
		var res = webdl_core_WebDL.tensorOfRank(0);
		res.set0D(value);
		return res;
	} else if((value instanceof Array) && value.__enum__ == null) {
		var value1D = value;
		if((value1D[0] instanceof Array) && value1D[0].__enum__ == null) {
			var value2D = value;
			if((value2D[0][0] instanceof Array) && value2D[0][0].__enum__ == null) {
				var value3D = value;
				if((value3D[0][0][0] instanceof Array) && value3D[0][0][0].__enum__ == null) {
					var value4D = value;
					var res1 = webdl_core_WebDL.tensorOfShape([value4D.length,value4D[0].length,value4D[0][0].length,value4D[0][0][0].length]);
					res1.set4D(value4D);
					return res1;
				}
				var res2 = webdl_core_WebDL.tensorOfShape([value3D.length,value3D[0].length,value3D[0][0].length]);
				res2.set3D(value3D);
				return res2;
			}
			var res3 = webdl_core_WebDL.tensorOfShape([value2D.length,value2D[0].length]);
			res3.set2D(value2D);
			return res3;
		}
		var res4 = webdl_core_WebDL.tensorOfShape([value1D.length]);
		res4.set1D(value1D);
		return res4;
	}
	throw new js__$Boot_HaxeError("invalid value");
};
webdl_core_WebDL.tensorLike = function(t) {
	return webdl_core_WebDL.tensorOfShape(t.shape.slice(0));
};
webdl_core_WebDL.add = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.add(a,b,res);
	return res;
};
webdl_core_WebDL.addConst = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.addConst(a,b,res);
	return res;
};
webdl_core_WebDL.sub = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.sub(a,b,res);
	return res;
};
webdl_core_WebDL.subConst = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.addConst(a,-b,res);
	return res;
};
webdl_core_WebDL.linComb = function(a,b,aScale,bScale) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.linComb(a,b,res,aScale,bScale);
	return res;
};
webdl_core_WebDL.mul = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.mul(a,b,res);
	return res;
};
webdl_core_WebDL.mulConst = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.mulConst(a,b,res);
	return res;
};
webdl_core_WebDL.div = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.div(a,b,res);
	return res;
};
webdl_core_WebDL.divConst = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.mulConst(a,1 / b,res);
	return res;
};
webdl_core_WebDL.pow = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeBinOp(a.shape,b.shape));
	webdl_core_WebDL.backend.pow(a,b,res);
	return res;
};
webdl_core_WebDL.powConst = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.powConst(a,b,res);
	return res;
};
webdl_core_WebDL.matMul = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeMatMul(a.shape,b.shape));
	webdl_core_WebDL.backend.matMul(a,b,res);
	return res;
};
webdl_core_WebDL.tensorDot = function(a,b,count,axes) {
	if(count == null) {
		count = -1;
	}
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeTensorDot(a.shape,b.shape,count,axes));
	webdl_core_WebDL.backend.tensorDot(a,b,res,count,axes);
	return res;
};
webdl_core_WebDL.abs = function(a) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.abs(a,res);
	return res;
};
webdl_core_WebDL.log = function(a) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.log(a,res);
	return res;
};
webdl_core_WebDL.square = function(a) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.mul(a,a,res);
	return res;
};
webdl_core_WebDL.exp = function(a) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.exp(a,res);
	return res;
};
webdl_core_WebDL.activation = function(a,activation) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.activation(a,res,activation);
	return res;
};
webdl_core_WebDL.biasAdd = function(a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.biasAdd(a,b,res);
	return res;
};
webdl_core_WebDL.reduceSum = function(a,axis,keepDim) {
	if(keepDim == null) {
		keepDim = false;
	}
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeReduce(a.shape,axis,keepDim));
	webdl_core_WebDL.backend.reduceSum(a,res,axis,keepDim);
	return res;
};
webdl_core_WebDL.reduceMean = function(a,axis,keepDim) {
	if(keepDim == null) {
		keepDim = false;
	}
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeReduce(a.shape,axis,keepDim));
	webdl_core_WebDL.backend.reduceMean(a,res,axis,keepDim);
	return res;
};
webdl_core_WebDL.split = function(a,axis,sizes) {
	var shapes = webdl_core_ShapeInference.inferShapesSplit(a.shape,axis,sizes);
	var res = [];
	var _g = 0;
	while(_g < shapes.length) {
		var shape = shapes[_g];
		++_g;
		res.push(new webdl_core_Tensor(webdl_core_WebDL.backend,shape));
	}
	webdl_core_WebDL.backend.split(a,res,axis,sizes);
	return res;
};
webdl_core_WebDL.merge = function(as,axis) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,webdl_core_ShapeInference.inferShapeMerge(as.map(function(t) {
		return t.shape;
	}),axis));
	webdl_core_WebDL.backend.merge(as,res,axis);
	return res;
};
webdl_core_WebDL.gradients = function(y,xs,gradY) {
	var _g = [];
	var _g1 = 0;
	while(_g1 < xs.length) {
		var x = xs[_g1];
		++_g1;
		_g.push(new webdl_core_Tensor(webdl_core_WebDL.backend,x.shape.slice(0)));
	}
	var res = _g;
	webdl_core_WebDL.backend.gradients(y,xs,res,gradY);
	return res;
};
webdl_core_WebDL.assign = function(dst,src) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,src.shape.slice(0));
	webdl_core_WebDL.backend.assign(src,res,dst);
	return res;
};
webdl_core_WebDL.where = function(cond,a,b) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,a.shape.slice(0));
	webdl_core_WebDL.backend.where(cond,a,b,res);
	return res;
};
webdl_core_WebDL.adamUpdate = function(count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay) {
	var res = new webdl_core_Tensor(webdl_core_WebDL.backend,[]);
	webdl_core_WebDL.backend.adamUpdate(count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay,res);
	return res;
};
webdl_core_WebDL.getTrainableVariables = function(references) {
	return webdl_core_graph_Graph.collectNodesConcerned(references.map(function(t) {
		return t.node;
	})).filter(function(n) {
		return n.tensor.trainable;
	}).map(function(n1) {
		return n1.tensor;
	});
};
webdl_core_WebDL.getTensorsToSave = function(references) {
	return webdl_core_graph_Graph.collectNodesConcerned(references.map(function(t) {
		return t.node;
	})).filter(function(n) {
		return n.tensor.shouldBeSaved;
	}).map(function(n1) {
		return n1.tensor;
	});
};
webdl_core_WebDL.run = function(tensors) {
	webdl_core_graph_Graph.run(tensors.map(function(t) {
		return t.node;
	}));
};
webdl_core_WebDL.exportElements = function(tensors) {
	var res = [];
	var _g = 0;
	while(_g < tensors.length) {
		var t = tensors[_g];
		++_g;
		res = res.concat(t.getArray());
	}
	return res;
};
webdl_core_WebDL.importElements = function(tensors,data) {
	var copy = data.slice();
	var _g = 0;
	while(_g < tensors.length) {
		var t = tensors[_g];
		++_g;
		if(copy.length < t.actualSize) {
			throw new js__$Boot_HaxeError("data size too small");
		}
		if(t.actualSize == -1) {
			throw new js__$Boot_HaxeError("tensor size unspecified");
		}
		t.setArray(copy.splice(0,t.actualSize));
	}
	if(copy.length > 0) {
		throw new js__$Boot_HaxeError("data size too large");
	}
};
var webdl_core_backend_Backend = function() { };
webdl_core_backend_Backend.__name__ = true;
var webdl_core_backend_gpu_GpuArray = function(gl,texSize) {
	this.gl = gl;
	this.texSize = texSize;
	this.maxSize = texSize * texSize;
	this.dataLength = texSize * texSize * 4;
	this.data = new Float32Array(this.dataLength);
	var _g1 = 0;
	var _g = this.dataLength;
	while(_g1 < _g) {
		var i = _g1++;
		this.data[i] = 0;
	}
	this.tex = gl.createTexture();
	gl.bindTexture(3553,this.tex);
	gl.texImage2D(3553,0,6408,texSize,texSize,0,6408,5126,this.data);
	gl.texParameteri(3553,10240,9728);
	gl.texParameteri(3553,10241,9728);
	gl.texParameteri(3553,10242,10497);
	gl.texParameteri(3553,10243,10497);
	gl.bindTexture(3553,null);
	this.dbuf = gl.createRenderbuffer();
	gl.bindRenderbuffer(36161,this.dbuf);
	gl.renderbufferStorage(36161,33189,texSize,texSize);
	gl.bindRenderbuffer(36161,null);
	this.fbuf = gl.createFramebuffer();
	gl.bindFramebuffer(36160,this.fbuf);
	gl.framebufferRenderbuffer(36160,36096,36161,this.dbuf);
	gl.framebufferTexture2D(36160,36064,3553,this.tex,0);
	gl.bindFramebuffer(36160,null);
};
webdl_core_backend_gpu_GpuArray.__name__ = true;
webdl_core_backend_gpu_GpuArray.prototype = {
	downloadPixels: function() {
		this.gl.bindFramebuffer(36160,this.fbuf);
		this.gl.readPixels(0,0,this.texSize,this.texSize,6408,5126,this.data);
		this.gl.bindFramebuffer(36160,null);
	}
	,uploadPixels: function() {
		this.gl.bindTexture(3553,this.tex);
		this.gl.texImage2D(3553,0,6408,this.texSize,this.texSize,0,6408,5126,this.data);
		this.gl.bindTexture(3553,null);
	}
	,setAsDst: function() {
		this.gl.bindFramebuffer(36160,this.fbuf);
		this.gl.viewport(0,0,this.texSize,this.texSize);
	}
	,setAsSrc: function(unif,unit) {
		this.gl.activeTexture(33984 + unit);
		this.gl.bindTexture(3553,this.tex);
		this.gl.activeTexture(33984);
		this.gl.uniform1i(unif,unit);
	}
};
var webdl_core_backend_gpu_GpuAtomicOperation = function(inputs,output,name,shader) {
	this.inputs = inputs;
	this.output = output;
	this.name = name;
	this.shader = shader;
};
webdl_core_backend_gpu_GpuAtomicOperation.__name__ = true;
webdl_core_backend_gpu_GpuAtomicOperation.prototype = {
	bindUniforms: function() {
		this.shader.setDst(this.output);
		var _g1 = 0;
		var _g = this.inputs.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.shader.setSrc(this.inputs[i],i);
		}
	}
	,preDraw: function() {
	}
	,postDraw: function() {
		var outputData = this.output.data;
		outputData.flip();
	}
};
var webdl_core_backend_gpu_GpuBackend = function() {
	var canvas = window.document.createElement("canvas");
	this.gl = js_html__$CanvasElement_CanvasUtil.getContextWebGL(canvas,null);
	this.gl.getExtension("OES_texture_float");
	this.gl.getExtension("OES_texture_float_linear");
	this.gl.getExtension("WEBGL_color_buffer_float");
	this.vbuf = this.gl.createBuffer();
	this.ibuf = this.gl.createBuffer();
	this.gl.bindBuffer(34962,this.vbuf);
	this.gl.bufferData(34962,new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),35044);
	this.gl.bindBuffer(34962,null);
	this.gl.bindBuffer(34963,this.ibuf);
	this.gl.bufferData(34963,new Int16Array([0,1,2,0,2,3]),35044);
	this.gl.bindBuffer(34963,null);
	this.disposedData = [];
};
webdl_core_backend_gpu_GpuBackend.__name__ = true;
webdl_core_backend_gpu_GpuBackend.__interfaces__ = [webdl_core_backend_Backend];
webdl_core_backend_gpu_GpuBackend.prototype = {
	runAtomicOperation: function(op) {
		op.preDraw();
		var program = op.shader.program;
		this.gl.useProgram(program);
		var posAttrib = this.gl.getAttribLocation(program,"aPos");
		var uvAttrib = this.gl.getAttribLocation(program,"aUv");
		this.gl.bindBuffer(34962,this.vbuf);
		this.gl.enableVertexAttribArray(posAttrib);
		this.gl.vertexAttribPointer(posAttrib,2,5126,false,16,0);
		this.gl.enableVertexAttribArray(uvAttrib);
		this.gl.vertexAttribPointer(uvAttrib,2,5126,false,16,8);
		this.gl.bindBuffer(34962,null);
		op.bindUniforms();
		this.gl.bindBuffer(34963,this.ibuf);
		this.gl.drawElements(4,6,5123,0);
		this.gl.bindBuffer(34963,null);
		this.gl.disableVertexAttribArray(posAttrib);
		this.gl.disableVertexAttribArray(uvAttrib);
		op.postDraw();
	}
	,requestTensorData: function(size) {
		var _g = 0;
		var _g1 = this.disposedData;
		while(_g < _g1.length) {
			var d = _g1[_g];
			++_g;
			if(d.isPreferableSize(size)) {
				HxOverrides.remove(this.disposedData,d);
				return d;
			}
		}
		return new webdl_core_backend_gpu_GpuTensorData(this.gl,size);
	}
	,disposeTensorData: function(data) {
		if(!(data instanceof webdl_core_backend_gpu_GpuTensorData)) {
			throw new js__$Boot_HaxeError("backends mismatch");
		}
		this.disposedData.push(data);
	}
	,add: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuAddOperation(this,a,b,dst);
	}
	,addConst: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuAddConstOperation(this,a,b,dst);
	}
	,sub: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuSubOperation(this,a,b,dst);
	}
	,linComb: function(a,b,dst,aScale,bScale) {
		return new webdl_core_backend_gpu_operation_GpuLinCombOperation(this,a,b,dst,aScale,bScale);
	}
	,mul: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuMulOperation(this,a,b,dst);
	}
	,mulConst: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuMulConstOperation(this,a,b,dst);
	}
	,div: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuDivOperation(this,a,b,dst);
	}
	,pow: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuPowOperation(this,a,b,dst);
	}
	,powConst: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuPowConstOperation(this,a,b,dst);
	}
	,matMul: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuMatMulOperation(this,a,b,dst);
	}
	,tensorDot: function(a,b,dst,count,axes) {
		return new webdl_core_backend_gpu_operation_GpuTensorDotOperation(this,a,b,dst,count,axes);
	}
	,abs: function(a,dst) {
		return new webdl_core_backend_gpu_operation_GpuAbsOperation(this,a,dst);
	}
	,log: function(a,dst) {
		return new webdl_core_backend_gpu_operation_GpuLogOperation(this,a,dst);
	}
	,exp: function(a,dst) {
		return new webdl_core_backend_gpu_operation_GpuExpOperation(this,a,dst);
	}
	,biasAdd: function(a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuBiasAddOperation(this,a,b,dst);
	}
	,activation: function(a,dst,activation) {
		return new webdl_core_backend_gpu_operation_GpuActivationOperation(this,a,dst,activation);
	}
	,reduceSum: function(a,dst,axis,keepDim) {
		return new webdl_core_backend_gpu_operation_GpuReduceSumOperation(this,a,dst,axis,keepDim);
	}
	,reduceMean: function(a,dst,axis,keepDim) {
		return new webdl_core_backend_gpu_operation_GpuReduceMeanOperation(this,a,dst,axis,keepDim);
	}
	,split: function(a,dsts,axis,sizes) {
		return new webdl_core_backend_gpu_operation_GpuSplitOperation(this,a,dsts,axis,sizes);
	}
	,merge: function(as,dst,axis) {
		return new webdl_core_backend_gpu_operation_GpuMergeOperation(this,as,dst,axis);
	}
	,gradients: function(y,xs,dsts,gradY) {
		return new webdl_core_backend_gpu_operation_GpuGradientsOperation(this,y,xs,dsts,gradY);
	}
	,assign: function(a,dummyDst,dst) {
		return new webdl_core_backend_gpu_operation_GpuAssignOperation(this,a,dummyDst,dst);
	}
	,where: function(cond,a,b,dst) {
		return new webdl_core_backend_gpu_operation_GpuWhereOperation(this,cond,a,b,dst);
	}
	,adamUpdate: function(count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay,dummyDst) {
		return new webdl_core_backend_gpu_operation_GpuAdamUpdateOperation(this,count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay,dummyDst);
	}
};
var webdl_core_backend_gpu_GpuShader = function(gl,numSourceTextures,mode,fragmentSource) {
	this.gl = gl;
	this.vertexShader = gl.createShader(35633);
	this.fragmentShader = gl.createShader(35632);
	this.program = gl.createProgram();
	this.vertexSource = "\n\t\t\tattribute vec2 " + "aPos" + ";\n\t\t\tattribute vec2 " + "aUv" + ";\n\t\t\tvarying vec2 " + "vUv" + ";\n\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(" + "aPos" + ", 0, 1);\n\t\t\t\t" + "vUv" + " = " + "aUv" + ";\n\t\t\t}\n\t\t";
	this.fragmentSource = fragmentSource;
	this.fragmentSourceHeader = "\n\t\t\tprecision highp float;\n\t\t\tvarying vec2 " + "vUv" + ";\n\n\t\t\t" + this.sourceTextureUniformDefinition(numSourceTextures) + "\n\n\t\t\tuniform sampler2D " + "uDstTex" + ";\n\t\t\tuniform int " + "uDstTexSize" + ";\n\t\t\tuniform float " + "uDstInvTexSize" + ";\n\t\t\tuniform int " + "uDstActualSize" + ";\n\t\t\tuniform ivec4 " + "uDstShape" + ";\n\t\t\tuniform ivec4 " + "uDstStride" + ";\n\n\t\t\tint rem(int a, int b) {\n\t\t\t\tint tmp = a - a / b * b; // a % b\n\t\t\t\ttmp += b;\n\t\t\t\treturn tmp - tmp / b * b; // (a % b + b) % b\n\t\t\t}\n\n\t\t\tstruct elem {\n\t\t\t\tfloat value;\n\t\t\t\tfloat diff;\n\t\t\t};\n\n\t\t\tint index4To1(ivec4 idx4, ivec4 shape) {\n\t\t\t\tint idx1 = idx4.w;\n\t\t\t\tidx1 = idx1 * shape.z + idx4.z;\n\t\t\t\tidx1 = idx1 * shape.y + idx4.y;\n\t\t\t\tidx1 = idx1 * shape.x + idx4.x;\n\t\t\t\treturn idx1;\n\t\t\t}\n\n\t\t\tivec4 index1To4(int idx1, ivec4 shape) {\n\t\t\t\tivec4 idx4 = ivec4(0);\n\t\t\t\tidx4.x = rem(idx1, shape.x); idx1 /= shape.x;\n\t\t\t\tidx4.y = rem(idx1, shape.y); idx1 /= shape.y;\n\t\t\t\tidx4.z = rem(idx1, shape.z); idx1 /= shape.z;\n\t\t\t\tidx4.w = rem(idx1, shape.w);\n\t\t\t\treturn idx4;\n\t\t\t}\n\n\t\t\tint uvToIndex1(vec2 uv, int texSize) {\n\t\t\t\tivec2 pixel = ivec2(floor(uv * float(texSize)));\n\t\t\t\treturn pixel.y * texSize + pixel.x;\n\t\t\t}\n\n\t\t\tvec2 index4ToUv(ivec4 idx4, int texSize, ivec4 shape) {\n\t\t\t\tint idx1 = index4To1(idx4, shape);\n\t\t\t\tivec2 pixel = ivec2(rem(idx1, texSize), idx1 / texSize);\n\t\t\t\treturn (vec2(pixel) + 0.5) / float(texSize);\n\t\t\t}\n\n\t\t\tivec4 addX(ivec4 idx4, int x) {\n\t\t\t\treturn idx4 + ivec4(x, 0, 0, 0);\n\t\t\t}\n\n\t\t\tivec4 addY(ivec4 idx4, int y) {\n\t\t\t\treturn idx4 + ivec4(0, y, 0, 0);\n\t\t\t}\n\n\t\t\tivec4 addZ(ivec4 idx4, int z) {\n\t\t\t\treturn idx4 + ivec4(0, 0, z, 0);\n\t\t\t}\n\n\t\t\tivec4 addW(ivec4 idx4, int w) {\n\t\t\t\treturn idx4 + ivec4(0, 0, 0, w);\n\t\t\t}\n\n\t\t\tivec4 insertX(ivec4 idx4, int x) {\n\t\t\t\treturn ivec4(x, idx4.xyz);\n\t\t\t}\n\n\t\t\tivec4 insertY(ivec4 idx4, int y) {\n\t\t\t\treturn ivec4(idx4.x, y, idx4.yz);\n\t\t\t}\n\n\t\t\tivec4 insertZ(ivec4 idx4, int z) {\n\t\t\t\treturn ivec4(idx4.xy, z, idx4.z);\n\t\t\t}\n\n\t\t\tivec4 insertW(ivec4 idx4, int w) {\n\t\t\t\treturn ivec4(idx4.xyz, w);\n\t\t\t}\n\n\t\t\tivec4 deleteX(ivec4 idx4) {\n\t\t\t\treturn ivec4(idx4.yzw, 0);\n\t\t\t}\n\n\t\t\tivec4 deleteY(ivec4 idx4) {\n\t\t\t\treturn ivec4(idx4.xzw, 0);\n\t\t\t}\n\n\t\t\tivec4 deleteZ(ivec4 idx4) {\n\t\t\t\treturn ivec4(idx4.xyw, 0);\n\t\t\t}\n\n\t\t\tivec4 deleteW(ivec4 idx4) {\n\t\t\t\treturn ivec4(idx4.xyz, 0);\n\t\t\t}\n\n\t\t\tivec4 replaceX(ivec4 idx4, int x) {\n\t\t\t\treturn ivec4(x, idx4.yzw);\n\t\t\t}\n\n\t\t\tivec4 replaceY(ivec4 idx4, int y) {\n\t\t\t\treturn ivec4(idx4.x, y, idx4.zw);\n\t\t\t}\n\n\t\t\tivec4 replaceZ(ivec4 idx4, int z) {\n\t\t\t\treturn ivec4(idx4.xy, z, idx4.w);\n\t\t\t}\n\n\t\t\tivec4 replaceW(ivec4 idx4, int w) {\n\t\t\t\treturn ivec4(idx4.xyz, w);\n\t\t\t}\n\n\t\t\tfloat safePow(float a, float b) {\n\t\t\t\tif (a >= 0.0) {\n\t\t\t\t\treturn pow(a, b);\n\t\t\t\t} else {\n\t\t\t\t\tint intB = int(floor(b + 0.5));\n\t\t\t\t\tint sign = 1 - rem(intB, 2) * 2; // 1 for even, -1 for odd\n\t\t\t\t\treturn pow(abs(a), b) * float(sign);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfloat tanh(float x) {\n\t\t\t\tif (x < 0.0) {\n\t\t\t\t\tfloat epx2 = exp(2.0 * x);\n\t\t\t\t\treturn (epx2 - 1.0) / (epx2 + 1.0);\n\t\t\t\t} else {\n\t\t\t\t\tfloat emx2 = exp(-2.0 * x);\n\t\t\t\t\treturn (1.0 - emx2) / (1.0 + emx2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfloat tanhGrad(float x) {\n\t\t\t\tfloat tanhx = tanh(x);\n\t\t\t\treturn 1.0 - tanhx * tanhx;\n\t\t\t}\n\n\t\t\tfloat sigmoid(float x) {\n\t\t\t\treturn 1.0 / (1.0 + exp(-x));\n\t\t\t}\n\n\t\t\tfloat sigmoidGrad(float x) {\n\t\t\t\tfloat y = sigmoid(x);\n\t\t\t\treturn y * (1.0 - y);\n\t\t\t}\n\n\t\t\tfloat relu(float x) {\n\t\t\t\tif (x < 0.0) return 0.0;\n\t\t\t\treturn x;\n\t\t\t}\n\n\t\t\tfloat reluGrad(float x) {\n\t\t\t\tif (x < 0.0) return 0.0;\n\t\t\t\treturn 1.0;\n\t\t\t}\n\n\t\t\t" + this.sourceSampleDefinition(numSourceTextures) + "\n\t\t";
	var tmp = "\n\t\t\tvoid main() {\n\t\t\t\tint idx1 = uvToIndex1(" + "vUv" + ", " + "uDstTexSize" + ");\n\t\t\t\tif (idx1 >= " + "uDstActualSize" + ") {\n\t\t\t\t\tdiscard;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tivec4 idx4 = index1To4(idx1, " + "uDstShape" + ");\n\t\t\t\tvec4 dst = texture2D(" + "uDstTex" + ", " + "vUv" + ");\n\t\t\t\tfloat result = run(idx4);\n\t\t\t\tgl_FragColor = vec4(";
	var tmp1;
	switch(mode) {
	case 0:
		tmp1 = "result, dst.y, 0, 0";
		break;
	case 1:
		tmp1 = "dst.x, dst.y + result, 0, 0";
		break;
	case 2:
		tmp1 = "dst.x, result, 0, 0";
		break;
	default:
		throw new js__$Boot_HaxeError("invalid shader mode");
	}
	this.fragmentSourceFooter = tmp + tmp1 + ");\n\t\t\t}\n\t\t";
	this.compile();
};
webdl_core_backend_gpu_GpuShader.__name__ = true;
webdl_core_backend_gpu_GpuShader.loopOverDimensions = function(idx1s,idx1Offsets,sourceIndices,components,inside) {
	if(sourceIndices.length > 4) {
		throw new js__$Boot_HaxeError("too many indices");
	}
	if(sourceIndices.length != components.length) {
		throw new js__$Boot_HaxeError("invalid argument");
	}
	var res1 = "";
	var res2 = "";
	var idx1sType = ["int","ivec2","ivec3","ivec4"][sourceIndices.length - 1];
	var numLoops = components[0].length;
	var numIndices = sourceIndices.length;
	if(numLoops == 0) {
		res1 += "" + idx1sType + " " + idx1s + " = " + idx1Offsets + ";\n";
	}
	var _g1 = 0;
	var _g = numLoops;
	while(_g1 < _g) {
		var i = _g1++;
		var _g2 = [];
		var _g4 = 0;
		var _g3 = numIndices;
		while(_g4 < _g3) {
			var j = _g4++;
			_g2.push(components[j][i]);
		}
		var componentsInLoop = _g2;
		var idx1sInLoop = i == numLoops - 1 ? idx1s : idx1s + i + "_";
		var stridesInLoop = "strides" + i + "_";
		var loopCounter = "i" + i + "_";
		var nInLoop = "n" + i + "_";
		res1 += "int " + nInLoop + " = " + ("uSrcShape" + sourceIndices[0]) + "." + componentsInLoop[0] + ";\n";
		res1 += "" + idx1sType + " " + idx1sInLoop + " = " + idx1Offsets + ";\n";
		var res11 = "" + idx1sType + " " + stridesInLoop + " = " + idx1sType + "(";
		var _g41 = [];
		var _g6 = 0;
		var _g5 = numIndices;
		while(_g6 < _g5) {
			var j1 = _g6++;
			_g41.push("uSrcStride" + sourceIndices[j1] + "." + componentsInLoop[j1]);
		}
		res1 += res11 + _g41.join(", ") + ");\n";
		res1 += "for (int " + loopCounter + " = 0; " + loopCounter + " < " + 1000000 + "; " + loopCounter + "++) {\nif (" + loopCounter + " == " + nInLoop + ") break;\n";
		res2 = "\n}" + res2;
		res2 = "\n" + idx1sInLoop + " += " + stridesInLoop + ";" + res2;
		idx1Offsets = idx1sInLoop;
	}
	return res1 + inside + res2;
};
webdl_core_backend_gpu_GpuShader.loopOverDimensionsBroadcast = function(idx1,idx1Offset,broadcastTargetIndex,inside) {
	var doBroadcast = "doBroadcast";
	var res1 = "bvec4 " + doBroadcast + " = bvec4(ivec4(equal(" + "uDstShape" + ", ivec4(1))) * ivec4(notEqual(" + ("uSrcShape" + broadcastTargetIndex) + ", ivec4(1))));\n";
	var res2 = "";
	var _g = 0;
	while(_g < 4) {
		var i = _g++;
		var componentInLoop = "xyzw".charAt(i);
		var idx1InLoop = i == 3 ? idx1 : idx1 + i + "_";
		var strideInLoop = "stride" + i + "_";
		var loopCounter = "i" + i + "_";
		var nInLoop = "n" + i + "_";
		res1 += "int " + nInLoop + " = " + doBroadcast + "." + componentInLoop + " ? " + ("uSrcShape" + broadcastTargetIndex) + "." + componentInLoop + " : 1;\n";
		res1 += "int " + idx1InLoop + " = " + idx1Offset + ";\n";
		res1 += "int " + strideInLoop + " = " + ("uSrcStride" + broadcastTargetIndex + "." + componentInLoop) + ";\n";
		res1 += "for (int " + loopCounter + " = 0; " + loopCounter + " < " + 1000000 + "; " + loopCounter + "++) {\nif (" + loopCounter + " == " + nInLoop + ") break;\n";
		res2 = "\n}" + res2;
		res2 = "\n" + idx1InLoop + " += " + strideInLoop + ";" + res2;
		idx1Offset = idx1InLoop;
	}
	return res1 + inside + res2;
};
webdl_core_backend_gpu_GpuShader.prototype = {
	sourceTextureUniformDefinition: function(numSourceTextures) {
		var _g = [];
		var _g2 = 1;
		var _g1 = numSourceTextures + 1;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push("\n\t\t\tuniform sampler2D " + ("uSrcTex" + i) + ";\n\t\t\tuniform int " + ("uSrcTexSize" + i) + ";\n\t\t\tuniform float " + ("uSrcInvTexSize" + i) + ";\n\t\t\tuniform ivec4 " + ("uSrcShape" + i) + ";\n\t\t\tuniform ivec4 " + ("uSrcStride" + i) + ";\n\t\t");
		}
		return _g.join("\n");
	}
	,sourceSampleDefinition: function(numSourceTextures) {
		var _g = [];
		var _g2 = 1;
		var _g1 = numSourceTextures + 1;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push("\n\t\t\telem src" + i + "(ivec4 idx4) {\n\t\t\t\tidx4 *= ivec4(notEqual(" + ("uSrcShape" + i) + ", ivec4(1))); // broadcasting\n\t\t\t\tvec2 uv = index4ToUv(idx4, " + ("uSrcTexSize" + i) + ", " + ("uSrcShape" + i) + ");\n\t\t\t\tvec4 tex = texture2D(" + ("uSrcTex" + i) + ", uv);\n\t\t\t\treturn elem(tex.x, tex.y);\n\t\t\t}\n\t\t\telem src" + i + "(int idx1) {\n\t\t\t\tint pixY = idx1 / " + ("uSrcTexSize" + i) + ";\n\t\t\t\tint pixX = idx1 - pixY * " + ("uSrcTexSize" + i) + ";\n\t\t\t\tvec2 uv = vec2(pixX, pixY) * " + ("uSrcInvTexSize" + i) + ";\n\t\t\t\tvec4 tex = texture2D(" + ("uSrcTex" + i) + ", uv);\n\t\t\t\treturn elem(tex.x, tex.y);\n\t\t\t}\n\t\t");
		}
		return _g.join("\n");
	}
	,compile: function() {
		this.gl.shaderSource(this.vertexShader,this.vertexSource);
		this.gl.compileShader(this.vertexShader);
		if(!this.gl.getShaderParameter(this.vertexShader,35713)) {
			js_Browser.alert(this.gl.getShaderInfoLog(this.vertexShader));
			var lines = this.vertexSource.split("\n");
			var tmp = this.gl.getShaderInfoLog(this.vertexShader) + "\n";
			var _g = [];
			var _g2 = 0;
			var _g1 = lines.length;
			while(_g2 < _g1) {
				var i = _g2++;
				_g.push(i + 1 + " | " + lines[i]);
			}
			console.log("src/webdl/core/backend/gpu/GpuShader.hx:269:",tmp + _g.join("\n"));
		}
		var combinedFragmentShaderSource = this.fragmentSourceHeader + this.fragmentSource + this.fragmentSourceFooter;
		this.gl.shaderSource(this.fragmentShader,combinedFragmentShaderSource);
		this.gl.compileShader(this.fragmentShader);
		if(!this.gl.getShaderParameter(this.fragmentShader,35713)) {
			js_Browser.alert(this.gl.getShaderInfoLog(this.fragmentShader));
			var lines1 = combinedFragmentShaderSource.split("\n");
			var tmp1 = this.gl.getShaderInfoLog(this.fragmentShader) + "\n";
			var _g3 = [];
			var _g21 = 0;
			var _g11 = lines1.length;
			while(_g21 < _g11) {
				var i1 = _g21++;
				_g3.push(i1 + 1 + " | " + lines1[i1]);
			}
			console.log("src/webdl/core/backend/gpu/GpuShader.hx:278:",tmp1 + _g3.join("\n"));
		}
		this.gl.attachShader(this.program,this.vertexShader);
		this.gl.attachShader(this.program,this.fragmentShader);
		this.gl.linkProgram(this.program);
		if(!this.gl.getProgramParameter(this.program,35714)) {
			console.log("src/webdl/core/backend/gpu/GpuShader.hx:285:",this.gl.getProgramInfoLog(this.program));
		}
		this.map = new haxe_ds_StringMap();
	}
	,uniform: function(name) {
		var _this = this.map;
		if(__map_reserved[name] != null ? _this.existsReserved(name) : _this.h.hasOwnProperty(name)) {
			var _this1 = this.map;
			if(__map_reserved[name] != null) {
				return _this1.getReserved(name);
			} else {
				return _this1.h[name];
			}
		}
		var unif = this.gl.getUniformLocation(this.program,name);
		var _this2 = this.map;
		if(__map_reserved[name] != null) {
			_this2.setReserved(name,unif);
		} else {
			_this2.h[name] = unif;
		}
		return unif;
	}
	,attribute: function(name) {
		return this.gl.getAttribLocation(this.program,name);
	}
	,setSrc: function(t,index) {
		if(!(t.data instanceof webdl_core_backend_gpu_GpuTensorData)) {
			throw new js__$Boot_HaxeError("backends mismatch");
		}
		var gpuData = t.data;
		var src = gpuData.src;
		var shape = t.actualShape;
		var unit = index + 1;
		src.setAsSrc(this.uniform("uSrcTex" + unit),unit);
		var texSize = src.texSize;
		this.gl.uniform1i(this.uniform("uSrcTexSize" + unit),texSize);
		this.gl.uniform1f(this.uniform("uSrcInvTexSize" + unit),1 / texSize);
		var _g = t.rank;
		switch(_g) {
		case 0:
			this.gl.uniform4i(this.uniform("uSrcShape" + unit),1,1,1,1);
			this.gl.uniform4i(this.uniform("uSrcStride" + unit),1,1,1,1);
			break;
		case 1:
			this.gl.uniform4i(this.uniform("uSrcShape" + unit),shape[0],1,1,1);
			this.gl.uniform4i(this.uniform("uSrcStride" + unit),1,shape[0],shape[0],shape[0]);
			break;
		case 2:
			this.gl.uniform4i(this.uniform("uSrcShape" + unit),shape[1],shape[0],1,1);
			this.gl.uniform4i(this.uniform("uSrcStride" + unit),1,shape[1],shape[1] * shape[0],shape[1] * shape[0]);
			break;
		case 3:
			this.gl.uniform4i(this.uniform("uSrcShape" + unit),shape[2],shape[1],shape[0],1);
			this.gl.uniform4i(this.uniform("uSrcStride" + unit),1,shape[2],shape[2] * shape[1],shape[2] * shape[1] * shape[0]);
			break;
		case 4:
			this.gl.uniform4i(this.uniform("uSrcShape" + unit),shape[3],shape[2],shape[1],shape[0]);
			this.gl.uniform4i(this.uniform("uSrcStride" + unit),1,shape[3],shape[3] * shape[2],shape[3] * shape[2] * shape[1]);
			break;
		default:
			throw new js__$Boot_HaxeError("dimension too high");
		}
	}
	,setDst: function(t) {
		if(!(t.data instanceof webdl_core_backend_gpu_GpuTensorData)) {
			throw new js__$Boot_HaxeError("backends mismatch");
		}
		var gpuData = t.data;
		var src = gpuData.src;
		var dst = gpuData.dst;
		var shape = t.actualShape;
		src.setAsSrc(this.uniform("uDstTex"),0);
		dst.setAsDst();
		var texSize = dst.texSize;
		this.gl.uniform1i(this.uniform("uDstTexSize"),texSize);
		this.gl.uniform1f(this.uniform("uDstInvTexSize"),1 / texSize);
		this.gl.uniform1i(this.uniform("uDstActualSize"),t.actualSize);
		var _g = t.rank;
		switch(_g) {
		case 0:
			this.gl.uniform4i(this.uniform("uDstShape"),1,1,1,1);
			this.gl.uniform4i(this.uniform("uDstStride"),1,1,1,1);
			break;
		case 1:
			this.gl.uniform4i(this.uniform("uDstShape"),shape[0],1,1,1);
			this.gl.uniform4i(this.uniform("uDstStride"),1,shape[0],shape[0],shape[0]);
			break;
		case 2:
			this.gl.uniform4i(this.uniform("uDstShape"),shape[1],shape[0],1,1);
			this.gl.uniform4i(this.uniform("uDstStride"),1,shape[1],shape[1] * shape[0],shape[1] * shape[0]);
			break;
		case 3:
			this.gl.uniform4i(this.uniform("uDstShape"),shape[2],shape[1],shape[0],1);
			this.gl.uniform4i(this.uniform("uDstStride"),1,shape[2],shape[2] * shape[1],shape[2] * shape[1] * shape[0]);
			break;
		case 4:
			this.gl.uniform4i(this.uniform("uDstShape"),shape[3],shape[2],shape[1],shape[0]);
			this.gl.uniform4i(this.uniform("uDstStride"),1,shape[3],shape[3] * shape[2],shape[3] * shape[2] * shape[1]);
			break;
		default:
			throw new js__$Boot_HaxeError("dimension too high");
		}
	}
};
var webdl_core_backend_gpu_GpuTensorData = function(gl,requestedSize) {
	this.gl = gl;
	var texSize = 1;
	while(texSize * texSize < requestedSize) texSize *= 2;
	this.maxSize = texSize * texSize;
	this.src = new webdl_core_backend_gpu_GpuArray(gl,texSize);
	this.dst = new webdl_core_backend_gpu_GpuArray(gl,texSize);
};
webdl_core_backend_gpu_GpuTensorData.__name__ = true;
webdl_core_backend_gpu_GpuTensorData.__interfaces__ = [webdl_core_TensorData];
webdl_core_backend_gpu_GpuTensorData.prototype = {
	isPreferableSize: function(size) {
		if(size <= this.maxSize) {
			return size * 4 > this.maxSize;
		} else {
			return false;
		}
	}
	,getValue: function(size) {
		if(size > this.maxSize) {
			throw new js__$Boot_HaxeError("max size exceeded");
		}
		this.src.downloadPixels();
		var value = [];
		var _g1 = 0;
		var _g = size;
		while(_g1 < _g) {
			var i = _g1++;
			value.push(this.src.data[i << 2]);
		}
		return value;
	}
	,setValue: function(value) {
		if(value.length > this.maxSize) {
			throw new js__$Boot_HaxeError("max size exceeded");
		}
		var _g1 = 0;
		var _g = value.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.src.data[i << 2] = value[i];
		}
		this.src.uploadPixels();
	}
	,clearValue: function(value) {
		this.gl.bindFramebuffer(36160,this.src.fbuf);
		this.gl.colorMask(true,false,false,false);
		this.gl.clearColor(value,0,0,0);
		this.gl.clear(16384);
		this.gl.colorMask(true,true,true,true);
		this.gl.bindFramebuffer(36160,null);
	}
	,getDiff: function(size) {
		if(size > this.maxSize) {
			throw new js__$Boot_HaxeError("max size exceeded");
		}
		this.src.downloadPixels();
		var diff = [];
		var _g1 = 0;
		var _g = size;
		while(_g1 < _g) {
			var i = _g1++;
			diff.push(this.src.data[i << 2 | 1]);
		}
		return diff;
	}
	,setDiff: function(diff) {
		if(diff.length > this.maxSize) {
			throw new js__$Boot_HaxeError("max size exceeded");
		}
		var _g1 = 0;
		var _g = diff.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.src.data[i << 2 | 1] = diff[i];
		}
		this.src.uploadPixels();
	}
	,clearDiff: function(diff) {
		this.gl.bindFramebuffer(36160,this.src.fbuf);
		this.gl.colorMask(false,true,false,false);
		this.gl.clearColor(0,diff,0,0);
		this.gl.clear(16384);
		this.gl.colorMask(true,true,true,true);
		this.gl.bindFramebuffer(36160,null);
	}
	,flip: function() {
		var tmp = this.src;
		this.src = this.dst;
		this.dst = tmp;
	}
};
var webdl_core_backend_gpu_ShaderConsts = function() { };
webdl_core_backend_gpu_ShaderConsts.__name__ = true;
var webdl_core_backend_gpu_operation_BroadcastBackpropData = function(src,dst,axes,intermediates,ops,scalar) {
	this.src = src;
	this.dst = dst;
	this.axes = axes;
	this.intermediates = intermediates;
	this.ops = ops;
	this.scalar = scalar;
};
webdl_core_backend_gpu_operation_BroadcastBackpropData.__name__ = true;
var webdl_core_backend_gpu_operation_GpuOperation = function(backend,inputs,outputs) {
	webdl_core_Operation.call(this,inputs,outputs);
	this.backend = backend;
	this.forwardOps = [];
	this.backwardOps = [];
	this.broadcasts = [];
};
webdl_core_backend_gpu_operation_GpuOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuOperation.__super__ = webdl_core_Operation;
webdl_core_backend_gpu_operation_GpuOperation.prototype = $extend(webdl_core_Operation.prototype,{
	shapeEq: function(a,b,shrinkA,shrinkB) {
		if(shrinkB == null) {
			shrinkB = 0;
		}
		if(shrinkA == null) {
			shrinkA = 0;
		}
		var res = true;
		if(a.length - shrinkA != b.length - shrinkB) {
			res = false;
		} else {
			var num = a.length - shrinkA;
			var _g1 = 0;
			var _g = num;
			while(_g1 < _g) {
				var i = _g1++;
				var sizeA = a[i];
				var sizeB = b[i];
				if(sizeA == -1 || sizeB == -1) {
					throw new js__$Boot_HaxeError("no data assigned");
				}
				res = res && sizeA == sizeB;
			}
		}
		if(!res) {
			throw new js__$Boot_HaxeError("shapes mismatch");
		}
	}
	,fop: function(inputs,output,name,fragmentSource) {
		return new webdl_core_backend_gpu_GpuAtomicOperation(inputs,output,name,new webdl_core_backend_gpu_GpuShader(this.backend.gl,inputs.length,0,fragmentSource));
	}
	,bop: function(inputs,output,name,fragmentSource,accumulate) {
		if(accumulate == null) {
			accumulate = true;
		}
		return new webdl_core_backend_gpu_GpuAtomicOperation(inputs,output,name,new webdl_core_backend_gpu_GpuShader(this.backend.gl,inputs.length,accumulate ? 1 : 2,fragmentSource));
	}
	,addBroadcastBackward: function(src,dst,axes) {
		if(axes.length == 0) {
			return src;
		}
		var shape = dst.shape.slice(0);
		var prevTensor = webdl_core_WebDL.tensorOfShape(shape);
		var intermediates = [prevTensor];
		var ops = [];
		var _g1 = 0;
		var _g = axes.length;
		while(_g1 < _g) {
			var i = _g1++;
			var axis = axes[i];
			shape[axis] = 1;
			var nextTensor = i == axes.length - 1 ? src : webdl_core_WebDL.tensorOfShape(shape);
			intermediates.push(nextTensor);
			var axisComp = "xyzw".charAt(dst.rank - 1 - axis);
			ops.push(new webdl_core_backend_gpu_GpuAtomicOperation([prevTensor],nextTensor,"broadcast_backward" + i,new webdl_core_backend_gpu_GpuShader(this.backend.gl,1,nextTensor == src ? 1 : 2,"\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\tint idx1Offset = index4To1(idx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[[axisComp]],"\n\t\t\t\t\t\t\telem a = src1(idx1);\n\t\t\t\t\t\t\tsum += a.diff;\n\t\t\t\t\t\t") + "\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t")));
			prevTensor = nextTensor;
		}
		this.broadcasts.push(new webdl_core_backend_gpu_operation_BroadcastBackpropData(src,dst,axes,intermediates,ops,src.rank == 0));
		return intermediates[0];
	}
	,shapeCheck: function() {
	}
	,broadcastBackwardShapeCheck: function() {
		var _g = 0;
		var _g1 = this.broadcasts;
		while(_g < _g1.length) {
			var b = _g1[_g];
			++_g;
			var dst = b.dst;
			var intermediates = b.intermediates;
			var axes = b.axes;
			var shape = dst.actualShape.slice(0);
			intermediates[0].assignShape(shape);
			intermediates[0].fillDiff(0);
			var _g3 = 1;
			var _g2 = intermediates.length;
			while(_g3 < _g2) {
				var j = _g3++;
				shape[axes[j - 1]] = 1;
				if(j == intermediates.length - 1 && b.scalar) {
					intermediates[j].assignShape([]);
				} else {
					intermediates[j].assignShape(shape);
				}
			}
		}
	}
	,run: function() {
		this.shapeCheck();
		var _g = 0;
		var _g1 = this.forwardOps;
		while(_g < _g1.length) {
			var forwardOp = _g1[_g];
			++_g;
			this.backend.runAtomicOperation(forwardOp);
		}
	}
	,backwardRun: function() {
		this.broadcastBackwardShapeCheck();
		var _g = 0;
		var _g1 = this.backwardOps;
		while(_g < _g1.length) {
			var backwardOp = _g1[_g];
			++_g;
			this.backend.runAtomicOperation(backwardOp);
		}
		var _g2 = 0;
		var _g11 = this.broadcasts;
		while(_g2 < _g11.length) {
			var b = _g11[_g2];
			++_g2;
			var _g21 = 0;
			var _g3 = b.ops;
			while(_g21 < _g3.length) {
				var op = _g3[_g21];
				++_g21;
				this.backend.runAtomicOperation(op);
			}
		}
	}
});
var webdl_core_backend_gpu_operation_GpuAbsOperation = function(backend,a,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"abs_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn abs(a.value);\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,a],a,"abs_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\tif (a.value < 0.0) {\n\t\t\t\t\t\treturn -dst.diff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn dst.diff;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuAbsOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuAbsOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuAbsOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuActivationOperation = function(backend,a,dst,activation) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	var activForward;
	switch(activation) {
	case 0:
		activForward = "a.value";
		break;
	case 1:
		activForward = "tanh(a.value)";
		break;
	case 2:
		activForward = "sigmoid(a.value)";
		break;
	case 3:
		activForward = "relu(a.value)";
		break;
	}
	var activBackward;
	switch(activation) {
	case 0:
		activBackward = "1.0";
		break;
	case 1:
		activBackward = "tanhGrad(a.value)";
		break;
	case 2:
		activBackward = "sigmoidGrad(a.value)";
		break;
	case 3:
		activBackward = "reluGrad(a.value)";
		break;
	}
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"activation_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn " + activForward + ";\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,a],a,"activation_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\treturn dst.diff * " + activBackward + ";\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuActivationOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuActivationOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuActivationOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuAdamUpdateOperation = function(backend,count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay,dummyDst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[count,t,g,m,v,alpha,beta1,beta2,epsilon,l2Decay],[dummyDst]);
	this.count = count;
	this.t = t;
	this.g = g;
	this.m = m;
	this.v = v;
	this.alpha = alpha;
	this.beta1 = beta1;
	this.beta2 = beta2;
	this.epsilon = epsilon;
	this.l2Decay = l2Decay;
	this.forwardOps = [this.fop([g,m,beta1],m,"adam_update_m","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tfloat g = src1(idx4).value;\n\t\t\t\t\tfloat m = src2(idx4).value;\n\t\t\t\t\tfloat beta1 = src3(idx4).value;\n\t\t\t\t\treturn beta1 * m + (1.0 - beta1) * g;\n\t\t\t\t}\n\t\t\t"),this.fop([g,v,beta2],v,"adam_update_v","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tfloat g = src1(idx4).value;\n\t\t\t\t\tfloat v = src2(idx4).value;\n\t\t\t\t\tfloat beta2 = src3(idx4).value;\n\t\t\t\t\treturn beta2 * v + (1.0 - beta2) * g * g;\n\t\t\t\t}\n\t\t\t"),this.fop([t,count,m,v,alpha,beta1,beta2,epsilon,l2Decay],t,"adam_update_t","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tfloat t       = src1(idx4).value;\n\t\t\t\t\tfloat count   = src2(idx4).value;\n\t\t\t\t\tfloat m       = src3(idx4).value;\n\t\t\t\t\tfloat v       = src4(idx4).value;\n\t\t\t\t\tfloat alpha   = src5(idx4).value;\n\t\t\t\t\tfloat beta1   = src6(idx4).value;\n\t\t\t\t\tfloat beta2   = src7(idx4).value;\n\t\t\t\t\tfloat epsilon = src8(idx4).value;\n\t\t\t\t\tfloat l2Decay = src9(idx4).value;\n\t\t\t\t\tfloat mHat = m / (1.0 - pow(beta1, count));\n\t\t\t\t\tfloat vHat = v / (1.0 - pow(beta2, count));\n\t\t\t\t\treturn t - alpha * (mHat / (sqrt(vHat) + epsilon) + l2Decay * t);\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [];
};
webdl_core_backend_gpu_operation_GpuAdamUpdateOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuAdamUpdateOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuAdamUpdateOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.shapeEq(this.t.actualShape,this.g.actualShape);
		this.m.assignShape(this.t.actualShape);
		this.v.assignShape(this.t.actualShape);
		var this1 = new Array(0);
		var scalarShape = this1;
		this.shapeEq(this.alpha.actualShape,scalarShape);
		this.shapeEq(this.beta1.actualShape,scalarShape);
		this.shapeEq(this.beta2.actualShape,scalarShape);
		this.shapeEq(this.epsilon.actualShape,scalarShape);
		this.shapeEq(this.l2Decay.actualShape,scalarShape);
	}
	,backwardRun: function() {
		throw new js__$Boot_HaxeError("differentiation of adam update is not supported");
	}
});
var webdl_core_backend_gpu_operation_GpuAddConstOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"addconst_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn a.value + float(" + b + ");\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst],a,"addconst_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuAddConstOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuAddConstOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuAddConstOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuAddOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"add_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn a.value + b.value;\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst],broadcastedA,"add_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t"),this.bop([dst],broadcastedB,"add_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuAddOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuAddOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuAddOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuAssignOperation = function(backend,a,dummyDst,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dummyDst]);
	this.a = a;
	this.dummyDst = dummyDst;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dummyDst,"assign_forward_dummy","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn a.value;\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dummyDst],a,"assign_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t")];
	this.assignOp = this.fop([a],dst,"assign_forward","\n\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\telem a = src1(idx4);\n\t\t\t\treturn a.value;\n\t\t\t}\n\t\t");
};
webdl_core_backend_gpu_operation_GpuAssignOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuAssignOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuAssignOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	run: function() {
		this.shapeCheck();
		if(!this.assignFast(this.a,this.dummyDst)) {
			var _g = 0;
			var _g1 = this.forwardOps;
			while(_g < _g1.length) {
				var forwardOp = _g1[_g];
				++_g;
				this.backend.runAtomicOperation(forwardOp);
			}
		}
	}
	,backwardRun: function() {
		if(!this.assignFast(this.dummyDst,this.a)) {
			webdl_core_backend_gpu_operation_GpuOperation.prototype.backwardRun.call(this);
		}
	}
	,shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
		this.dummyDst.assignShape(this.a.actualShape);
	}
	,onAfterRun: function() {
		if(!this.assignFast(this.a,this.dst)) {
			this.backend.runAtomicOperation(this.assignOp);
		}
	}
	,assignFast: function(src,dst) {
		var srcData = src.data;
		var dstData = dst.data;
		if(srcData.src.texSize != dstData.src.texSize) {
			return false;
		}
		var size = srcData.src.texSize;
		var gl = this.backend.gl;
		gl.bindFramebuffer(36160,srcData.src.fbuf);
		gl.bindTexture(3553,dstData.src.tex);
		gl.copyTexSubImage2D(3553,0,0,0,0,0,size,size);
		gl.bindTexture(3553,null);
		gl.bindFramebuffer(36160,null);
		return true;
	}
});
var webdl_core_backend_gpu_operation_GpuBiasAddOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"biasadd_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(ivec4(idx4.x, 0, 0, 0));\n\t\t\t\t\treturn a.value + b.value;\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst],a,"biasadd_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t"),this.bop([dst],b,"biasadd_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t// sum up all the higher dimensions in dst\n\t\t\t\t\tidx4.yzw = ivec3(0);\n\t\t\t\t\tint idx1Offset = index4To1(idx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[["y","z","w"]],"\n\t\t\t\t\t\telem dst = src1(idx1);\n\t\t\t\t\t\tsum += dst.diff;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuBiasAddOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuBiasAddOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuBiasAddOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		if(this.a.actualShape[this.a.rank - 1] != this.b.actualShape[this.b.rank - 1]) {
			throw new js__$Boot_HaxeError("dimensions mismatch");
		}
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuDivOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"div_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn a.value / b.value;\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst,b],broadcastedA,"div_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn dst.diff / b.value;\n\t\t\t\t}\n\t\t\t"),this.bop([dst,a,b],broadcastedB,"div_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\telem b = src3(idx4);\n\t\t\t\t\treturn -dst.diff * a.value / (b.value * b.value);\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuDivOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuDivOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuDivOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuExpOperation = function(backend,a,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"exp_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn exp(a.value);\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst],a,"exp_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff * dst.value;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuExpOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuExpOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuExpOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuGradientsOperation = function(backend,y,xs,dsts,gradY) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,xs.concat(gradY == null ? [y] : [y,gradY]),dsts);
	this.y = y;
	this.xs = xs;
	this.dsts = dsts;
	this.gradY = gradY;
	if(xs.length != dsts.length) {
		throw new js__$Boot_HaxeError("invalid argument");
	}
	var _g = [];
	var _g2 = 0;
	var _g1 = xs.length;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(this.fop([xs[i]],dsts[i],"gradient_forward_" + i,"\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn a.diff;\n\t\t\t\t}\n\t\t\t"));
	}
	this.forwardOps = _g;
	this.backwardOps = gradY == null ? [] : [this.bop([gradY],y,"gradient_init","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem gradY = src1(idx4);\n\t\t\t\t\treturn gradY.value;\n\t\t\t\t}\n\t\t\t",false)];
};
webdl_core_backend_gpu_operation_GpuGradientsOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuGradientsOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuGradientsOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	run: function() {
		if(this.gradY == null) {
			this.y.fillDiff(1.0);
		} else {
			webdl_core_backend_gpu_operation_GpuOperation.prototype.backwardRun.call(this);
		}
		webdl_core_graph_Graph.backprop(this.y.node);
		webdl_core_backend_gpu_operation_GpuOperation.prototype.run.call(this);
	}
	,backwardRun: function() {
		throw new js__$Boot_HaxeError("gradient operation is not differentiable");
	}
	,shapeCheck: function() {
		var _g1 = 0;
		var _g = this.dsts.length;
		while(_g1 < _g) {
			var i = _g1++;
			this.dsts[i].assignShape(this.xs[i].actualShape);
		}
	}
});
var webdl_core_backend_gpu_operation_GpuLinCombOperation = function(backend,a,b,dst,aScale,bScale) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"lincomb_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn a.value * float(" + aScale + ") + b.value * float(" + bScale + ");\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst],broadcastedA,"lincomb_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff * float(" + aScale + ");\n\t\t\t\t}\n\t\t\t"),this.bop([dst],broadcastedB,"lincomb_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff * float(" + bScale + ");\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuLinCombOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuLinCombOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuLinCombOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuLogOperation = function(backend,a,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"log_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn log(a.value);\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,a],a,"log_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\treturn dst.diff / a.value;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuLogOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuLogOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuLogOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuMatMulOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"matmul_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 aIdx4 = replaceX(idx4, 0);\n\t\t\t\t\tivec4 bIdx4 = replaceY(idx4, 0);\n\n\t\t\t\t\tint aIdx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint bIdx1Offset = index4To1(bIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(aIdx1Offset, bIdx1Offset);\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[["x"],["y"]],"\n\t\t\t\t\t\telem a = src1(idx1s.x);\n\t\t\t\t\t\telem b = src2(idx1s.y);\n\t\t\t\t\t\tsum += a.value * b.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,b],a,"matmul_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 dstIdx4 = ivec4(0, idx4.yzw);\n\t\t\t\t\tivec4 bIdx4 = ivec4(0, idx4.xzw);\n\n\t\t\t\t\tint dstIdx1Offset = index4To1(dstIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint bIdx1Offset = index4To1(bIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(dstIdx1Offset, bIdx1Offset);\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[["x"],["x"]],"\n\t\t\t\t\t\telem dst = src1(idx1s.x);\n\t\t\t\t\t\telem b = src2(idx1s.y);\n\t\t\t\t\t\tsum += dst.diff * b.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t"),this.bop([dst,a],b,"matmul_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 dstIdx4 = ivec4(idx4.x, 0, idx4.zw);\n\t\t\t\t\tivec4 aIdx4 = ivec4(idx4.y, 0, idx4.zw);\n\n\t\t\t\t\tint dstIdx1Offset = index4To1(dstIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint aIdx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(dstIdx1Offset, aIdx1Offset);\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[["y"],["y"]],"\n\t\t\t\t\t\telem dst = src1(idx1s.x);\n\t\t\t\t\t\telem a = src2(idx1s.y);\n\t\t\t\t\t\tsum += dst.diff * a.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuMatMulOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuMatMulOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuMatMulOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		var aLast = this.a.rank - 1;
		var bLast = this.b.rank - 1;
		this.shapeEq(this.a.actualShape,this.b.actualShape,2,2);
		if(this.a.actualShape[aLast] != this.b.actualShape[bLast - 1]) {
			throw new js__$Boot_HaxeError("cannot multiply matrices");
		}
		var dstShape = this.a.actualShape.slice(0);
		dstShape[bLast] = this.b.actualShape[bLast];
		this.dst.assignShape(dstShape);
	}
});
var webdl_core_backend_gpu_operation_GpuMergeOperation = function(backend,as,dst,axis) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,as,[dst]);
	this.as = as;
	this.dst = dst;
	this.axis = axis;
	if(axis < 0 || axis >= dst.rank) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var axisComp = "xyzw".charAt(dst.rank - 1 - axis);
	var axisCompUpper = axisComp.toUpperCase();
	var offset = "0";
	var offsets = [];
	var _g1 = 0;
	var _g = as.length;
	while(_g1 < _g) {
		var i = _g1++;
		offsets.push(offset);
		offset += " + " + "uSrcShape" + (i + 1) + "." + axisComp;
	}
	offsets.push(offset);
	offsets = offsets.map(function(s) {
		return "(" + s + ")";
	});
	var tmp = "\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tint idx = idx4." + axisComp + ";\n\t\t\t\t";
	var _g2 = [];
	var _g21 = 0;
	var _g11 = as.length;
	while(_g21 < _g11) {
		var i1 = _g21++;
		_g2.push("\n\t\t\t\t\t\tif (idx < " + offsets[i1 + 1] + ") {\n\t\t\t\t\t\t\telem a = src" + (i1 + 1) + "(add" + axisCompUpper + "(idx4, -" + offsets[i1] + "));\n\t\t\t\t\t\t\treturn a.value;\n\t\t\t\t\t\t}\n\t\t\t\t\t");
	}
	this.forwardOps = [this.fop(as,dst,"merge_forward",tmp + _g2.join("\n") + "\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t")];
	var _g12 = [];
	var _g3 = 0;
	var _g22 = as.length;
	while(_g3 < _g22) {
		var i2 = _g3++;
		_g12.push(this.bop(as.concat([dst]),as[i2],"merge_backward_" + i2,"\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem dst = src" + (as.length + 1) + "(add" + axisCompUpper + "(idx4, " + offsets[i2] + "));\n\t\t\t\t\t\treturn dst.diff;\n\t\t\t\t\t}\n\t\t\t\t"));
	}
	this.backwardOps = _g12;
};
webdl_core_backend_gpu_operation_GpuMergeOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuMergeOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuMergeOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		var totalSize = 0;
		var this1 = this.as[0].actualShape;
		var this2 = new Array(this1.length);
		var r = this2;
		haxe_ds__$Vector_Vector_$Impl_$.blit(this1,0,r,0,this1.length);
		var dstShape = r;
		dstShape[this.axis] = 0;
		var _g1 = 0;
		var _g = this.as.length;
		while(_g1 < _g) {
			var i = _g1++;
			var aShape = this.as[i].actualShape;
			totalSize += aShape[this.axis];
			dstShape[this.axis] = aShape[this.axis];
			this.shapeEq(dstShape,aShape);
		}
		dstShape[this.axis] = totalSize;
		this.dst.assignShape(dstShape);
	}
});
var webdl_core_backend_gpu_operation_GpuMulConstOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"mulconst_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn a.value * float(" + b + ");\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst],a,"mulconst_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff * float(" + b + ");\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuMulConstOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuMulConstOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuMulConstOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuMulOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"mul_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn a.value * b.value;\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst,b],broadcastedA,"mul_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn dst.diff * b.value;\n\t\t\t\t}\n\t\t\t"),this.bop([dst,a],broadcastedB,"mul_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\treturn dst.diff * a.value;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuMulOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuMulOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuMulOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuPowConstOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.forwardOps = [this.fop([a],dst,"powconst_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\treturn safePow(a.value, float(" + b + "));\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,a],a,"powconst_backward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\treturn dst.diff * float(" + b + ") * safePow(a.value, float(" + b + ") - 1.0);\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuPowConstOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuPowConstOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuPowConstOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(this.a.actualShape);
	}
});
var webdl_core_backend_gpu_operation_GpuPowOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"pow_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn safePow(a.value, b.value);\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst,a,b],broadcastedA,"pow_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\telem b = src3(idx4);\n\t\t\t\t\treturn dst.diff * b.value * safePow(a.value, b.value - 1.0);\n\t\t\t\t}\n\t\t\t"),this.bop([dst,a],broadcastedB,"pow_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\treturn dst.diff * log(a.value) * dst.value;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuPowOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuPowOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuPowOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuReduceMeanOperation = function(backend,a,dst,axis,keepDim) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.keepDim = keepDim;
	this.axis = axis;
	if(axis < 0 || axis >= a.rank) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var axisComp = "xyzw".charAt(a.rank - 1 - axis);
	var axisCompUpper = axisComp.toUpperCase();
	if(keepDim) {
		this.forwardOps = [this.fop([a],dst,"reducemean_forward_kd","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\tivec4 aIdx4 = replace" + axisCompUpper + "(idx4, 0);\n\t\t\t\t\t\tint idx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[[axisComp]],"\n\t\t\t\t\t\t\telem a = src1(idx1);\n\t\t\t\t\t\t\tsum += a.value;\n\t\t\t\t\t\t") + ("\n\t\t\t\t\t\treturn sum / float(" + ("uSrcShape" + "1") + "." + axisComp + ");\n\t\t\t\t\t}\n\t\t\t\t"))];
		this.backwardOps = [this.bop([dst],a,"reducemean_backward_kd","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem dst = src1(replace" + axisCompUpper + "(idx4, 0));\n\t\t\t\t\t\treturn dst.diff / float(" + "uDstShape" + "." + axisComp + ");\n\t\t\t\t\t}\n\t\t\t\t")];
	} else {
		this.forwardOps = [this.fop([a],dst,"reducemean_forward","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\tivec4 aIdx4 = insert" + axisCompUpper + "(idx4, 0);\n\t\t\t\t\t\tint idx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[[axisComp]],"\n\t\t\t\t\t\t\telem a = src1(idx1);\n\t\t\t\t\t\t\tsum += a.value;\n\t\t\t\t\t\t") + ("\n\t\t\t\t\t\treturn sum / float(" + ("uSrcShape" + "1") + "." + axisComp + ");\n\t\t\t\t\t}\n\t\t\t\t"))];
		this.backwardOps = [this.bop([dst],a,"reducemean_backward","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem dst = src1(delete" + axisCompUpper + "(idx4));\n\t\t\t\t\t\treturn dst.diff / float(" + "uDstShape" + "." + axisComp + ");\n\t\t\t\t\t}\n\t\t\t\t")];
	}
};
webdl_core_backend_gpu_operation_GpuReduceMeanOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuReduceMeanOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuReduceMeanOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		var dstShape = [];
		if(this.keepDim) {
			dstShape = this.a.actualShape.slice(0);
			dstShape[this.axis] = 1;
			this.dst.assignShape(dstShape);
		} else {
			var _g1 = 0;
			var _g = this.a.rank;
			while(_g1 < _g) {
				var i = _g1++;
				if(this.axis != i) {
					dstShape.push(this.a.actualShape[i]);
				}
			}
			this.dst.assignShape(dstShape);
		}
	}
});
var webdl_core_backend_gpu_operation_GpuReduceSumOperation = function(backend,a,dst,axis,keepDim) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],[dst]);
	this.a = a;
	this.dst = dst;
	this.keepDim = keepDim;
	this.axis = axis;
	if(axis < 0 || axis >= a.rank) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var axisComp = "xyzw".charAt(a.rank - 1 - axis);
	var axisCompUpper = axisComp.toUpperCase();
	if(keepDim) {
		this.forwardOps = [this.fop([a],dst,"reducesum_forward_kd","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\tivec4 aIdx4 = replace" + axisCompUpper + "(idx4, 0);\n\t\t\t\t\t\tint idx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[[axisComp]],"\n\t\t\t\t\t\t\telem a = src1(idx1);\n\t\t\t\t\t\t\tsum += a.value;\n\t\t\t\t\t\t") + "\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t")];
		this.backwardOps = [this.bop([dst],a,"reducesum_backward_kd","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem dst = src1(replace" + axisCompUpper + "(idx4, 0));\n\t\t\t\t\t\treturn dst.diff;\n\t\t\t\t\t}\n\t\t\t\t")];
	} else {
		this.forwardOps = [this.fop([a],dst,"reducesum_forward","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\tivec4 aIdx4 = insert" + axisCompUpper + "(idx4, 0);\n\t\t\t\t\t\tint idx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t\t" + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1","idx1Offset",[1],[[axisComp]],"\n\t\t\t\t\t\t\telem a = src1(idx1);\n\t\t\t\t\t\t\tsum += a.value;\n\t\t\t\t\t\t") + "\n\t\t\t\t\t\treturn sum;\n\t\t\t\t\t}\n\t\t\t\t")];
		this.backwardOps = [this.bop([dst],a,"reducesum_backward","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem dst = src1(delete" + axisCompUpper + "(idx4));\n\t\t\t\t\t\treturn dst.diff;\n\t\t\t\t\t}\n\t\t\t\t")];
	}
};
webdl_core_backend_gpu_operation_GpuReduceSumOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuReduceSumOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuReduceSumOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		var dstShape = [];
		if(this.keepDim) {
			dstShape = this.a.actualShape.slice(0);
			dstShape[this.axis] = 1;
			this.dst.assignShape(dstShape);
		} else {
			var _g1 = 0;
			var _g = this.a.rank;
			while(_g1 < _g) {
				var i = _g1++;
				if(this.axis != i) {
					dstShape.push(this.a.actualShape[i]);
				}
			}
			this.dst.assignShape(dstShape);
		}
	}
});
var webdl_core_backend_gpu_operation_GpuSplitOperation = function(backend,a,dsts,axis,sizes) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a],dsts);
	this.a = a;
	this.dsts = dsts;
	this.sizes = sizes;
	this.axis = axis;
	if(axis < 0 || axis >= a.rank) {
		throw new js__$Boot_HaxeError("invalid axis");
	}
	var axisComp = "xyzw".charAt(a.rank - 1 - axis);
	var axisCompUpper = axisComp.toUpperCase();
	if(dsts.length != sizes.length) {
		throw new js__$Boot_HaxeError("invalid argument");
	}
	var offset = 0;
	var offsets = [];
	var _g = 0;
	while(_g < sizes.length) {
		var size = sizes[_g];
		++_g;
		offsets.push(offset);
		offset += size;
	}
	offsets.push(offset);
	var _g1 = [];
	var _g2 = 0;
	var _g11 = dsts.length;
	while(_g2 < _g11) {
		var i = _g2++;
		_g1.push(this.fop([a],dsts[i],"split_forward","\n\t\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\t\telem a = src1(add" + axisCompUpper + "(idx4, " + offsets[i] + "));\n\t\t\t\t\t\treturn a.value;\n\t\t\t\t\t}\n\t\t\t\t"));
	}
	this.forwardOps = _g1;
	var tmp = "\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tint idx = idx4." + axisComp + ";\n\t\t\t\t";
	var _g12 = [];
	var _g3 = 0;
	var _g21 = dsts.length;
	while(_g3 < _g21) {
		var i1 = _g3++;
		_g12.push("\n\t\t\t\t\t\tif (idx < " + offsets[i1 + 1] + ") {\n\t\t\t\t\t\t\telem dst = src" + (i1 + 1) + "(add" + axisCompUpper + "(idx4, -" + offsets[i1] + "));\n\t\t\t\t\t\t\treturn dst.diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t");
	}
	this.backwardOps = [this.bop(dsts,a,"split_backward",tmp + _g12.join("\n") + "\n\t\t\t\t\treturn 0.0;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuSplitOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuSplitOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuSplitOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		var totalSize = 0;
		var _g1 = 0;
		var _g = this.dsts.length;
		while(_g1 < _g) {
			var i = _g1++;
			var this1 = this.a.actualShape;
			var this2 = new Array(this1.length);
			var r = this2;
			haxe_ds__$Vector_Vector_$Impl_$.blit(this1,0,r,0,this1.length);
			var dstShape = r;
			dstShape[this.axis] = this.sizes[i];
			this.dsts[i].assignShape(dstShape);
			totalSize += this.sizes[i];
		}
		if(totalSize != this.a.actualShape[this.axis]) {
			throw new js__$Boot_HaxeError("split sizes mismatch");
		}
	}
});
var webdl_core_backend_gpu_operation_GpuSubOperation = function(backend,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([a,b],dst,"sub_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem a = src1(idx4);\n\t\t\t\t\telem b = src2(idx4);\n\t\t\t\t\treturn a.value - b.value;\n\t\t\t\t}\n\t\t\t")];
	var broadcastedA = this.addBroadcastBackward(a,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,a.shape));
	var broadcastedB = this.addBroadcastBackward(b,dst,webdl_core_ShapeInference.getBroadcastedAxes(dst.shape,b.shape));
	this.backwardOps = [this.bop([dst],broadcastedA,"sub_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn dst.diff;\n\t\t\t\t}\n\t\t\t"),this.bop([dst],broadcastedB,"sub_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\treturn -dst.diff;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuSubOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuSubOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuSubOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.dst.assignShape(webdl_core_ShapeInference.broadcast(this.a.shape,this.b.shape,this.a.actualShape,this.b.actualShape));
	}
});
var webdl_core_backend_gpu_operation_GpuTensorDotOperation = function(backend,a,b,dst,count,axes) {
	var _gthis = this;
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[a,b],[dst]);
	this.a = a;
	this.b = b;
	this.dst = dst;
	if(count == -1 && axes == null || count != -1 && axes != null) {
		throw new js__$Boot_HaxeError("specify either count or axes");
	}
	if(count != -1) {
		var _g = [];
		var _g2 = a.rank - count;
		var _g1 = a.rank;
		while(_g2 < _g1) {
			var i = _g2++;
			_g.push(i);
		}
		this.adummyAxes = _g;
		var _g11 = [];
		var _g3 = 0;
		var _g21 = count;
		while(_g3 < _g21) {
			var i1 = _g3++;
			_g11.push(i1);
		}
		this.bdummyAxes = _g11;
	} else {
		if(axes.length != 2) {
			throw new js__$Boot_HaxeError("invalid argument");
		}
		this.adummyAxes = axes[0];
		this.bdummyAxes = axes[1];
	}
	var _g4 = [];
	var _g22 = 0;
	var _g12 = a.rank;
	while(_g22 < _g12) {
		var i2 = _g22++;
		_g4.push(i2);
	}
	this.afreeAxes = _g4.filter(function(i3) {
		return _gthis.adummyAxes.indexOf(i3) == -1;
	});
	var _g13 = [];
	var _g31 = 0;
	var _g23 = b.rank;
	while(_g31 < _g23) {
		var i4 = _g31++;
		_g13.push(i4);
	}
	this.bfreeAxes = _g13.filter(function(i5) {
		return _gthis.bdummyAxes.indexOf(i5) == -1;
	});
	var _g24 = [];
	var _g41 = 0;
	var _g32 = this.afreeAxes.length;
	while(_g41 < _g32) {
		var i6 = _g41++;
		_g24.push(i6);
	}
	var afreeInDstAxes = _g24;
	var _g33 = [];
	var _g5 = 0;
	var _g42 = this.bfreeAxes.length;
	while(_g5 < _g42) {
		var i7 = _g5++;
		_g33.push(this.afreeAxes.length + i7);
	}
	var bfreeInDstAxes = _g33;
	if(this.adummyAxes.length != this.bdummyAxes.length) {
		throw new js__$Boot_HaxeError("axis sizes mismatch");
	}
	this.axesCheck(this.adummyAxes,a.rank);
	this.axesCheck(this.bdummyAxes,b.rank);
	var adummy = this.adummyAxes.map(function(i8) {
		return "xyzw".charAt(a.rank - 1 - i8);
	});
	var bdummy = this.bdummyAxes.map(function(i9) {
		return "xyzw".charAt(b.rank - 1 - i9);
	});
	var afree = this.afreeAxes.map(function(i10) {
		return "xyzw".charAt(a.rank - 1 - i10);
	});
	var bfree = this.bfreeAxes.map(function(i11) {
		return "xyzw".charAt(b.rank - 1 - i11);
	});
	var afreeInDst = afreeInDstAxes.map(function(i12) {
		return "xyzw".charAt(dst.rank - 1 - i12);
	});
	var bfreeInDst = bfreeInDstAxes.map(function(i13) {
		return "xyzw".charAt(dst.rank - 1 - i13);
	});
	var adummyAll = adummy.join("");
	var bdummyAll = bdummy.join("");
	var afreeAll = afree.join("");
	var bfreeAll = bfree.join("");
	var afreeInDstAll = afreeInDst.join("");
	var bfreeInDstAll = bfreeInDst.join("");
	var hasAfree = afree.length != 0;
	var hasBfree = bfree.length != 0;
	var hasDummy = adummy.length != 0;
	var tmp = "\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 aIdx4 = ivec4(0);\n\t\t\t\t\tivec4 bIdx4 = ivec4(0);\n\n\t\t\t\t\t// assign free indices\n\t\t\t\t" + (hasAfree ? "aIdx4." + afreeAll + " = idx4." + afreeInDstAll + ";\n" : "") + (hasBfree ? "bIdx4." + bfreeAll + " = idx4." + bfreeInDstAll + ";\n" : "") + ("\n\n\t\t\t\t\tint aIdx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint bIdx1Offset = index4To1(bIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(aIdx1Offset, bIdx1Offset);\n\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t") + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[adummy,bdummy],"\n\t\t\t\t\t\telem a = src1(idx1s.x);\n\t\t\t\t\t\telem b = src2(idx1s.y);\n\t\t\t\t\t\tsum += a.value * b.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t";
	this.forwardOps = [this.fop([a,b],dst,"tensordot_forward",tmp)];
	var tmp1 = "\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 dstIdx4 = ivec4(0);\n\t\t\t\t\tivec4 bIdx4 = ivec4(0);\n\n\t\t\t\t\t// assign free and dummy indices\n\t\t\t\t" + (hasAfree ? "dstIdx4." + afreeInDstAll + " = idx4." + afreeAll + ";\n" : "") + (hasDummy ? "bIdx4." + bdummyAll + " = idx4." + adummyAll + ";\n" : "") + ("\n\n\t\t\t\t\tint dstIdx1Offset = index4To1(dstIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint bIdx1Offset = index4To1(bIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(dstIdx1Offset, bIdx1Offset);\n\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t") + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[bfreeInDst,bfree],"\n\t\t\t\t\t\telem dst = src1(idx1s.x);\n\t\t\t\t\t\telem b = src2(idx1s.y);\n\t\t\t\t\t\tsum += dst.diff * b.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t";
	var tmp2 = this.bop([dst,b],a,"tensordot_backward_a",tmp1);
	var tmp3 = "\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\tivec4 dstIdx4 = ivec4(0);\n\t\t\t\t\tivec4 aIdx4 = ivec4(0);\n\n\t\t\t\t\t// assign free and dummy indices\n\t\t\t\t" + (hasBfree ? "dstIdx4." + bfreeInDstAll + " = idx4." + bfreeAll + ";\n" : "") + (hasDummy ? "aIdx4." + adummyAll + " = idx4." + bdummyAll + ";\n" : "") + ("\n\n\t\t\t\t\tint dstIdx1Offset = index4To1(dstIdx4, " + ("uSrcShape" + "1") + ");\n\t\t\t\t\tint aIdx1Offset = index4To1(aIdx4, " + ("uSrcShape" + "2") + ");\n\n\t\t\t\t\tivec2 idx1Offsets = ivec2(dstIdx1Offset, aIdx1Offset);\n\n\t\t\t\t\tfloat sum = 0.0;\n\t\t\t\t") + webdl_core_backend_gpu_GpuShader.loopOverDimensions("idx1s","idx1Offsets",[1,2],[afreeInDst,afree],"\n\t\t\t\t\t\telem dst = src1(idx1s.x);\n\t\t\t\t\t\telem a = src2(idx1s.y);\n\t\t\t\t\t\tsum += dst.diff * a.value;\n\t\t\t\t\t") + "\n\t\t\t\t\treturn sum;\n\t\t\t\t}\n\t\t\t";
	this.backwardOps = [tmp2,this.bop([dst,a],b,"tensordot_backward_b",tmp3)];
};
webdl_core_backend_gpu_operation_GpuTensorDotOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuTensorDotOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuTensorDotOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	axesCheck: function(axes,rank) {
		if(axes.length > rank) {
			throw new js__$Boot_HaxeError("too many axes");
		}
		var _g1 = 0;
		var _g = axes.length;
		while(_g1 < _g) {
			var i = _g1++;
			if(axes[i] < 0 || axes[i] >= rank) {
				throw new js__$Boot_HaxeError("invalid axis");
			}
			var _g3 = 0;
			var _g2 = i;
			while(_g3 < _g2) {
				var j = _g3++;
				if(axes[i] == axes[j]) {
					throw new js__$Boot_HaxeError("duplicate axes");
				}
			}
		}
	}
	,shapeCheck: function() {
		if(this.adummyAxes.length != this.bdummyAxes.length) {
			throw new js__$Boot_HaxeError("!?");
		}
		var _g1 = 0;
		var _g = this.adummyAxes.length;
		while(_g1 < _g) {
			var i = _g1++;
			var adummySize = this.a.actualShape[this.adummyAxes[i]];
			var bdummySize = this.b.actualShape[this.bdummyAxes[i]];
			if(adummySize == -1 || bdummySize == -1) {
				throw new js__$Boot_HaxeError("no data assigned");
			}
			if(adummySize != bdummySize) {
				throw new js__$Boot_HaxeError("cannot multiply tensors");
			}
		}
		var dstShape = [];
		var _g2 = 0;
		var _g11 = this.afreeAxes;
		while(_g2 < _g11.length) {
			var i1 = _g11[_g2];
			++_g2;
			dstShape.push(this.a.actualShape[i1]);
		}
		var _g3 = 0;
		var _g12 = this.bfreeAxes;
		while(_g3 < _g12.length) {
			var i2 = _g12[_g3];
			++_g3;
			dstShape.push(this.b.actualShape[i2]);
		}
		this.dst.assignShape(dstShape);
	}
});
var webdl_core_backend_gpu_operation_GpuWhereOperation = function(backend,cond,a,b,dst) {
	webdl_core_backend_gpu_operation_GpuOperation.call(this,backend,[cond,a,b],[dst]);
	this.cond = cond;
	this.a = a;
	this.b = b;
	this.dst = dst;
	this.forwardOps = [this.fop([cond,a,b],dst,"where_forward","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem cond = src1(idx4);\n\t\t\t\t\telem a = src2(idx4);\n\t\t\t\t\telem b = src3(idx4);\n\t\t\t\t\treturn cond.value > 0.5 ? a.value : b.value;\n\t\t\t\t}\n\t\t\t")];
	this.backwardOps = [this.bop([dst,cond],a,"where_backward_a","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem cond = src2(idx4);\n\t\t\t\t\treturn cond.value > 0.5 ? dst.diff : 0.0;\n\t\t\t\t}\n\t\t\t"),this.bop([dst,cond],b,"where_backward_b","\n\t\t\t\tfloat run(ivec4 idx4) {\n\t\t\t\t\telem dst = src1(idx4);\n\t\t\t\t\telem cond = src2(idx4);\n\t\t\t\t\treturn cond.value > 0.5 ? 0.0 : dst.diff;\n\t\t\t\t}\n\t\t\t")];
};
webdl_core_backend_gpu_operation_GpuWhereOperation.__name__ = true;
webdl_core_backend_gpu_operation_GpuWhereOperation.__super__ = webdl_core_backend_gpu_operation_GpuOperation;
webdl_core_backend_gpu_operation_GpuWhereOperation.prototype = $extend(webdl_core_backend_gpu_operation_GpuOperation.prototype,{
	shapeCheck: function() {
		this.shapeEq(this.a.actualShape,this.b.actualShape);
		this.dst.assignShape(this.a.actualShape.slice(0));
	}
});
var webdl_core_graph_Edge = function(operation) {
	this.operation = operation;
	var this1 = operation.inputs;
	var length = this1.length;
	var this2 = new Array(length);
	var r = this2;
	var len = length;
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		var v = this1[i].node;
		r[i] = v;
	}
	this.inputs = r;
	var this3 = operation.outputs;
	var length1 = this3.length;
	var this4 = new Array(length1);
	var r1 = this4;
	var len1 = length1;
	var _g11 = 0;
	var _g2 = len1;
	while(_g11 < _g2) {
		var i1 = _g11++;
		var v1 = this3[i1].node;
		r1[i1] = v1;
	}
	this.outputs = r1;
	var _g3 = 0;
	var _g12 = this.inputs;
	while(_g3 < _g12.length) {
		var n = _g12[_g3];
		++_g3;
		if(n.outputs.indexOf(this) == -1) {
			n.outputs.push(this);
		}
	}
	var _g4 = 0;
	var _g13 = this.outputs;
	while(_g4 < _g13.length) {
		var n1 = _g13[_g4];
		++_g4;
		if(n1.input != null) {
			throw new js__$Boot_HaxeError("outputs conflict");
		}
		n1.input = this;
	}
	this.time = -1;
};
webdl_core_graph_Edge.__name__ = true;
webdl_core_graph_Edge.prototype = {
	collectForward: function(time,nodes,edges) {
		if(this.time == time) {
			return;
		}
		this.time = time;
		var _g = 0;
		var _g1 = this.outputs;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			n.collectForward(time,nodes,edges);
		}
		var _g2 = 0;
		var _g11 = this.inputs;
		while(_g2 < _g11.length) {
			var n1 = _g11[_g2];
			++_g2;
			n1.collectForward(time,nodes,edges);
		}
		edges.push(this);
	}
	,collectBackward: function(time,queue,edges) {
		if(this.time == time) {
			return;
		}
		this.time = time;
		edges.push(this);
		var _g = 0;
		var _g1 = this.inputs;
		while(_g < _g1.length) {
			var n = _g1[_g];
			++_g;
			if(!n.inQueue) {
				queue.push(n);
				n.inQueue = true;
			}
		}
	}
	,run: function() {
		this.operation.run();
	}
	,onAfterRun: function() {
		this.operation.onAfterRun();
	}
	,backward: function() {
		this.operation.backwardRun();
	}
};
var webdl_core_graph_Graph = function() { };
webdl_core_graph_Graph.__name__ = true;
webdl_core_graph_Graph.run = function(nodes) {
	var unused = [];
	var edges = [];
	webdl_core_graph_Graph.time++;
	var _g = 0;
	while(_g < nodes.length) {
		var n = nodes[_g];
		++_g;
		n.collectForward(webdl_core_graph_Graph.time,unused,edges);
	}
	var _g1 = 0;
	while(_g1 < edges.length) {
		var e = edges[_g1];
		++_g1;
		e.run();
	}
	var _g2 = 0;
	while(_g2 < edges.length) {
		var e1 = edges[_g2];
		++_g2;
		e1.onAfterRun();
	}
};
webdl_core_graph_Graph.backprop = function(y) {
	var nodes = [];
	var unused = [];
	var edges = [];
	webdl_core_graph_Graph.time++;
	y.collectForward(webdl_core_graph_Graph.time,nodes,unused);
	webdl_core_graph_Graph.time++;
	var queue = [];
	queue.push(y);
	while(queue.length > 0) {
		var n = queue.shift();
		n.collectBackward(webdl_core_graph_Graph.time,queue,edges);
	}
	var _g = 0;
	while(_g < nodes.length) {
		var n1 = nodes[_g];
		++_g;
		if(n1 != y) {
			n1.tensor.fillDiff(0);
		}
	}
	var _g1 = 0;
	while(_g1 < edges.length) {
		var e = edges[_g1];
		++_g1;
		e.backward();
	}
};
webdl_core_graph_Graph.collectNodesConcerned = function(nodes) {
	var res = [];
	var unused = [];
	webdl_core_graph_Graph.time++;
	var _g = 0;
	while(_g < nodes.length) {
		var n = nodes[_g];
		++_g;
		n.collectForward(webdl_core_graph_Graph.time,res,unused);
	}
	return res;
};
var webdl_core_graph_Node = function(tensor) {
	this.tensor = tensor;
	this.input = null;
	this.outputs = [];
	this.inQueue = false;
	this.time = -1;
};
webdl_core_graph_Node.__name__ = true;
webdl_core_graph_Node.prototype = {
	collectForward: function(time,nodes,edges) {
		if(this.time == time) {
			return;
		}
		this.time = time;
		this.inQueue = false;
		nodes.push(this);
		if(this.input != null) {
			this.input.collectForward(time,nodes,edges);
		}
	}
	,collectBackward: function(time,queue,edges) {
		if(this.time == time) {
			return;
		}
		this.time = time;
		if(this.input != null) {
			this.input.collectBackward(time,queue,edges);
		}
	}
};
var webdl_core_layer_Layer = function() {
	this.updates = [];
};
webdl_core_layer_Layer.__name__ = true;
webdl_core_layer_Layer.prototype = {
	init: function() {
	}
};
var webdl_core_layer_BatchNormalizationLayer = function(a,isTraining,batchAxis,momentum,epsilon) {
	if(epsilon == null) {
		epsilon = 1e-6;
	}
	if(momentum == null) {
		momentum = 0.95;
	}
	webdl_core_layer_Layer.call(this);
	this.input = a;
	this.batchMean = webdl_core_WebDL.reduceMean(a,batchAxis,true);
	this.batchVariance = webdl_core_WebDL.reduceMean(webdl_core_WebDL.square(webdl_core_WebDL.sub(a,this.batchMean)),batchAxis,true);
	this.popMean = webdl_core_WebDL.tensorLike(this.batchMean);
	this.popVariance = webdl_core_WebDL.tensorLike(this.batchMean);
	this.beta = webdl_core_WebDL.tensorLike(this.batchMean);
	this.scale = webdl_core_WebDL.tensorLike(this.batchMean);
	this.popMean.fill(0);
	this.popVariance.fill(1);
	this.beta.fill(0);
	this.scale.fill(1);
	var trainMean = webdl_core_WebDL.assign(this.popMean,webdl_core_WebDL.linComb(this.popMean,this.batchMean,momentum,1 - momentum));
	var trainVariance = webdl_core_WebDL.assign(this.popVariance,webdl_core_WebDL.linComb(this.popVariance,this.batchVariance,momentum,1 - momentum));
	this.updates = [trainMean,trainVariance];
	this.popMean.shouldBeSaved = true;
	this.popVariance.shouldBeSaved = true;
	this.scale.trainable = true;
	this.scale.shouldBeSaved = true;
	this.beta.trainable = true;
	this.beta.doNotDecay = true;
	this.beta.shouldBeSaved = true;
	var out1 = webdl_core_WebDL.add(webdl_core_WebDL.mul(webdl_core_WebDL.mul(webdl_core_WebDL.sub(a,this.batchMean),webdl_core_WebDL.powConst(webdl_core_WebDL.addConst(this.batchVariance,epsilon),-0.5)),this.scale),this.beta);
	var out2 = webdl_core_WebDL.add(webdl_core_WebDL.mul(webdl_core_WebDL.mul(webdl_core_WebDL.sub(a,this.popMean),webdl_core_WebDL.powConst(webdl_core_WebDL.addConst(this.popVariance,epsilon),-0.5)),this.scale),this.beta);
	this.output = webdl_core_WebDL.where(isTraining,out1,out2);
};
webdl_core_layer_BatchNormalizationLayer.__name__ = true;
webdl_core_layer_BatchNormalizationLayer.__super__ = webdl_core_layer_Layer;
webdl_core_layer_BatchNormalizationLayer.prototype = $extend(webdl_core_layer_Layer.prototype,{
	init: function() {
		this.popMean.fill(0);
		this.popVariance.fill(1);
	}
});
var webdl_core_layer_DenseLayer = function(a,unit,activation,initializer,useBias) {
	if(useBias == null) {
		useBias = true;
	}
	if(activation == null) {
		activation = 0;
	}
	webdl_core_layer_Layer.call(this);
	this.input = a;
	if(initializer == null) {
		initializer = activation == 3 ? new webdl_core_nn_HeInitializer() : new webdl_core_nn_XavierInitializer();
	}
	this.initializer = initializer;
	var outputShape = a.shape.slice(0);
	outputShape[a.rank - 1] = unit;
	this.output = webdl_core_WebDL.tensorOfShape(outputShape);
	this.kernelIn = a.shape[a.rank - 1];
	var kernelOut = unit;
	if(this.kernelIn == -1) {
		throw new js__$Boot_HaxeError("the size of the last dimension of the input tensor must be known at the layer constructor");
	}
	this.kernel = webdl_core_WebDL.tensorOfShape([this.kernelIn,kernelOut]);
	this.kernel.trainable = true;
	this.kernel.shouldBeSaved = true;
	if(useBias) {
		this.bias = webdl_core_WebDL.tensorOfShape([kernelOut]);
		this.bias.trainable = true;
		this.bias.shouldBeSaved = true;
		this.bias.doNotDecay = true;
		this.output = webdl_core_WebDL.biasAdd(webdl_core_WebDL.tensorDot(a,this.kernel,1),this.bias);
	} else {
		this.bias = null;
		this.output = webdl_core_WebDL.tensorDot(a,this.kernel,1);
	}
	if(activation != 0) {
		this.output = webdl_core_WebDL.activation(this.output,activation);
	}
};
webdl_core_layer_DenseLayer.__name__ = true;
webdl_core_layer_DenseLayer.__super__ = webdl_core_layer_Layer;
webdl_core_layer_DenseLayer.prototype = $extend(webdl_core_layer_Layer.prototype,{
	init: function() {
		this.initializer.numInputs = this.kernelIn;
		this.kernel.fillByGenerator(($_=this.initializer,$bind($_,$_.next)));
		if(this.bias != null) {
			this.bias.fillByGenerator(($_=this.initializer,$bind($_,$_.next)));
		}
	}
});
var webdl_core_nn_Initializer = function() { };
webdl_core_nn_Initializer.__name__ = true;
var webdl_core_nn_HeInitializer = function() {
};
webdl_core_nn_HeInitializer.__name__ = true;
webdl_core_nn_HeInitializer.__interfaces__ = [webdl_core_nn_Initializer];
webdl_core_nn_HeInitializer.prototype = {
	next: function() {
		return Math.sqrt(-2 * (2 / this.numInputs) * Math.log(Math.random())) * Math.sin(2 * Math.PI * Math.random());
	}
};
var webdl_core_nn_UniformInitializer = function(range) {
	this.range = range;
};
webdl_core_nn_UniformInitializer.__name__ = true;
webdl_core_nn_UniformInitializer.__interfaces__ = [webdl_core_nn_Initializer];
webdl_core_nn_UniformInitializer.prototype = {
	next: function() {
		var min = -this.range;
		var max = this.range;
		return Math.random() * (max - min) + min;
	}
};
var webdl_core_nn_XavierInitializer = function() {
};
webdl_core_nn_XavierInitializer.__name__ = true;
webdl_core_nn_XavierInitializer.__interfaces__ = [webdl_core_nn_Initializer];
webdl_core_nn_XavierInitializer.prototype = {
	next: function() {
		return Math.sqrt(-2 * (1 / this.numInputs) * Math.log(Math.random())) * Math.sin(2 * Math.PI * Math.random());
	}
};
var webdl_core_optimizer_Optimizer = function(trainables,grads) {
	this.trainables = trainables;
	this.grads = grads;
	if(trainables.length != grads.length) {
		throw new js__$Boot_HaxeError("invalid arguments");
	}
};
webdl_core_optimizer_Optimizer.__name__ = true;
webdl_core_optimizer_Optimizer.prototype = {
	run: function() {
	}
	,exportData: function() {
		return [];
	}
	,importData: function(data) {
	}
};
var webdl_core_optimizer_AdamOptimizer = function(trainables,grads,alpha,beta1,beta2,epsilon) {
	if(epsilon == null) {
		epsilon = 1e-8;
	}
	if(beta2 == null) {
		beta2 = 0.999;
	}
	if(beta1 == null) {
		beta1 = 0.9;
	}
	if(alpha == null) {
		alpha = 0.001;
	}
	webdl_core_optimizer_Optimizer.call(this,trainables,grads);
	this.adamUpdates = [];
	var count = webdl_core_WebDL.tensorOfValue(0);
	var updatedCount = webdl_core_WebDL.assign(count,webdl_core_WebDL.addConst(count,1));
	var alphaTensor = webdl_core_WebDL.tensorOfValue(alpha);
	var beta1Tensor = webdl_core_WebDL.tensorOfValue(beta1);
	var beta2Tensor = webdl_core_WebDL.tensorOfValue(beta2);
	var epsilonTensor = webdl_core_WebDL.tensorOfValue(epsilon);
	var zero = webdl_core_WebDL.tensorOfValue(0);
	this.l2Decay = webdl_core_WebDL.tensorOfValue(0);
	this.internalTensors = [count,alphaTensor,beta1Tensor,beta2Tensor,epsilonTensor,this.l2Decay];
	var num = trainables.length;
	var _g1 = 0;
	var _g = num;
	while(_g1 < _g) {
		var i = _g1++;
		var t = trainables[i];
		var g = grads[i];
		var m = webdl_core_WebDL.tensorLike(t);
		var v = webdl_core_WebDL.tensorLike(t);
		this.internalTensors.push(m);
		this.internalTensors.push(v);
		var update = webdl_core_WebDL.adamUpdate(updatedCount,t,g,m,v,alphaTensor,beta1Tensor,beta2Tensor,epsilonTensor,t.doNotDecay ? zero : this.l2Decay);
		this.adamUpdates.push(update);
	}
};
webdl_core_optimizer_AdamOptimizer.__name__ = true;
webdl_core_optimizer_AdamOptimizer.__super__ = webdl_core_optimizer_Optimizer;
webdl_core_optimizer_AdamOptimizer.prototype = $extend(webdl_core_optimizer_Optimizer.prototype,{
	setL2Decay: function(decay) {
		this.l2Decay.set0D(decay);
	}
	,run: function() {
		webdl_core_WebDL.run(this.adamUpdates);
	}
	,exportData: function() {
		return webdl_core_WebDL.exportElements(this.internalTensors);
	}
	,importData: function(data) {
		webdl_core_WebDL.importElements(this.internalTensors,data);
	}
});
var webdl_rl_ddpg_Actor = function(network,targetNetwork) {
	this.network = network;
	this.targetNetwork = targetNetwork;
	if(network == targetNetwork) {
		throw new js__$Boot_HaxeError("network and target network must not be the same instance");
	}
	if(network.stateDim != targetNetwork.stateDim || network.actionDim != targetNetwork.actionDim || network.trainables.length != targetNetwork.trainables.length || network.tensorsToSave.length != targetNetwork.tensorsToSave.length) {
		throw new js__$Boot_HaxeError("dimensions mismatch between network and target network");
	}
	this.stateDim = network.stateDim;
	this.actionDim = network.actionDim;
};
webdl_rl_ddpg_Actor.__name__ = true;
webdl_rl_ddpg_Actor.createActor = function(stateDim,actionDim,numNeuronsInHiddenLayers,actionRanges,finalLayerWeight,batchNormalization) {
	if(batchNormalization == null) {
		batchNormalization = false;
	}
	if(finalLayerWeight == null) {
		finalLayerWeight = 0.003;
	}
	var network = webdl_rl_ddpg_Actor.createNetwork(stateDim,actionDim,numNeuronsInHiddenLayers,actionRanges,finalLayerWeight,batchNormalization);
	var targetNetwork = webdl_rl_ddpg_Actor.createNetwork(stateDim,actionDim,numNeuronsInHiddenLayers,actionRanges,finalLayerWeight,batchNormalization);
	return new webdl_rl_ddpg_Actor(network,targetNetwork);
};
webdl_rl_ddpg_Actor.createNetwork = function(stateDim,actionDim,numNeuronsInHiddenLayers,actionRanges,finalLayerWeight,batchNormalization) {
	var inState = webdl_core_WebDL.tensorOfShape([-1,stateDim]);
	var layers = [];
	var layer;
	var outTensor = inState;
	var inDim = stateDim;
	var isTraining = webdl_core_WebDL.tensorOfValue(0);
	var updates = [];
	var _g = 0;
	while(_g < numNeuronsInHiddenLayers.length) {
		var unit = numNeuronsInHiddenLayers[_g];
		++_g;
		if(batchNormalization) {
			layer = new webdl_core_layer_DenseLayer(outTensor,unit,0,new webdl_core_nn_UniformInitializer(1 / Math.sqrt(inDim)),false);
			layers.push(layer);
			outTensor = layer.output;
			var bn = new webdl_core_layer_BatchNormalizationLayer(outTensor,isTraining,0);
			updates = updates.concat(bn.updates);
			outTensor = webdl_core_WebDL.activation(bn.output,3);
			batchNormalization = false;
		} else {
			layer = new webdl_core_layer_DenseLayer(outTensor,unit,3,new webdl_core_nn_UniformInitializer(1 / Math.sqrt(inDim)));
			layers.push(layer);
			outTensor = layer.output;
		}
		inDim = unit;
	}
	layer = new webdl_core_layer_DenseLayer(outTensor,actionDim,1,new webdl_core_nn_UniformInitializer(finalLayerWeight));
	layers.push(layer);
	outTensor = layer.output;
	var _g1 = [];
	var _g11 = 0;
	while(_g11 < actionRanges.length) {
		var range = actionRanges[_g11];
		++_g11;
		_g1.push(0.5 * (range[0] + range[1]));
	}
	var outBias = webdl_core_WebDL.tensorOfValue([_g1]);
	var _g12 = [];
	var _g2 = 0;
	while(_g2 < actionRanges.length) {
		var range1 = actionRanges[_g2];
		++_g2;
		_g12.push(0.5 * (range1[1] - range1[0]));
	}
	var outScale = webdl_core_WebDL.tensorOfValue([_g12]);
	var outAction = webdl_core_WebDL.add(webdl_core_WebDL.mul(outTensor,outScale),outBias);
	return new webdl_rl_ddpg_ActorNetwork(layers,inState,outAction,stateDim,actionDim,updates,isTraining);
};
var webdl_rl_ddpg_ActorNetwork = function(layers,inState,outAction,stateDim,actionDim,updates,isTraining) {
	this.layers = layers;
	this.inState = inState;
	this.outAction = outAction;
	this.stateDim = stateDim;
	this.actionDim = actionDim;
	this.updates = updates;
	this.isTraining = isTraining;
	this.trainables = webdl_core_WebDL.getTrainableVariables([outAction]);
	this.tensorsToSave = webdl_core_WebDL.getTensorsToSave([outAction]);
	var _g = 0;
	while(_g < layers.length) {
		var layer = layers[_g];
		++_g;
		layer.init();
	}
};
webdl_rl_ddpg_ActorNetwork.__name__ = true;
webdl_rl_ddpg_ActorNetwork.prototype = {
	dump: function() {
		console.log("src/webdl/rl/ddpg/ActorNetwork.hx:34:","actor network info");
		var _g = 0;
		var _g1 = this.layers;
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			console.log("src/webdl/rl/ddpg/ActorNetwork.hx:36:","kernel: " + layer.kernel.print());
			console.log("src/webdl/rl/ddpg/ActorNetwork.hx:37:","bias: " + layer.bias.print());
		}
	}
};
var webdl_rl_ddpg_BytesTools = function() { };
webdl_rl_ddpg_BytesTools.__name__ = true;
webdl_rl_ddpg_BytesTools.writeFloatArray = function(bo,array) {
	bo.writeInt32(array.length);
	var _g = 0;
	while(_g < array.length) {
		var a = array[_g];
		++_g;
		if(!isFinite(a)) {
			throw new js__$Boot_HaxeError("float must be finite");
		}
		bo.writeFloat(a);
	}
};
webdl_rl_ddpg_BytesTools.readFloatArray = function(bi) {
	var len = bi.readInt32();
	var res = [];
	var _g1 = 0;
	var _g = len;
	while(_g1 < _g) {
		var i = _g1++;
		var a = bi.readFloat();
		if(!isFinite(a)) {
			throw new js__$Boot_HaxeError("float must be finite");
		}
		if(Math.abs(a) > 1e+37) {
			a = 0;
		}
		res.push(a);
	}
	return res;
};
var webdl_rl_ddpg_Critic = function(network,targetNetwork) {
	this.network = network;
	this.targetNetwork = targetNetwork;
	if(network == targetNetwork) {
		throw new js__$Boot_HaxeError("network and target network must not be the same instance");
	}
	if(network.stateDim != targetNetwork.stateDim || network.actionDim != targetNetwork.actionDim || network.trainables.length != targetNetwork.trainables.length || network.tensorsToSave.length != targetNetwork.tensorsToSave.length) {
		throw new js__$Boot_HaxeError("dimensions mismatch between network and target network");
	}
	this.stateDim = network.stateDim;
	this.actionDim = network.actionDim;
};
webdl_rl_ddpg_Critic.__name__ = true;
webdl_rl_ddpg_Critic.createCritic = function(stateDim,actionDim,numNeuronsInHiddenLayers,finalLayerWeight,batchNormalization) {
	if(batchNormalization == null) {
		batchNormalization = false;
	}
	if(finalLayerWeight == null) {
		finalLayerWeight = 0.003;
	}
	var network = webdl_rl_ddpg_Critic.createNetwork(stateDim,actionDim,numNeuronsInHiddenLayers,finalLayerWeight,batchNormalization);
	var targetNetwork = webdl_rl_ddpg_Critic.createNetwork(stateDim,actionDim,numNeuronsInHiddenLayers,finalLayerWeight,batchNormalization);
	return new webdl_rl_ddpg_Critic(network,targetNetwork);
};
webdl_rl_ddpg_Critic.createNetwork = function(stateDim,actionDim,numNeuronsInHiddenLayers,finalLayerWeight,batchNormalization) {
	var inState = webdl_core_WebDL.tensorOfShape([-1,stateDim]);
	var inAction = webdl_core_WebDL.tensorOfShape([-1,actionDim]);
	var layers = [];
	var layer;
	var outTensor = inState;
	var inDim = stateDim;
	var isTraining = webdl_core_WebDL.tensorOfValue(0);
	var updates = [];
	var _g1 = 0;
	var _g = numNeuronsInHiddenLayers.length;
	while(_g1 < _g) {
		var i = _g1++;
		var unit = numNeuronsInHiddenLayers[i];
		var activ = batchNormalization ? 0 : 3;
		if(i == 1 || i == 0 && numNeuronsInHiddenLayers.length == 1) {
			inDim += actionDim;
			layer = new webdl_core_layer_DenseLayer(webdl_core_WebDL.merge([outTensor,inAction],1),unit,activ,new webdl_core_nn_UniformInitializer(1 / Math.sqrt(inDim)),!batchNormalization);
		} else {
			layer = new webdl_core_layer_DenseLayer(outTensor,unit,activ,new webdl_core_nn_UniformInitializer(1 / Math.sqrt(inDim)),!batchNormalization);
		}
		layers.push(layer);
		outTensor = layer.output;
		if(batchNormalization) {
			var bn = new webdl_core_layer_BatchNormalizationLayer(outTensor,isTraining,0);
			updates = updates.concat(bn.updates);
			outTensor = webdl_core_WebDL.activation(bn.output,3);
			batchNormalization = false;
		}
		inDim = unit;
	}
	layer = new webdl_core_layer_DenseLayer(outTensor,1,0,new webdl_core_nn_UniformInitializer(finalLayerWeight));
	layers.push(layer);
	var outValue = webdl_core_WebDL.reduceSum(layer.output,1);
	return new webdl_rl_ddpg_CriticNetwork(layers,inState,inAction,outValue,stateDim,actionDim,updates,isTraining);
};
var webdl_rl_ddpg_CriticNetwork = function(layers,inState,inAction,outValue,stateDim,actionDim,updates,isTraining) {
	this.layers = layers;
	this.inState = inState;
	this.inAction = inAction;
	this.outValue = outValue;
	this.stateDim = stateDim;
	this.actionDim = actionDim;
	this.updates = updates;
	this.isTraining = isTraining;
	this.trainables = webdl_core_WebDL.getTrainableVariables([outValue]);
	this.tensorsToSave = webdl_core_WebDL.getTensorsToSave([outValue]);
	var _g = 0;
	while(_g < layers.length) {
		var layer = layers[_g];
		++_g;
		layer.init();
	}
};
webdl_rl_ddpg_CriticNetwork.__name__ = true;
webdl_rl_ddpg_CriticNetwork.prototype = {
	dump: function() {
		console.log("src/webdl/rl/ddpg/CriticNetwork.hx:36:","critic network info");
		var _g = 0;
		var _g1 = this.layers;
		while(_g < _g1.length) {
			var layer = _g1[_g];
			++_g;
			console.log("src/webdl/rl/ddpg/CriticNetwork.hx:38:","kernel: " + layer.kernel.print());
			console.log("src/webdl/rl/ddpg/CriticNetwork.hx:39:","bias: " + layer.bias.print());
		}
	}
};
var webdl_rl_ddpg_DDPG = function(ddpgSetting) {
	var actionRanges = ddpgSetting.actionRanges;
	this.stateDim = ddpgSetting.stateDim;
	this.actionDim = actionRanges.length;
	var numHiddenLayers = ddpgSetting.numHiddenLayers;
	var numHiddenUnits = ddpgSetting.numHiddenUnits;
	var tmp = this.stateDim;
	var tmp1 = this.actionDim;
	var _g = [];
	var _g2 = 0;
	var _g1 = numHiddenLayers;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(numHiddenUnits);
	}
	this.actor = webdl_rl_ddpg_Actor.createActor(tmp,tmp1,_g,actionRanges);
	var tmp2 = this.stateDim;
	var tmp3 = this.actionDim;
	var _g11 = [];
	var _g3 = 0;
	var _g21 = numHiddenLayers;
	while(_g3 < _g21) {
		var i1 = _g3++;
		_g11.push(numHiddenUnits);
	}
	this.critic = webdl_rl_ddpg_Critic.createCritic(tmp2,tmp3,_g11);
	this.agent = ddpgSetting.agent;
	this.maxEpisodeTime = ddpgSetting.maxEpisodeLength;
	this.noise = new webdl_rl_ddpg_OrnsteinUhlenbeckNoise(this.actionDim,0,ddpgSetting.noiseTheta,ddpgSetting.noiseSigma);
	this.prioritizedExperienceReplay = ddpgSetting.prioritizedReplay;
	this.gamma = ddpgSetting.gamma;
	this.tau = ddpgSetting.targetUpdateTau;
	this.updateInterval = ddpgSetting.updateInterval;
	this.rewardScaleFactor = ddpgSetting.rewardScaleFactor;
	this.applyNoise = ddpgSetting.noise;
	this.playingMode = ddpgSetting.evaluation;
	this.normalizeObserbation = ddpgSetting.normalizeObserbation;
	this.replayBufferSize = ddpgSetting.replayBufferSize;
	this.minibatchSize = ddpgSetting.minibatchSize;
	this.startReplay = ddpgSetting.startReplay;
	var aNet = this.actor.network;
	var cNet = this.critic.network;
	var aTargetNet = this.actor.targetNetwork;
	var cTargetNet = this.critic.targetNetwork;
	if(this.actor.stateDim != this.critic.stateDim) {
		throw new js__$Boot_HaxeError("state dimensions between actor and critic mismatch");
	}
	if(this.actor.actionDim != this.critic.actionDim) {
		throw new js__$Boot_HaxeError("action dimensions between actor and critic mismatch");
	}
	this.actionDim = this.actor.actionDim;
	this.stateDim = this.actor.stateDim;
	this.stateMeanStd = new webdl_rl_ddpg_MeanStdTracker([1,this.stateDim]);
	var normalizedActionGradient = webdl_core_WebDL.tensorOfShape([-1,this.actionDim]);
	var predictedQValue = webdl_core_WebDL.tensorOfShape([-1]);
	this.unnormalizedState = webdl_core_WebDL.tensorOfShape([-1,this.stateDim]);
	this.criticMiniBatchReward = webdl_core_WebDL.tensorOfShape([-1]);
	this.criticMiniBatchNotDone = webdl_core_WebDL.tensorOfShape([-1]);
	this.criticMiniBatchTdError = webdl_core_WebDL.tensorOfShape([-1]);
	var normalizedState = webdl_core_WebDL.div(webdl_core_WebDL.sub(this.unnormalizedState,this.stateMeanStd.mean),this.stateMeanStd.std);
	this.assignNormalizedStateToActor = webdl_core_WebDL.assign(aNet.inState,normalizedState);
	this.assignNormalizedStateToCritic = webdl_core_WebDL.assign(cNet.inState,normalizedState);
	this.assignNormalizedStateToActorTarget = webdl_core_WebDL.assign(aTargetNet.inState,normalizedState);
	this.assignNormalizedStateToCriticTarget = webdl_core_WebDL.assign(cTargetNet.inState,normalizedState);
	var unnormalizedActionGradient = webdl_core_WebDL.mulConst(webdl_core_WebDL.gradients(cNet.outValue,[cNet.inAction])[0],-1);
	normalizedActionGradient = webdl_core_WebDL.mulConst(unnormalizedActionGradient,1 / this.minibatchSize);
	var policyGrads = webdl_core_WebDL.gradients(aNet.outAction,aNet.trainables,normalizedActionGradient);
	this.actorOptimizer = new webdl_core_optimizer_AdamOptimizer(aNet.trainables,policyGrads,ddpgSetting.actorLearningRate);
	this.actorOptimizer.setL2Decay(ddpgSetting.actorWeightDecay);
	this.predictAction = [webdl_core_WebDL.assign(cTargetNet.inAction,aTargetNet.outAction)];
	this.predictQValue = [webdl_core_WebDL.assign(predictedQValue,webdl_core_WebDL.add(webdl_core_WebDL.mul(webdl_core_WebDL.mulConst(cTargetNet.outValue,this.gamma),this.criticMiniBatchNotDone),this.criticMiniBatchReward))];
	var tdError = webdl_core_WebDL.assign(this.criticMiniBatchTdError,webdl_core_WebDL.sub(predictedQValue,cNet.outValue));
	var criticLoss = webdl_core_WebDL.reduceMean(webdl_core_WebDL.square(tdError),0);
	var criticGradients = webdl_core_WebDL.gradients(criticLoss,cNet.trainables);
	this.criticOptimizer = new webdl_core_optimizer_AdamOptimizer(cNet.trainables,criticGradients,ddpgSetting.criticLearningRate);
	this.criticOptimizer.setL2Decay(ddpgSetting.criticWeightDecay);
	var allTensorsToSave = aNet.trainables.concat(cNet.tensorsToSave);
	var allTargetTensorsToSave = aTargetNet.trainables.concat(cTargetNet.tensorsToSave);
	this.initTargetNetworksOps = [];
	this.updateTargetNetworksOps = [];
	var _g31 = 0;
	var _g22 = allTensorsToSave.length;
	while(_g31 < _g22) {
		var i2 = _g31++;
		var t = allTensorsToSave[i2];
		var tTarget = allTargetTensorsToSave[i2];
		this.initTargetNetworksOps.push(webdl_core_WebDL.assign(tTarget,t));
		this.updateTargetNetworksOps.push(webdl_core_WebDL.assign(tTarget,webdl_core_WebDL.linComb(t,tTarget,this.tau,1 - this.tau)));
	}
	if(this.prioritizedExperienceReplay) {
		this.prioritizedReplayBuffer = new webdl_rl_ddpg_er_PrioritizedReplayBuffer(this.replayBufferSize);
	} else {
		this.replayBuffer = new webdl_rl_ddpg_er_ReplayBuffer(this.replayBufferSize);
	}
	this.lastState = this.agent.reset();
	this.episode = 0;
	this.episodeTime = 0;
	this.totalReward = 0;
	this.totalRewardInLastEpisode = 0;
	this.totalRewards = [];
	this.numSteps = 0;
	this.experiences = null;
	this.continueFromData = false;
	webdl_core_WebDL.run(this.initTargetNetworksOps);
};
webdl_rl_ddpg_DDPG.__name__ = true;
webdl_rl_ddpg_DDPG.prototype = {
	computeActions: function(states) {
		this.unnormalizedState.set2D(states);
		webdl_core_WebDL.run([this.assignNormalizedStateToActor]);
		webdl_core_WebDL.run([this.actor.network.outAction]);
		return this.actor.network.outAction.get2D();
	}
	,computeValues: function(states,actions) {
		this.unnormalizedState.set2D(states);
		webdl_core_WebDL.run([this.assignNormalizedStateToCritic]);
		this.critic.network.inAction.set2D(actions);
		webdl_core_WebDL.run([this.critic.network.outValue]);
		return this.critic.network.outValue.get1D();
	}
	,step: function(disableEarlyReset) {
		if(disableEarlyReset == null) {
			disableEarlyReset = false;
		}
		this.numSteps++;
		this.unnormalizedState.set2D([this.lastState]);
		webdl_core_WebDL.run([this.assignNormalizedStateToActor,this.assignNormalizedStateToCritic]);
		webdl_core_WebDL.run([this.actor.network.outAction]);
		this.lastActionWithoutNoise = this.actor.network.outAction.get2D()[0];
		this.critic.network.inAction.set2D([this.lastActionWithoutNoise]);
		webdl_core_WebDL.run([this.critic.network.outValue]);
		this.lastValueWithoutNoise = this.critic.network.outValue.get1D()[0];
		var bufferSize = this.prioritizedExperienceReplay ? this.prioritizedReplayBuffer.size : this.replayBuffer.size;
		this.lastAction = this.lastActionWithoutNoise.slice();
		var explorationNoise = this.noise.next();
		var noiseScale = !this.continueFromData && bufferSize * 2 < this.startReplay ? 3 : 1;
		if(this.applyNoise) {
			var _g1 = 0;
			var _g = this.actor.actionDim;
			while(_g1 < _g) {
				var i = _g1++;
				this.lastAction[i] += explorationNoise[i] * noiseScale;
			}
		}
		var result = this.agent.step(this.lastAction);
		var experience = new webdl_rl_ddpg_er_Experience(this.lastState,this.lastAction,result.reward,result.nextState,result.done);
		if(this.prioritizedExperienceReplay) {
			this.prioritizedReplayBuffer.push(experience);
		} else {
			this.replayBuffer.push(experience);
		}
		++bufferSize;
		this.lastReward = result.reward;
		this.totalReward += result.reward;
		this.lastState = result.nextState;
		if(!this.playingMode && !this.continueFromData && bufferSize < this.startReplay && this.normalizeObserbation) {
			webdl_core_WebDL.run(this.stateMeanStd.update(result.nextState));
		}
		this.episodeTime++;
		if(!disableEarlyReset && result.done || this.episodeTime >= this.maxEpisodeTime) {
			this.lastState = this.agent.reset();
			this.episodeTime = 0;
			this.episode++;
			this.totalRewards.push(this.totalReward);
			this.totalRewardInLastEpisode = this.totalReward;
			this.totalReward = 0;
			var _g2 = 0;
			while(_g2 < 1000) {
				var i1 = _g2++;
				this.noise.next();
			}
		}
		if(!this.playingMode && bufferSize >= this.startReplay && this.numSteps % this.updateInterval == 0) {
			if(this.experiences != null && this.prioritizedExperienceReplay) {
				var tdError = this.criticMiniBatchTdError.get1D();
				var _g11 = 0;
				var _g3 = this.minibatchSize;
				while(_g11 < _g3) {
					var i2 = _g11++;
					this.experiences[i2].absTdError = tdError[i2] < 0 ? -tdError[i2] : tdError[i2];
				}
				this.prioritizedReplayBuffer.update(this.experiences);
			}
			this.experiences = this.prioritizedExperienceReplay ? this.prioritizedReplayBuffer.sample(this.minibatchSize) : this.replayBuffer.sample(this.minibatchSize);
			var _g4 = [];
			var _g12 = 0;
			var _g21 = this.experiences;
			while(_g12 < _g21.length) {
				var e = _g21[_g12];
				++_g12;
				_g4.push(e.state);
			}
			var state = _g4;
			var _g13 = [];
			var _g22 = 0;
			var _g31 = this.experiences;
			while(_g22 < _g31.length) {
				var e1 = _g31[_g22];
				++_g22;
				_g13.push(e1.action);
			}
			var action = _g13;
			var _g23 = [];
			var _g32 = 0;
			var _g41 = this.experiences;
			while(_g32 < _g41.length) {
				var e2 = _g41[_g32];
				++_g32;
				_g23.push(e2.state2);
			}
			var state2 = _g23;
			var _g33 = [];
			var _g42 = 0;
			var _g5 = this.experiences;
			while(_g42 < _g5.length) {
				var e3 = _g5[_g42];
				++_g42;
				_g33.push(e3.reward * this.rewardScaleFactor);
			}
			var reward = _g33;
			var _g43 = [];
			var _g51 = 0;
			var _g6 = this.experiences;
			while(_g51 < _g6.length) {
				var e4 = _g6[_g51];
				++_g51;
				_g43.push(e4.done ? 0.0 : 1.0);
			}
			var notDone = _g43;
			this.critic.network.isTraining.set0D(1);
			this.critic.targetNetwork.isTraining.set0D(1);
			this.actor.network.isTraining.set0D(1);
			this.actor.targetNetwork.isTraining.set0D(1);
			this.unnormalizedState.set2D(state2);
			webdl_core_WebDL.run([this.assignNormalizedStateToActorTarget,this.assignNormalizedStateToCriticTarget]);
			this.unnormalizedState.set2D(state);
			webdl_core_WebDL.run([this.assignNormalizedStateToCritic,this.assignNormalizedStateToActor]);
			webdl_core_WebDL.run(this.predictAction);
			this.critic.network.inAction.set2D(action);
			this.criticMiniBatchReward.set1D(reward);
			this.criticMiniBatchNotDone.set1D(notDone);
			webdl_core_WebDL.run(this.predictQValue);
			this.criticOptimizer.run();
			this.critic.network.inAction.set2D(action);
			this.actorOptimizer.run();
			webdl_core_WebDL.run(this.updateTargetNetworksOps);
			this.critic.network.isTraining.set0D(0);
			this.critic.targetNetwork.isTraining.set0D(0);
			this.actor.network.isTraining.set0D(0);
			this.actor.targetNetwork.isTraining.set0D(0);
			return true;
		}
		return false;
	}
	,exportWeights: function() {
		var tensors = this.actor.network.tensorsToSave.concat(this.critic.network.tensorsToSave).concat([this.stateMeanStd.mean,this.stateMeanStd.std]);
		return webdl_core_WebDL.exportElements(tensors);
	}
	,importWeights: function(weights) {
		var tensors = this.actor.network.tensorsToSave.concat(this.critic.network.tensorsToSave).concat([this.stateMeanStd.mean,this.stateMeanStd.std]);
		webdl_core_WebDL.importElements(tensors,weights);
		webdl_core_WebDL.run(this.initTargetNetworksOps);
	}
	,exportBytes: function() {
		if(this.prioritizedExperienceReplay) {
			throw new js__$Boot_HaxeError("exporting bytes in prioritized experience replay mode is not supported");
		}
		var bo = new haxe_io_BytesOutput();
		bo.writeString("DDPG");
		webdl_rl_ddpg_BytesTools.writeFloatArray(bo,this.exportWeights());
		webdl_rl_ddpg_BytesTools.writeFloatArray(bo,this.actorOptimizer.exportData());
		webdl_rl_ddpg_BytesTools.writeFloatArray(bo,this.criticOptimizer.exportData());
		this.replayBuffer.writeBytes(bo);
		var res = bo.getBytes();
		bo.close();
		return res;
	}
	,importBytes: function(bytes) {
		if(this.prioritizedExperienceReplay) {
			throw new js__$Boot_HaxeError("importing bytes in prioritized experience replay mode is not supported");
		}
		var bi = new haxe_io_BytesInput(bytes);
		if(bi.readString(4) != "DDPG") {
			throw new js__$Boot_HaxeError("invalid data");
		}
		this.importWeights(webdl_rl_ddpg_BytesTools.readFloatArray(bi));
		this.actorOptimizer.importData(webdl_rl_ddpg_BytesTools.readFloatArray(bi));
		this.criticOptimizer.importData(webdl_rl_ddpg_BytesTools.readFloatArray(bi));
		this.replayBuffer = webdl_rl_ddpg_er_ReplayBuffer.readBytes(bi);
		bi.close();
	}
};
var webdl_rl_ddpg_DDPGSetting = function(agent,stateDim,actionRanges) {
	this.actionRanges = null;
	this.stateDim = -1;
	this.agent = null;
	this.maxEpisodeLength = 1000;
	this.minibatchSize = 64;
	this.updateInterval = 1;
	this.rewardScaleFactor = 0.01;
	this.targetUpdateTau = 0.01;
	this.gamma = 0.995;
	this.criticWeightDecay = 0.01;
	this.actorWeightDecay = 0.001;
	this.criticLearningRate = 0.001;
	this.actorLearningRate = 0.0001;
	this.normalizeObserbation = true;
	this.prioritizedReplay = false;
	this.startReplay = 5000;
	this.replayBufferSize = 500000;
	this.numHiddenUnits = 64;
	this.numHiddenLayers = 2;
	this.noiseSigma = 0.3;
	this.noiseTheta = 0.15;
	this.noise = true;
	this.evaluation = false;
	this.agent = agent;
	this.stateDim = stateDim;
	this.actionRanges = actionRanges;
};
webdl_rl_ddpg_DDPGSetting.__name__ = true;
var webdl_rl_ddpg_MeanStdTracker = function(shape) {
	this.sample = webdl_core_WebDL.tensorOfShape(shape);
	this.sum = webdl_core_WebDL.tensorOfShape(shape);
	this.sumSq = webdl_core_WebDL.tensorOfShape(shape);
	this.mean = webdl_core_WebDL.tensorOfShape(shape);
	this.std = webdl_core_WebDL.tensorOfShape(shape);
	this.count = webdl_core_WebDL.tensorOfValue(0);
	this.mean.fill(0);
	this.std.fill(1);
	this.mean.shouldBeSaved = true;
	this.std.shouldBeSaved = true;
	var newSum = webdl_core_WebDL.assign(this.sum,webdl_core_WebDL.add(this.sum,this.sample));
	var newSumSq = webdl_core_WebDL.assign(this.sumSq,webdl_core_WebDL.add(this.sumSq,webdl_core_WebDL.square(this.sample)));
	var newCount = webdl_core_WebDL.assign(this.count,webdl_core_WebDL.addConst(this.count,1));
	var newMean = webdl_core_WebDL.assign(this.mean,webdl_core_WebDL.div(newSum,newCount));
	var newStd = webdl_core_WebDL.assign(this.std,webdl_core_WebDL.powConst(webdl_core_WebDL.addConst(webdl_core_WebDL.sub(webdl_core_WebDL.div(newSumSq,newCount),webdl_core_WebDL.square(newMean)),1e-6),0.5));
	this.updates = [newMean,newStd];
};
webdl_rl_ddpg_MeanStdTracker.__name__ = true;
webdl_rl_ddpg_MeanStdTracker.prototype = {
	update: function(sampleDataArray) {
		this.sample.setArray(sampleDataArray);
		return this.updates;
	}
};
var webdl_rl_ddpg_OrnsteinUhlenbeckNoise = function(dim,mu,theta,sigma,dt) {
	if(dt == null) {
		dt = 0.01;
	}
	if(sigma == null) {
		sigma = 0.3;
	}
	if(theta == null) {
		theta = 0.15;
	}
	if(mu == null) {
		mu = 0;
	}
	this.dim = dim;
	this.mu = mu;
	this.theta = theta;
	this.sigma = sigma;
	this.dt = dt;
	var _g = [];
	var _g2 = 0;
	var _g1 = dim;
	while(_g2 < _g1) {
		var i = _g2++;
		_g.push(0);
	}
	this.xs = _g;
};
webdl_rl_ddpg_OrnsteinUhlenbeckNoise.__name__ = true;
webdl_rl_ddpg_OrnsteinUhlenbeckNoise.prototype = {
	next: function() {
		var _g1 = 0;
		var _g = this.dim;
		while(_g1 < _g) {
			var i = _g1++;
			this.xs[i] += (this.mu - this.xs[i]) * this.theta * this.dt + this.sigma * (Math.sqrt(-2 * this.dt * Math.log(Math.random())) * Math.sin(2 * Math.PI * Math.random()));
		}
		return this.xs;
	}
};
var webdl_rl_ddpg_er_Experience = function(state,action,reward,state2,done) {
	this.state = state;
	this.action = action;
	this.reward = reward;
	this.state2 = state2;
	this.done = done;
	this.absTdError = 10000;
	this.p = 0;
	this.index = -1;
};
webdl_rl_ddpg_er_Experience.__name__ = true;
var webdl_rl_ddpg_er_FenwickTree = function(maxSize) {
	this.maxSize = maxSize;
	var this1 = new Array(maxSize);
	this.tree = this1;
	var this2 = new Array(maxSize);
	this.rawValues = this2;
	var _g1 = 0;
	var _g = maxSize;
	while(_g1 < _g) {
		var i = _g1++;
		this.tree[i] = 0;
		this.rawValues[i] = 0;
	}
};
webdl_rl_ddpg_er_FenwickTree.__name__ = true;
webdl_rl_ddpg_er_FenwickTree.prototype = {
	set: function(i,value) {
		var diff = value - this.rawValues[i];
		this.rawValues[i] = value;
		++i;
		while(i <= this.maxSize) {
			var _g = i - 1;
			var _g1 = this.tree;
			_g1[_g] = _g1[_g] + diff;
			i += i & -i;
		}
	}
	,get: function(i) {
		return this.rawValues[i];
	}
	,getSum: function(i) {
		++i;
		var sum = 0;
		while(i >= 1) {
			sum += this.tree[i - 1];
			i -= i & -i;
		}
		return sum;
	}
	,refresh: function() {
		var _g1 = 0;
		var _g = this.maxSize;
		while(_g1 < _g) {
			var i = _g1++;
			this.tree[i] = this.rawValues[i];
		}
		var _g11 = 1;
		var _g2 = this.maxSize;
		while(_g11 < _g2) {
			var i1 = _g11++;
			var _g21 = i1 - 1 + (i1 & -i1);
			var _g3 = this.tree;
			_g3[_g21] = _g3[_g21] + this.tree[i1 - 1];
		}
	}
};
var webdl_rl_ddpg_er_PrioritizedReplayBuffer = function(bufferSize) {
	this.bufferSize = bufferSize;
	var this1 = new Array(bufferSize);
	this.exps = this1;
	this.tree = new webdl_rl_ddpg_er_FenwickTree(bufferSize);
	this.pointer = 0;
	this.size = 0;
	this.sampleCount = 0;
	this.filled = false;
};
webdl_rl_ddpg_er_PrioritizedReplayBuffer.__name__ = true;
webdl_rl_ddpg_er_PrioritizedReplayBuffer.prototype = {
	push: function(e) {
		if(this.pointer == this.bufferSize) {
			this.filled = true;
			this.pointer = 0;
		}
		this.exps[this.pointer] = e;
		e.index = this.pointer;
		e.p = Math.pow(e.absTdError + 0.01,0.6);
		this.tree.set(this.pointer,e.p);
		this.size = this.filled ? this.bufferSize : this.pointer;
		this.pointer++;
	}
	,update: function(es) {
		var _g = 0;
		while(_g < es.length) {
			var e = es[_g];
			++_g;
			e.p = Math.pow(e.absTdError + 0.01,0.6);
			this.tree.set(e.index,e.p);
		}
	}
	,sample: function(num) {
		if(++this.sampleCount % 500 == 0) {
			this.tree.refresh();
		}
		var res = [];
		var invSum = 1 / this.tree.getSum(this.size);
		var _g1 = 0;
		var _g = num;
		while(_g1 < _g) {
			var i = _g1++;
			var x = Math.random() * this.tree.getSum(this.size);
			var min = -1;
			var max = this.size - 1;
			while(max - min > 1) {
				var mid = min + max >> 1;
				if(this.tree.getSum(mid) > x) {
					max = mid;
				} else {
					min = mid;
				}
			}
			res.push(this.exps[max]);
			this.tree.set(max,0);
		}
		var _g2 = 0;
		while(_g2 < res.length) {
			var e = res[_g2];
			++_g2;
			this.tree.set(e.index,e.p);
		}
		return res;
	}
};
var webdl_rl_ddpg_er_ReplayBuffer = function(maxBufferSize) {
	this.maxBufferSize = maxBufferSize;
	var this1 = new Array(maxBufferSize);
	this.buffer = this1;
	this.size = 0;
	this.index = 0;
};
webdl_rl_ddpg_er_ReplayBuffer.__name__ = true;
webdl_rl_ddpg_er_ReplayBuffer.readBytes = function(bi) {
	var maxBufferSize = bi.readInt32();
	if(maxBufferSize > 3000000) {
		maxBufferSize = 3000000;
	}
	var rb = new webdl_rl_ddpg_er_ReplayBuffer(maxBufferSize);
	rb.size = bi.readInt32();
	rb.index = bi.readInt32();
	var _g1 = 0;
	var _g = rb.size;
	while(_g1 < _g) {
		var i = _g1++;
		rb.buffer[i] = new webdl_rl_ddpg_er_Experience(webdl_rl_ddpg_BytesTools.readFloatArray(bi),webdl_rl_ddpg_BytesTools.readFloatArray(bi),bi.readFloat(),webdl_rl_ddpg_BytesTools.readFloatArray(bi),bi.readByte() != 0);
	}
	return rb;
};
webdl_rl_ddpg_er_ReplayBuffer.prototype = {
	clear: function() {
		while(this.size > 0) this.buffer[--this.size] = null;
		this.index = 0;
	}
	,push: function(experience) {
		this.buffer[this.index] = experience;
		this.index = (this.index + 1) % this.maxBufferSize;
		if(this.size < this.maxBufferSize) {
			this.size++;
		}
	}
	,sample: function(num) {
		var res = [];
		var _g1 = 0;
		var _g = num;
		while(_g1 < _g) {
			var i = _g1++;
			res.push(this.buffer[Std.random(this.size)]);
		}
		return res;
	}
	,writeBytes: function(bo) {
		bo.writeInt32(this.maxBufferSize);
		bo.writeInt32(this.size);
		bo.writeInt32(this.index);
		var _g1 = 0;
		var _g = this.size;
		while(_g1 < _g) {
			var i = _g1++;
			var e = this.buffer[i];
			webdl_rl_ddpg_BytesTools.writeFloatArray(bo,e.state);
			webdl_rl_ddpg_BytesTools.writeFloatArray(bo,e.action);
			bo.writeFloat(e.reward);
			webdl_rl_ddpg_BytesTools.writeFloatArray(bo,e.state2);
			bo.writeByte(e.done ? 1 : 0);
		}
	}
};
var $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
String.__name__ = true;
Array.__name__ = true;
Date.__name__ = ["Date"];
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
var ArrayBuffer = $global.ArrayBuffer || js_html_compat_ArrayBuffer;
if(ArrayBuffer.prototype.slice == null) {
	ArrayBuffer.prototype.slice = js_html_compat_ArrayBuffer.sliceImpl;
}
var DataView = $global.DataView || js_html_compat_DataView;
var Float32Array = $global.Float32Array || js_html_compat_Float32Array._new;
var Uint8Array = $global.Uint8Array || js_html_compat_Uint8Array._new;
_$PendulumTest_PendulumAgent.MAX_TORQUE = 4;
_$PendulumTest_PendulumAgent.MAX_VELOCITY = 8;
haxe_io_FPHelper.i64tmp = (function($this) {
	var $r;
	var this1 = new haxe__$Int64__$_$_$Int64(0,0);
	$r = this1;
	return $r;
}(this));
haxe_io_FPHelper.helper = new DataView(new ArrayBuffer(8));
js_html_compat_Float32Array.BYTES_PER_ELEMENT = 4;
js_html_compat_Uint8Array.BYTES_PER_ELEMENT = 1;
pot_graphics_Graphics.MAT_STACK_SIZE = 1024;
pot_graphics_Graphics.MAX_LIGHTS = 8;
pot_graphics__$Shader_Uniform.INT = 0;
pot_graphics__$Shader_Uniform.INT2 = 1;
pot_graphics__$Shader_Uniform.INT3 = 2;
pot_graphics__$Shader_Uniform.INT4 = 3;
pot_graphics__$Shader_Uniform.FLOAT = 4;
pot_graphics__$Shader_Uniform.FLOAT2 = 5;
pot_graphics__$Shader_Uniform.FLOAT3 = 6;
pot_graphics__$Shader_Uniform.FLOAT4 = 7;
pot_graphics__$Shader_Uniform.MATRIX2 = 8;
pot_graphics__$Shader_Uniform.MATRIX3 = 9;
pot_graphics__$Shader_Uniform.MATRIX4 = 10;
pot_graphics__$Shader_Uniform.TEX2D = 11;
pot_util_Timer.MIN_SLEEP_TIME = 4;
webdl_core_backend_gpu_GpuShader.FORWARD = 0;
webdl_core_backend_gpu_GpuShader.BACKWARD_ACCUMULATE = 1;
webdl_core_backend_gpu_GpuShader.BACKWARD_OVERWRITE = 2;
webdl_core_backend_gpu_ShaderConsts.A_POS = "aPos";
webdl_core_backend_gpu_ShaderConsts.A_UV = "aUv";
webdl_core_backend_gpu_ShaderConsts.V_UV = "vUv";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX = "uSrcTex";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX_SIZE = "uSrcTexSize";
webdl_core_backend_gpu_ShaderConsts.U_SRC_INV_TEX_SIZE = "uSrcInvTexSize";
webdl_core_backend_gpu_ShaderConsts.U_SRC_RANK = "uSrcRank";
webdl_core_backend_gpu_ShaderConsts.U_SRC_SHAPE = "uSrcShape";
webdl_core_backend_gpu_ShaderConsts.U_SRC_STRIDE = "uSrcStride";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX1 = "uSrcTex" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX_SIZE1 = "uSrcTexSize" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_INV_TEX_SIZE1 = "uSrcInvTexSize" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_RANK1 = "uSrcRank" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_SHAPE1 = "uSrcShape" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_STRIDE1 = "uSrcStride" + "1";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX2 = "uSrcTex" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX_SIZE2 = "uSrcTexSize" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_INV_TEX_SIZE2 = "uSrcInvTexSize" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_RANK2 = "uSrcRank" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_SHAPE2 = "uSrcShape" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_STRIDE2 = "uSrcStride" + "2";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX3 = "uSrcTex" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX_SIZE3 = "uSrcTexSize" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_INV_TEX_SIZE3 = "uSrcInvTexSize" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_RANK3 = "uSrcRank" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_SHAPE3 = "uSrcShape" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_STRIDE3 = "uSrcStride" + "3";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX4 = "uSrcTex" + "4";
webdl_core_backend_gpu_ShaderConsts.U_SRC_TEX_SIZE4 = "uSrcTexSize" + "4";
webdl_core_backend_gpu_ShaderConsts.U_SRC_INV_TEX_SIZE4 = "uSrcInvTexSize" + "4";
webdl_core_backend_gpu_ShaderConsts.U_SRC_RANK4 = "uSrcRank" + "4";
webdl_core_backend_gpu_ShaderConsts.U_SRC_SHAPE4 = "uSrcShape" + "4";
webdl_core_backend_gpu_ShaderConsts.U_SRC_STRIDE4 = "uSrcStride" + "4";
webdl_core_backend_gpu_ShaderConsts.U_DST_TEX = "uDstTex";
webdl_core_backend_gpu_ShaderConsts.U_DST_TEX_SIZE = "uDstTexSize";
webdl_core_backend_gpu_ShaderConsts.U_DST_INV_TEX_SIZE = "uDstInvTexSize";
webdl_core_backend_gpu_ShaderConsts.U_DST_RANK = "uDstRank";
webdl_core_backend_gpu_ShaderConsts.U_DST_SHAPE = "uDstShape";
webdl_core_backend_gpu_ShaderConsts.U_DST_STRIDE = "uDstStride";
webdl_core_backend_gpu_ShaderConsts.U_DST_ACTUAL_SIZE = "uDstActualSize";
webdl_core_backend_gpu_ShaderConsts.MAX_DIMENSION_SIZE = 1000000;
webdl_core_backend_gpu_ShaderConsts.SRC_ACCESS1 = "texture2D(" + ("uSrcTex" + "1") + ", " + "vUv" + ")";
webdl_core_backend_gpu_ShaderConsts.SRC_ACCESS2 = "texture2D(" + ("uSrcTex" + "2") + ", " + "vUv" + ")";
webdl_core_backend_gpu_ShaderConsts.SRC_ACCESS3 = "texture2D(" + ("uSrcTex" + "3") + ", " + "vUv" + ")";
webdl_core_backend_gpu_ShaderConsts.SRC_ACCESS4 = "texture2D(" + ("uSrcTex" + "4") + ", " + "vUv" + ")";
webdl_core_graph_Graph.time = 0;
webdl_rl_ddpg_er_PrioritizedReplayBuffer.ALPHA = 0.6;
webdl_rl_ddpg_er_PrioritizedReplayBuffer.EPSILON = 0.01;
PendulumTest.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
